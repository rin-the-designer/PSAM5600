import { evaluate as T } from "@strudel/core";
import { getLeafLocations as v } from "@strudel/mini";
import { parse as W } from "acorn";
import S from "escodegen";
import { walk as $ } from "estree-walker";
let E = [];
function N(t) {
  E.push(t);
}
let m = /* @__PURE__ */ new Map();
function U(t, i) {
  m.set(t, i);
}
function d(t, i = {}) {
  const { wrapAsync: a = !1, addReturn: l = !0, emitMiniLocations: s = !0, emitWidgets: L = !0 } = i;
  let h = W(t, {
    ecmaVersion: 2022,
    allowAwaitOutsideFunction: !0,
    locations: !0
  }), u = [];
  const x = (e, c) => {
    const n = m.get("minilang");
    if (n) {
      const r = `[${e}]`, o = n.getLocations(r, c.start);
      u = u.concat(o);
    } else {
      const r = v(`"${e}"`, c.start, t);
      u = u.concat(r);
    }
  };
  let f = [];
  $(h, {
    enter(e, c) {
      if (R(e)) {
        const { name: n } = e.tag, r = m.get(n), o = e.quasi.quasis[0].value.raw, y = e.quasi.start + 1;
        if (s) {
          const b = r.getLocations(o, y);
          u = u.concat(b);
        }
        return this.skip(), this.replace(Q(n, o, y));
      }
      if (j(e, "tidal")) {
        const n = e.quasi.quasis[0].value.raw, r = e.quasi.start + 1;
        if (s) {
          const o = H(n, r);
          u = u.concat(o);
        }
        return this.skip(), this.replace(P(n, r));
      }
      if (q(e, c)) {
        const { quasis: n } = e, { raw: r } = n[0].value;
        return this.skip(), s && x(r, e), this.replace(w(r, e));
      }
      if (k(e)) {
        const { value: n } = e;
        return this.skip(), s && x(n, e), this.replace(w(n, e));
      }
      if (I(e))
        return L && f.push({
          from: e.arguments[0].start,
          to: e.arguments[0].end,
          value: e.arguments[0].raw,
          // don't use value!
          min: e.arguments[1]?.value ?? 0,
          max: e.arguments[2]?.value ?? 1,
          step: e.arguments[3]?.value,
          type: "slider"
        }), this.replace(C(e));
      if (M(e)) {
        const n = e.callee.property.name, r = f.filter((y) => y.type === n).length, o = {
          to: e.end,
          index: r,
          type: n,
          id: i.id
        };
        return L && f.push(o), this.replace(_(e, o));
      }
      if (D(e, c))
        return this.replace(B(e));
      if (F(e))
        return this.replace(O(e));
    },
    leave(e, c, n, r) {
    }
  });
  let { body: p } = h;
  if (!p.length)
    console.warn("empty body -> fallback to silence"), p.push({
      type: "ExpressionStatement",
      expression: {
        type: "Identifier",
        name: "silence"
      }
    });
  else if (!p?.[p.length - 1]?.expression)
    throw new Error("unexpected ast format without body expression");
  if (l) {
    const { expression: e } = p[p.length - 1];
    p[p.length - 1] = {
      type: "ReturnStatement",
      argument: e
    };
  }
  let g = S.generate(h);
  return a && (g = `(async ()=>{${g}})()`), s ? { output: g, miniLocations: u, widgets: f } : { output: g };
}
function k(t, i, a) {
  return t.type !== "Literal" ? !1 : t.raw[0] === '"';
}
function q(t, i) {
  return t.type === "TemplateLiteral" && i.type !== "TaggedTemplateExpression";
}
function w(t, i) {
  const { start: a } = i, l = m.get("minilang");
  let s = "m";
  return l && l.name && (s = l.name), {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: s
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: a }
    ],
    optional: !1
  };
}
function I(t) {
  return t.type === "CallExpression" && t.callee.name === "slider";
}
function M(t) {
  return t.type === "CallExpression" && E.includes(t.callee.property?.name);
}
function C(t) {
  const i = "slider_" + t.arguments[0].start;
  return t.arguments.unshift({
    type: "Literal",
    value: i,
    raw: i
  }), t.callee.name = "sliderWithID", t;
}
function A(t) {
  return `${t.id || ""}_widget_${t.type}_${t.index}`;
}
function _(t, i) {
  const a = A(i);
  return t.arguments.unshift({
    type: "Literal",
    value: a,
    raw: a
  }), t;
}
function D(t, i) {
  return t.type === "CallExpression" && t.callee.name === "samples" && i.type !== "AwaitExpression";
}
function B(t) {
  return {
    type: "AwaitExpression",
    argument: t
  };
}
function F(t) {
  return t.type === "LabeledStatement";
}
function O(t) {
  return {
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: t.body.expression,
        property: {
          type: "Identifier",
          name: "p"
        }
      },
      arguments: [
        {
          type: "Literal",
          value: t.label.name,
          raw: `'${t.label.name}'`
        }
      ]
    }
  };
}
function R(t) {
  return t.type === "TaggedTemplateExpression" && m.has(t.tag.name);
}
function j(t, i) {
  return t.type === "TaggedTemplateExpression" && t.tag.name === i;
}
function H(t, i) {
  return t.split("").reduce((a, l, s) => (l !== '"' || (!a.length || a[a.length - 1].length > 1 ? a.push([s + 1]) : a[a.length - 1].push(s)), a), []).map(([a, l]) => {
    const s = t.slice(a, l);
    return v(`"${s}"`, i + a - 1);
  }).flat();
}
function P(t, i) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "tidal"
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: i }
    ],
    optional: !1
  };
}
function Q(t, i, a) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: t
    },
    arguments: [
      { type: "Literal", value: i },
      { type: "Literal", value: a }
    ],
    optional: !1
  };
}
const X = (t) => T(t, d);
export {
  X as evaluate,
  A as getWidgetID,
  U as registerLanguage,
  N as registerWidgetType,
  d as transpiler
};
