import { map as on } from "nanostores";
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, o, a, c) {
      super(n), o = Math.abs(o), this.delayTime.value = a;
      const s = n.createGain();
      s.gain.value = Math.min(Math.abs(c), 0.995), this.feedback = s.gain;
      const d = n.createGain();
      return d.gain.value = o, this.delayGain = d, this.connect(s), this.connect(d), s.connect(this), this.connect = (l) => d.connect(l), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, o) {
    return new t(this, e, n, o);
  };
}
var Pt = {};
Pt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), o = n.sampleRate, a = t.numChannels || 2, c = t.decayTime * 1.5, s = Math.round(t.decayTime * o), d = Math.round(c * o), l = Math.round((t.fadeInTime || 0) * o), i = Math.pow(1 / 1e3, 1 / s), r = n.createBuffer(a, d, o), h = 0; h < a; h++) {
    for (var m = r.getChannelData(h), u = 0; u < d; u++)
      m[u] = an() * Math.pow(i, u);
    for (var u = 0; u < l; u++)
      m[u] *= u / l;
  }
  cn(r, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
Pt.generateGraph = function(t, e, n, o, a) {
  var c = document.createElement("canvas");
  c.width = e, c.height = n;
  var s = c.getContext("2d");
  s.fillStyle = "#000", s.fillRect(0, 0, c.width, c.height), s.fillStyle = "#fff";
  for (var d = e / t.length, l = n / (a - o), i = 0; i < t.length; i++)
    s.fillRect(i * d, n - (t[i] - o) * l, 1, 1);
  return c;
};
var cn = function(t, e, n, o, a) {
  if (e == 0) {
    a(t);
    return;
  }
  var c = sn(t), s = new OfflineAudioContext(t.numberOfChannels, c[0].length, t.sampleRate), d = s.createBufferSource();
  d.buffer = t;
  var l = s.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), l.type = "lowpass", l.Q.value = 1e-4, l.frequency.setValueAtTime(e, 0), l.frequency.linearRampToValueAtTime(n, o), d.connect(l), l.connect(s.destination), d.start(), s.oncomplete = function(i) {
    a(i.renderedBuffer);
  }, s.startRendering(), window.filterNode = l;
}, sn = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
}, an = function() {
  return Math.random() * 2 - 1;
};
let be = (t) => console.log(t);
function Xe(t, e = "cyclist") {
  J(`[${e}] error: ${t.message}`);
}
const J = (...t) => be(...t), so = (t) => {
  be = t;
}, dn = (t) => {
  if (typeof t != "string")
    return [];
  const [e, n = "", o] = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return e ? [e, n, o ? Number(o) : void 0] : [];
}, ln = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, rn = { "#": 1, b: -1, s: 1, f: -1 }, Wt = (t, e = 3) => {
  const [n, o, a = e] = dn(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const c = ln[n.toLowerCase()], s = o?.split("").reduce((d, l) => d + rn[l], 0) || 0;
  return (Number(a) + 1) * 12 + c + s;
}, ye = (t) => Math.pow(2, (t - 69) / 12) * 440, $ = (t, e, n) => Math.min(Math.max(t, e), n), un = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69, mn = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: o } = t;
  return typeof n == "number" ? un(n) : typeof o == "string" ? Wt(o) : typeof o == "number" ? o : e;
};
function U(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && J(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
const Ge = (t, e) => (t % e + e) % e, re = (t, e) => Ge(Math.round(U(t, 0)), e);
function hn(t, e) {
  return t / e;
}
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e, n = 1, o = 0) {
  const a = Math.floor($(o, 0, 1) * e.length), c = e.sampleRate * t, s = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let d = 0; d < e.numberOfChannels; d++) {
    let l = e.getChannelData(d), i = s.getChannelData(d);
    for (let r = 0; r < c; r++) {
      let h = (a + r * Math.abs(n)) % l.length;
      n < 1 && (h = h * -1), i[r] = l.at(h) || 0;
    }
  }
  return s;
}, AudioContext.prototype.createReverb = function(t, e, n, o, a, c, s) {
  const d = this.createConvolver();
  return d.generate = (l = 2, i = 0.1, r = 15e3, h = 1e3, m, u, p) => {
    d.duration = l, d.fade = i, d.lp = r, d.dim = h, d.ir = m, d.irspeed = u, d.irbegin = p, m ? d.buffer = this.adjustLength(l, m, u, p) : Pt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: l,
        fadeInTime: i,
        lpFreqStart: r,
        lpFreqEnd: h
      },
      (Z) => {
        d.buffer = Z;
      }
    );
  }, d.generate(t, e, n, o, a, c, s), d;
});
var ue = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, o) {
      if (super(n), !ue[o])
        throw new Error("vowel: unknown vowel " + o);
      const { gains: a, qs: c, freqs: s } = ue[o], d = n.createGain();
      for (let l = 0; l < 5; l++) {
        const i = n.createGain();
        i.gain.value = a[l];
        const r = n.createBiquadFilter();
        r.type = "bandpass", r.Q.value = c[l], r.frequency.value = s[l], this.connect(r), r.connect(i), i.connect(d);
      }
      return d.gain.value = 8, this.connect = (l) => d.connect(l), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
const pn = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIGd0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBvPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW8/ITE6KHRoaXMuc3RhcnRlZD1vLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBJdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYT1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYSksZVtzKzFdPS1NYXRoLnNpbihhKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbz0xO3RoaXMuc2l6ZT5vO288PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgdT0wO3U8dGhpcy5fd2lkdGg7dSs9Mil7dmFyIGM9dGhpcy5fd2lkdGgtdS0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj51JjMpPDxjfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG89ZS9yPDwxLGksdSxjPXRoaXMuX2JpdHJldjtpZihvPT09NClmb3IoaT0wLHU9MDtpPGU7aSs9byx1Kyspe2NvbnN0IGQ9Y1t1XTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksZCxyKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZD1jW3VdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxkLHIpfXZhciBhPXRoaXMuX2ludj8tMToxLGg9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bz1lL3I8PDE7dmFyIG09bz4+PjI7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIHA9aSttLGw9aSxmPTA7bDxwO2wrPTIsZis9cil7Y29uc3QgZD1sLHY9ZCttLGc9dittLEk9ZyttLGI9dFtkXSxCPXRbZCsxXSxfPXRbdl0sdz10W3YrMV0sVD10W2ddLFA9dFtnKzFdLHk9dFtJXSxBPXRbSSsxXSx4PWIsVj1CLEY9aFtmXSxNPWEqaFtmKzFdLE89XypGLXcqTSxOPV8qTSt3KkYsWT1oWzIqZl0sTD1hKmhbMipmKzFdLEg9VCpZLVAqTCxVPVQqTCtQKlksSz1oWzMqZl0sWj1hKmhbMypmKzFdLCQ9eSpLLUEqWixHPXkqWitBKkssaj14K0gsaz1WK1Usej14LUgsSj1WLVUsUT1PKyQsRT1OK0csUj1hKihPLSQpLFg9YSooTi1HKSxzdD1qK1EsaXQ9aytFLG90PWotUSxhdD1rLUUsdXQ9eitYLGh0PUotUixjdD16LVgsbHQ9SitSO3RbZF09c3QsdFtkKzFdPWl0LHRbdl09dXQsdFt2KzFdPWh0LHRbZ109b3QsdFtnKzFdPWF0LHRbSV09Y3QsdFtJKzFdPWx0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2UrMV0sYz1vW2Urc10sYT1vW2UrcysxXSxoPWkrYyxtPXUrYSxwPWktYyxsPXUtYTtyW3RdPWgsclt0KzFdPW0sclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLHU9cyoyLGM9cyozLGE9b1tlXSxoPW9bZSsxXSxtPW9bZStzXSxwPW9bZStzKzFdLGw9b1tlK3VdLGY9b1tlK3UrMV0sZD1vW2UrY10sdj1vW2UrYysxXSxnPWErbCxJPWgrZixiPWEtbCxCPWgtZixfPW0rZCx3PXArdixUPWkqKG0tZCksUD1pKihwLXYpLHk9ZytfLEE9SSt3LHg9YitQLFY9Qi1ULEY9Zy1fLE09SS13LE89Yi1QLE49QitUO3JbdF09eSxyW3QrMV09QSxyW3QrMl09eCxyW3QrM109VixyW3QrNF09RixyW3QrNV09TSxyW3QrNl09TyxyW3QrN109Tn1fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxvPWUvcjw8MSxpLHUsYz10aGlzLl9iaXRyZXY7aWYobz09PTQpZm9yKGk9MCx1PTA7aTxlO2krPW8sdSsrKXtjb25zdCBmdD1jW3VdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGksZnQ+Pj4xLHI+Pj4xKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZnQ9Y1t1XTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChpLGZ0Pj4+MSxyPj4+MSl9dmFyIGE9dGhpcy5faW52Py0xOjEsaD10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtvPWUvcjw8MTt2YXIgbT1vPj4+MSxwPW0+Pj4xLGw9cD4+PjE7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIGY9MCxkPTA7Zjw9bDtmKz0yLGQrPXIpe3ZhciB2PWkrZixnPXYrcCxJPWcrcCxiPUkrcCxCPXRbdl0sXz10W3YrMV0sdz10W2ddLFQ9dFtnKzFdLFA9dFtJXSx5PXRbSSsxXSxBPXRbYl0seD10W2IrMV0sVj1CLEY9XyxNPWhbZF0sTz1hKmhbZCsxXSxOPXcqTS1UKk8sWT13Kk8rVCpNLEw9aFsyKmRdLEg9YSpoWzIqZCsxXSxVPVAqTC15KkgsSz1QKkgreSpMLFo9aFszKmRdLCQ9YSpoWzMqZCsxXSxHPUEqWi14KiQsaj1BKiQreCpaLGs9VitVLHo9RitLLEo9Vi1VLFE9Ri1LLEU9TitHLFI9WStqLFg9YSooTi1HKSxzdD1hKihZLWopLGl0PWsrRSxvdD16K1IsYXQ9SitzdCx1dD1RLVg7aWYodFt2XT1pdCx0W3YrMV09b3QsdFtnXT1hdCx0W2crMV09dXQsZj09PTApe3ZhciBodD1rLUUsY3Q9ei1SO3RbSV09aHQsdFtJKzFdPWN0O2NvbnRpbnVlfWlmKGYhPT1sKXt2YXIgbHQ9SixFdD0tUSxSdD1rLER0PS16LHF0PS1hKnN0LFd0PS1hKlgsWXQ9LWEqUixMdD0tYSpFLEh0PWx0K3F0LFV0PUV0K1d0LEt0PVJ0K0x0LFp0PUR0LVl0LG10PWkrcC1mLHZ0PWkrbS1mO3RbbXRdPUh0LHRbbXQrMV09VXQsdFt2dF09S3QsdFt2dCsxXT1adH19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2Urc10sYz1pK3UsYT1pLXU7clt0XT1jLHJbdCsxXT0wLHJbdCsyXT1hLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsbz10aGlzLl9kYXRhLGk9dGhpcy5faW52Py0xOjEsdT1zKjIsYz1zKjMsYT1vW2VdLGg9b1tlK3NdLG09b1tlK3VdLHA9b1tlK2NdLGw9YSttLGY9YS1tLGQ9aCtwLHY9aSooaC1wKSxnPWwrZCxJPWYsYj0tdixCPWwtZCxfPWYsdz12O3JbdF09ZyxyW3QrMV09MCxyW3QrMl09SSxyW3QrM109YixyW3QrNF09QixyW3QrNV09MCxyW3QrNl09XyxyW3QrN109d319Y29uc3QgQz0obix0LGUpPT5NYXRoLm1pbihNYXRoLm1heChuLHQpLGUpLHB0PShuLHQpPT4obiV0K3QpJXQ7ZnVuY3Rpb24gYnQobix0PTEpe3JldHVybiBuPj10P24tPXQ6bjwwJiYobis9dCksbn1jb25zdCBEPTEyODtmdW5jdGlvbiBCdChuLHQpe3JldHVybiB0PU1hdGgubWluKHQsMS10KSxuPHQ/KG4vPXQsbituLW4qbi0xKTpuPjEtdD8obj0obi0xKS90LG4qbituK24rMSk6MH1jb25zdCBydD17dHJpKG4sdD0uNSl7Y29uc3QgZT0xLXQ7cmV0dXJuIG4+PXQ/MS9lLW4vZTpuL3R9LHNpbmUobil7cmV0dXJuIE1hdGguc2luKE1hdGguUEkqMipuKSouNSsuNX0scmFtcChuKXtyZXR1cm4gbn0sc2F3KG4pe3JldHVybiAxLW59LHNxdWFyZShuLHQ9LjUpe3JldHVybiBuPj10PzA6MX0sY3VzdG9tKG4sdD1bMCwxXSl7Y29uc3QgZT10Lmxlbmd0aC0xLHM9TWF0aC5mbG9vcihuKmUpLHI9MS9lLG89Qyh0W3NdLDAsMSksdT1DKHRbcysxXSwwLDEpLGM9byxhPTAsaD1yO3JldHVybih1LWMpLyhoLWEpKihuLXIqcykrb30sc2F3YmxlcChuLHQpe3JldHVybiAyKm4tMS1CdChuLHQpfX07ZnVuY3Rpb24gcShuLHQpe3JldHVybiB0Lmxlbmd0aD4xP3Rbbl06dFswXX1jb25zdCBfdD1PYmplY3Qua2V5cyhydCk7Y2xhc3Mgd3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToidGltZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJza2V3IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJkZXB0aCIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJwaGFzZW9mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJjdXJ2ZSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkY29mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJtaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToibWF4IixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlfWluY3JlbWVudFBoYXNlKHQpe3RoaXMucGhhc2UrPXQsdGhpcy5waGFzZT4xJiYodGhpcy5waGFzZT10aGlzLnBoYXNlLTEpfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9cy5iZWdpblswXTtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXIpcmV0dXJuITA7Y29uc3Qgbz1lWzBdLGk9cy5mcmVxdWVuY3lbMF0sdT1zLnRpbWVbMF0sYz1zLmRlcHRoWzBdLGE9cy5za2V3WzBdLGg9cy5waGFzZW9mZnNldFswXSxtPXMuY3VydmVbMF0scD1zLmRjb2Zmc2V0WzBdLGw9cy5taW5bMF0sZj1zLm1heFswXSxkPV90W3Muc2hhcGVbMF1dLHY9b1swXS5sZW5ndGg/PzA7dGhpcy5waGFzZT09bnVsbCYmKHRoaXMucGhhc2U9cHQodSppK2gsMSkpO2NvbnN0IGc9aS9zYW1wbGVSYXRlO2ZvcihsZXQgST0wO0k8djtJKyspe2ZvcihsZXQgYj0wO2I8by5sZW5ndGg7YisrKXtsZXQgQj0ocnRbZF0odGhpcy5waGFzZSxhKStwKSpjO0I9TWF0aC5wb3coQixtKSxvW2JdW0ldPUMoQixsLGYpfXRoaXMuaW5jcmVtZW50UGhhc2UoZyl9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsZm8tcHJvY2Vzc29yIix3dCk7Y2xhc3MgU3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY29hcnNlIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgdT1zLmNvYXJzZVswXT8/MDt1PU1hdGgubWF4KDEsdSk7Zm9yKGxldCBjPTA7YzxEO2MrKylmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKylvW2FdW2NdPWMldT09PTA/clthXVtjXTpvW2FdW2MtMV07cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjb2Fyc2UtcHJvY2Vzc29yIixTdCk7Y2xhc3MgVHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY3J1c2giLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCB1PXMuY3J1c2hbMF0/Pzg7dT1NYXRoLm1heCgxLHUpO2ZvcihsZXQgYz0wO2M8RDtjKyspZm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspe2NvbnN0IGg9TWF0aC5wb3coMix1LTEpO29bYV1bY109TWF0aC5yb3VuZChyW2FdW2NdKmgpL2h9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjcnVzaC1wcm9jZXNzb3IiLFR0KTtjbGFzcyBQdCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxvPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IHU9cy5zaGFwZVswXTt1PXU8MT91OjEtNGUtMTAsdT0yKnUvKDEtdSk7Y29uc3QgYz1NYXRoLm1heCguMDAxLE1hdGgubWluKDEscy5wb3N0Z2FpblswXSkpO2ZvcihsZXQgYT0wO2E8RDthKyspZm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspb1toXVthXT0oMSt1KSpyW2hdW2FdLygxK3UqTWF0aC5hYnMocltoXVthXSkpKmM7cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzaGFwZS1wcm9jZXNzb3IiLFB0KTtmdW5jdGlvbiBTKG4pe2NvbnN0IHQ9bipuO3JldHVybiBuKigyNyt0KS8oMjcrOSp0KX1jb25zdCBkdD0zLjE0MTU5MjY1MzU5O2NsYXNzIHl0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjUwMH0se25hbWU6InEiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToiZHJpdmUiLGRlZmF1bHRWYWx1ZTouNjl9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExLHRoaXMucDA9WzAsMF0sdGhpcy5wMT1bMCwwXSx0aGlzLnAyPVswLDBdLHRoaXMucDM9WzAsMF0sdGhpcy5wMzI9WzAsMF0sdGhpcy5wMzM9WzAsMF0sdGhpcy5wMzQ9WzAsMF19cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtjb25zdCB1PXMucVswXSxjPUMoTWF0aC5leHAocy5kcml2ZVswXSksLjEsMmUzKTtsZXQgYT1zLmZyZXF1ZW5jeVswXTthPWEqMipkdC9zYW1wbGVSYXRlLGE9YT4xPzE6YTtjb25zdCBoPU1hdGgubWluKDgsdSouMTMpO2xldCBtPTEvYypNYXRoLm1pbigxLjc1LDEraCk7Zm9yKGxldCBwPTA7cDxEO3ArKylmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKyl7Y29uc3QgZj10aGlzLnAzW2xdKi4zNjA4OTErdGhpcy5wMzJbbF0qLjQxNzI5K3RoaXMucDMzW2xdKi4xNzc4OTYrdGhpcy5wMzRbbF0qLjA0Mzk3MjU7dGhpcy5wMzRbbF09dGhpcy5wMzNbbF0sdGhpcy5wMzNbbF09dGhpcy5wMzJbbF0sdGhpcy5wMzJbbF09dGhpcy5wM1tsXSx0aGlzLnAwW2xdKz0oUyhyW2xdW3BdKmMtaCpmKS1TKHRoaXMucDBbbF0pKSphLHRoaXMucDFbbF0rPShTKHRoaXMucDBbbF0pLVModGhpcy5wMVtsXSkpKmEsdGhpcy5wMltsXSs9KFModGhpcy5wMVtsXSktUyh0aGlzLnAyW2xdKSkqYSx0aGlzLnAzW2xdKz0oUyh0aGlzLnAyW2xdKS1TKHRoaXMucDNbbF0pKSphLG9bbF1bcF09ZiptfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGFkZGVyLXByb2Nlc3NvciIseXQpO2NsYXNzIEF0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImRpc3RvcnQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IHU9TWF0aC5leHBtMShzLmRpc3RvcnRbMF0pLGM9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IGE9MDthPEQ7YSsrKWZvcihsZXQgaD0wO2g8ci5sZW5ndGg7aCsrKW9baF1bYV09KDErdSkqcltoXVthXS8oMSt1Kk1hdGguYWJzKHJbaF1bYV0pKSpjO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGlzdG9ydC1wcm9jZXNzb3IiLEF0KTtmdW5jdGlvbiB4dChuLHQsZSl7cmV0dXJuIGUqKHQtbikrbn1mdW5jdGlvbiBWdChuLHQsZSl7cmV0dXJuIG48Mj8wOnh0KC10Ki41LHQqLjUsZS8obi0xKSl9ZnVuY3Rpb24gdHQobix0KXtyZXR1cm4gbipNYXRoLnBvdygyLHQvMTIpfWNsYXNzIEZ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7Y29uc3Qgcj1lWzBdLG89cy52b2ljZXNbMF0saT1zLmZyZXFzcHJlYWRbMF0sdT1zLnBhbnNwcmVhZFswXSouNSsuNSxjPU1hdGguc3FydCgxLXUpLGE9TWF0aC5zcXJ0KHUpO2ZvcihsZXQgaD0wO2g8bztoKyspe2NvbnN0IG09KGgmMSk9PTE7bGV0IHA9YyxsPWE7bSYmKHA9YSxsPWMpO2ZvcihsZXQgZj0wO2Y8clswXS5sZW5ndGg7ZisrKXtsZXQgZD10dChzLmZyZXF1ZW5jeVtmXT8/cy5mcmVxdWVuY3lbMF0scy5kZXR1bmVbMF0vMTAwKTtkPXR0KGQsVnQobyxpLGgpKTtjb25zdCB2PXB0KGQvc2FtcGxlUmF0ZSwxKTt0aGlzLnBoYXNlW2hdPXRoaXMucGhhc2VbaF0/P01hdGgucmFuZG9tKCk7Y29uc3QgZz1ydC5zYXdibGVwKHRoaXMucGhhc2VbaF0sdik7clswXVtmXT1yWzBdW2ZdK2cqcCxyWzFdW2ZdPXJbMV1bZl0rZypsLHRoaXMucGhhc2VbaF09YnQodGhpcy5waGFzZVtoXSt2KX19cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzdXBlcnNhdy1vc2NpbGxhdG9yIixGdCk7Y29uc3QgTXQ9MjA0ODtmdW5jdGlvbiBPdChuKXtsZXQgdD1uZXcgRmxvYXQzMkFycmF5KG4pO2Zvcih2YXIgZT0wO2U8bjtlKyspdFtlXT0uNSooMS1NYXRoLmNvcygyKk1hdGguUEkqZS9uKSk7cmV0dXJuIHR9Y2xhc3MgTnQgZXh0ZW5kcyBndHtzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJwaXRjaEZhY3RvciIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcih0KXt0LnByb2Nlc3Nvck9wdGlvbnM9e2Jsb2NrU2l6ZTpNdH0sc3VwZXIodCksdGhpcy5mZnRTaXplPXRoaXMuYmxvY2tTaXplLHRoaXMudGltZUN1cnNvcj0wLHRoaXMuaGFubldpbmRvdz1PdCh0aGlzLmJsb2NrU2l6ZSksdGhpcy5mZnQ9bmV3IEl0KHRoaXMuZmZ0U2l6ZSksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZD10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLnRpbWVDb21wbGV4QnVmZmVyPXRoaXMuZmZ0LmNyZWF0ZUNvbXBsZXhBcnJheSgpLHRoaXMubWFnbml0dWRlcz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZS8yKzEpLHRoaXMucGVha0luZGV4ZXM9bmV3IEludDMyQXJyYXkodGhpcy5tYWduaXR1ZGVzLmxlbmd0aCksdGhpcy5uYlBlYWtzPTB9cHJvY2Vzc09MQSh0LGUscyl7bGV0IHI9cy5waXRjaEZhY3RvcltzLnBpdGNoRmFjdG9yLmxlbmd0aC0xXTtyPDAmJihyPXIqLjI1KSxyPU1hdGgubWF4KDAscisxKTtmb3IodmFyIG89MDtvPHRoaXMubmJJbnB1dHM7bysrKWZvcih2YXIgaT0wO2k8dFtvXS5sZW5ndGg7aSsrKXt2YXIgdT10W29dW2ldLGM9ZVtvXVtpXTt0aGlzLmFwcGx5SGFubldpbmRvdyh1KSx0aGlzLmZmdC5yZWFsVHJhbnNmb3JtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXIsdSksdGhpcy5jb21wdXRlTWFnbml0dWRlcygpLHRoaXMuZmluZFBlYWtzKCksdGhpcy5zaGlmdFBlYWtzKHIpLHRoaXMuZmZ0LmNvbXBsZXRlU3BlY3RydW0odGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmludmVyc2VUcmFuc2Zvcm0odGhpcy50aW1lQ29tcGxleEJ1ZmZlcix0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZCksdGhpcy5mZnQuZnJvbUNvbXBsZXhBcnJheSh0aGlzLnRpbWVDb21wbGV4QnVmZmVyLGMpLHRoaXMuYXBwbHlIYW5uV2luZG93KGMpfXRoaXMudGltZUN1cnNvcis9dGhpcy5ob3BTaXplfWFwcGx5SGFubldpbmRvdyh0KXtmb3IodmFyIGU9MDtlPHRoaXMuYmxvY2tTaXplO2UrKyl0W2VdPXRbZV0qdGhpcy5oYW5uV2luZG93W2VdKjEuNjJ9Y29tcHV0ZU1hZ25pdHVkZXMoKXtmb3IodmFyIHQ9MCxlPTA7dDx0aGlzLm1hZ25pdHVkZXMubGVuZ3RoOyl7bGV0IHM9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltlXSxyPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZSsxXTt0aGlzLm1hZ25pdHVkZXNbdF09cyoqMityKioyLHQrPTEsZSs9Mn19ZmluZFBlYWtzKCl7dGhpcy5uYlBlYWtzPTA7dmFyIHQ9MjtsZXQgZT10aGlzLm1hZ25pdHVkZXMubGVuZ3RoLTI7Zm9yKDt0PGU7KXtsZXQgcz10aGlzLm1hZ25pdHVkZXNbdF07aWYodGhpcy5tYWduaXR1ZGVzW3QtMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0LTJdPj1zKXt0Kys7Y29udGludWV9aWYodGhpcy5tYWduaXR1ZGVzW3QrMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0KzJdPj1zKXt0Kys7Y29udGludWV9dGhpcy5wZWFrSW5kZXhlc1t0aGlzLm5iUGVha3NdPXQsdGhpcy5uYlBlYWtzKyssdCs9Mn19c2hpZnRQZWFrcyh0KXt0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZC5maWxsKDApO2Zvcih2YXIgZT0wO2U8dGhpcy5uYlBlYWtzO2UrKyl7bGV0IGk9dGhpcy5wZWFrSW5kZXhlc1tlXSx1PU1hdGgucm91bmQoaSp0KTtpZih1PnRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7dmFyIHM9MCxyPXRoaXMuZmZ0U2l6ZTtpZihlPjApe2xldCBoPXRoaXMucGVha0luZGV4ZXNbZS0xXTtzPWktTWF0aC5mbG9vcigoaS1oKS8yKX1pZihlPHRoaXMubmJQZWFrcy0xKXtsZXQgaD10aGlzLnBlYWtJbmRleGVzW2UrMV07cj1pK01hdGguY2VpbCgoaC1pKS8yKX1sZXQgYz1zLWksYT1yLWk7Zm9yKHZhciBvPWM7bzxhO28rKyl7bGV0IGg9aStvLG09dStvO2lmKG0+PXRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7bGV0IHA9MipNYXRoLlBJKihtLWgpL3RoaXMuZmZ0U2l6ZSxsPU1hdGguY29zKHAqdGhpcy50aW1lQ3Vyc29yKSxmPU1hdGguc2luKHAqdGhpcy50aW1lQ3Vyc29yKSxkPWgqMix2PWQrMSxnPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZF0sST10aGlzLmZyZXFDb21wbGV4QnVmZmVyW3ZdLGI9ZypsLUkqZixCPWcqZitJKmwsXz1tKjIsdz1fKzE7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbX10rPWIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbd10rPUJ9fX19cmVnaXN0ZXJQcm9jZXNzb3IoInBoYXNlLXZvY29kZXItcHJvY2Vzc29yIixOdCk7Y2xhc3MgQ3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGk9ZHQsdGhpcy5waGk9LXRoaXMucGksdGhpcy5ZMD0wLHRoaXMuWTE9MCx0aGlzLlBXPXRoaXMucGksdGhpcy5CPTIuMyx0aGlzLmRwaGlmPTAsdGhpcy5lbnZmPTB9c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo0NDAsbWluOk51bWJlci5FUFNJTE9OfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9LHtuYW1lOiJwdWxzZXdpZHRoIixkZWZhdWx0VmFsdWU6MSxtaW46MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXTtsZXQgbz0xLGk7Zm9yKGxldCB1PTA7dTwoclswXS5sZW5ndGg/PzApO3UrKyl7Y29uc3QgYz0oMS1DKHEodSxzLnB1bHNld2lkdGgpLC0uOTksLjk5KSkqdGhpcy5waSxhPXEodSxzLmRldHVuZSksaD10dChxKHUscy5mcmVxdWVuY3kpLGEvMTAwKTtpPWgqKHRoaXMucGkvKHNhbXBsZVJhdGUqLjUpKSx0aGlzLmRwaGlmKz0uMSooaS10aGlzLmRwaGlmKSxvKj0uOTk5OCx0aGlzLmVudmYrPS4xKihvLXRoaXMuZW52ZiksdGhpcy5CPTIuMyooMS0xZS00KmgpLHRoaXMuQjwwJiYodGhpcy5CPTApLHRoaXMucGhpKz10aGlzLmRwaGlmLHRoaXMucGhpPj10aGlzLnBpJiYodGhpcy5waGktPTIqdGhpcy5waSk7bGV0IG09TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTApO3RoaXMuWTA9LjUqKG0rdGhpcy5ZMCk7bGV0IHA9TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTErYyk7dGhpcy5ZMT0uNSoocCt0aGlzLlkxKTtmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKylyW2xdW3VdPS4xNSoobS1wKSp0aGlzLmVudmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJwdWxzZS1vc2NpbGxhdG9yIixDdCk7Y29uc3QgbnQ9e2JpdEM6ZnVuY3Rpb24obix0LGUpe3JldHVybiBuJnQ/ZTowfSxicjpmdW5jdGlvbihuLHQ9OCl7aWYodD4zMil0aHJvdyBuZXcgRXJyb3IoImJyKCkgU2l6ZSBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDMyIik7e2xldCBlPTA7Zm9yKGxldCBzPTA7czx0LTA7cysrKWUrPW50LmJpdEMobiwyKipzLDIqKih0LShzKzEpKSk7cmV0dXJuIGV9fSxzaW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnNpbihuLygxMjgvTWF0aC5QSSkpfSxjb3NmOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLmNvcyhuLygxMjgvTWF0aC5QSSkpfSx0YW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnRhbihuLygxMjgvTWF0aC5QSSkpfSxyZWdHOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQudGVzdChuLnRvU3RyaW5nKDIpKX19O2xldCBXLGV0O2Z1bmN0aW9uIGt0KG4pe2lmKChXfHxldCk9PW51bGwpe1c9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWF0aCksZXQ9Vy5tYXAocz0+TWF0aFtzXSk7Y29uc3QgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhudCksZT10Lm1hcChzPT5udFtzXSk7Vy5wdXNoKCJpbnQiLCJ3aW5kb3ciLC4uLnQpLGV0LnB1c2goTWF0aC5mbG9vcixnbG9iYWxUaGlzLC4uLmUpfXJldHVybiBuZXcgRnVuY3Rpb24oLi4uVywidCIsYHJldHVybiAwLAoke258fDB9O2ApLmJpbmQoZ2xvYmFsVGhpcywuLi5ldCl9Y2xhc3MgenQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucG9ydC5vbm1lc3NhZ2U9dD0+e2xldHtjb2RlVGV4dDplfT10LmRhdGE7Y29uc3R7Ynl0ZUJlYXRTdGFydFRpbWU6c309dC5kYXRhO3MhPW51bGwmJih0aGlzLnQ9MCx0aGlzLmluaXRpYWxPZmZzZXQ9TWF0aC5mbG9vcihzKSksZT1lLnRyaW0oKS5yZXBsYWNlKC9eZXZhbFwodW5lc2NhcGVcKGVzY2FwZSg/OmB8XCgnfFwoInxcKGApKC4qPykoPzpgfCdcKXwiXCl8YFwpKS5yZXBsYWNlXChcL3VcKFwuXC5cKVwvZyxbIidgXVwkMSVbIidgXVwpXClcKSQvLChyLG8pPT51bmVzY2FwZShlc2NhcGUobykucmVwbGFjZSgvdSguLikvZywiJDElIikpKSx0aGlzLmZ1bmM9a3QoZSl9LHRoaXMuaW5pdGlhbE9mZnNldD1udWxsLHRoaXMudD1udWxsLHRoaXMuZnVuYz1udWxsfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO3RoaXMudD09bnVsbCYmKHRoaXMudD1zLmJlZ2luWzBdKnNhbXBsZVJhdGUpO2NvbnN0IHI9ZVswXTtmb3IobGV0IG89MDtvPHJbMF0ubGVuZ3RoO28rKyl7Y29uc3QgaT1xKG8scy5kZXR1bmUpLHU9dHQocShvLHMuZnJlcXVlbmN5KSxpLzEwMCk7bGV0IGM9dGhpcy50LyhzYW1wbGVSYXRlLzI1NikqdSt0aGlzLmluaXRpYWxPZmZzZXQ7Y29uc3QgbT0oKHRoaXMuZnVuYyhjKSYyNTUpLzEyNy41LTEpKi4yO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKXJbcF1bb109QyhtLC0uNCwuNCk7dGhpcy50PXRoaXMudCsxfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiYnl0ZS1iZWF0LXByb2Nlc3NvciIsenQpfSkoKTsK";
let Yt = {};
function Ve(t, e) {
  const n = W();
  if (Yt[t])
    return Yt[t];
  const o = 2 * n.sampleRate, a = n.createBuffer(1, o, n.sampleRate), c = a.getChannelData(0);
  let s = 0, d, l, i, r, h, m, u;
  d = l = i = r = h = m = u = 0;
  for (let p = 0; p < o; p++)
    if (t === "white")
      c[p] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let Z = Math.random() * 2 - 1;
      c[p] = (s + 0.02 * Z) / 1.02, s = c[p];
    } else if (t === "pink") {
      let Z = Math.random() * 2 - 1;
      d = 0.99886 * d + Z * 0.0555179, l = 0.99332 * l + Z * 0.0750759, i = 0.969 * i + Z * 0.153852, r = 0.8665 * r + Z * 0.3104856, h = 0.55 * h + Z * 0.5329522, m = -0.7616 * m - Z * 0.016898, c[p] = d + l + i + r + h + m + u + Z * 0.5362, c[p] *= 0.11, u = Z * 0.115926;
    } else if (t === "crackle") {
      const Z = e * 0.01;
      Math.random() < Z ? c[p] = Math.random() * 2 - 1 : c[p] = 0;
    }
  return t !== "crackle" && (Yt[t] = a), a;
}
function Jt(t = "white", e, n = 0.02) {
  const a = W().createBufferSource();
  return a.buffer = Ve(t, n), a.loop = !0, a.start(e), {
    node: a,
    stop: (c) => a.stop(c)
  };
}
function Zn(t, e, n) {
  const o = Jt("pink", n);
  return {
    node: Xn(t, o.node, e),
    stop: (c) => o?.stop(c)
  };
}
const fe = ["pink", "white", "brown", "crackle"];
function H(t) {
  const e = W().createGain();
  return e.gain.value = t, e;
}
const me = (t, e, n, o) => o - n === 0 ? 0 : (e - t) / (o - n);
function I(t, e, n, o) {
  const a = new AudioWorkletNode(t, e, o);
  return Object.entries(n).forEach(([c, s]) => {
    a.parameters.get(c).value = s;
  }), a;
}
const Q = (t, e, n, o, a, c, s, d, l, i = "exponential") => {
  e = U(e), n = U(n), o = U(o), a = U(a);
  const r = i === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  i === "exponential" && (c = c === 0 ? 1e-3 : c, s = s === 0 ? 1e-3 : s);
  const h = s - c, m = s, u = c + o * h, p = l - d, Z = (X) => {
    let y;
    if (e > X) {
      let b = me(c, m, 0, e);
      y = X * b + (c > m ? c : 0);
    } else
      y = (X - e) * me(m, u, 0, n) + m;
    return i === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(c, d), e > p ? t[r](Z(p), l) : e + n > p ? (t[r](Z(e), d + e), t[r](Z(p), l)) : (t[r](Z(e), d + e), t[r](Z(e + n), d + e + n), t.setValueAtTime(u, l)), t[r](c, l + a);
};
function bn(t, e, n, o, a, c) {
  const s = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: o ?? 10,
    attack: a ?? 5e-3,
    release: c ?? 0.05
  };
  return new DynamicsCompressorNode(t, s);
}
const B = (t, e = "linear", n) => {
  const [s, d, l, i] = t;
  if (s == null && d == null && l == null && i == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const r = l ?? (s != null && d == null || s == null && d == null ? 1 : 1e-3);
  return [Math.max(s ?? 0, 1e-3), Math.max(d ?? 0, 1e-3), Math.min(r, 1), Math.max(i ?? 0, 0.01)];
};
function St(t, e, n, o, a, c, s, d, l, i, r, h, m, u) {
  const p = "exponential", [Z, X, y, b] = B([a, c, s, d], p, [5e-3, 0.14, 0, 0.1]);
  let V, g;
  if (m === "ladder" ? (V = I(t, "ladder-processor", { frequency: n, q: o, drive: u }), g = V.parameters.get("frequency")) : (V = t.createBiquadFilter(), V.type = e, V.Q.value = o, V.frequency.value = n, g = V.frequency), (a ?? c ?? s ?? d ?? l) !== void 0) {
    l = U(l, 1, !0), h = U(h, 0, !0);
    const M = Math.abs(l), w = M * h;
    let Y = $(2 ** -w * n, 0, 2e4), F = $(2 ** (M - w) * n, 0, 2e4);
    return l < 0 && ([Y, F] = [F, Y]), Q(g, Z, X, y, b, Y, F, i, r, p), V;
  }
  return V;
}
let he = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Xn(t, e, n = 0) {
  const o = W();
  if (!n)
    return t;
  let a = o.createGain(), c = o.createGain();
  t.connect(a), e.connect(c), a.gain.value = he(n), c.gain.value = he(1 - n);
  let s = o.createGain();
  return a.connect(s), c.connect(s), s;
}
let yn = ["linear", "exponential"];
function Xt(t, e, n, o) {
  if (!(e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv))
    return;
  const c = U(e.penv, 1, !0), s = yn[e.pcurve ?? 0];
  let [d, l, i, r] = B(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    s,
    [0.2, 1e-3, 1, 1e-3]
  ), h = e.panchor ?? i;
  const m = c * 100, u = 0 - m * h, p = m - m * h;
  Q(t, d, l, i, r, u, p, n, o, s);
}
function yt(t, e, n) {
  const { vibmod: o = 0.5, vib: a } = e;
  let c;
  if (a > 0) {
    c = W().createOscillator(), c.frequency.value = a;
    const s = W().createGain();
    return s.gain.value = o * 100, c.connect(s), s.connect(t), c.start(n), c;
  }
}
function bt(t, e, n, o) {
  const a = new ConstantSourceNode(t), c = H(0);
  return c.connect(t.destination), a.connect(c), a.onended = () => {
    try {
      c.disconnect();
    } catch {
    }
    try {
      a.disconnect();
    } catch {
    }
    e();
  }, a.start(n), a.stop(o), a;
}
const Gn = (t, e = 1, n = "sine") => {
  const o = W();
  let a;
  fe.includes(n) ? (a = o.createBufferSource(), a.buffer = Ve(n, 2), a.loop = !0) : (a = o.createOscillator(), a.type = n, a.frequency.value = t), a.start();
  const c = new GainNode(o, { gain: e });
  return a.connect(c), { node: c, stop: (s) => a.stop(s) };
}, Vn = (t, e, n, o = "sine") => {
  const c = t.value * e, s = c * n;
  return Gn(c, s, o);
};
function Nt(t, e, n) {
  const {
    fmh: o = 1,
    fmi: a,
    fmenv: c = "exp",
    fmattack: s,
    fmdecay: d,
    fmsustain: l,
    fmrelease: i,
    fmvelocity: r,
    fmwave: h = "sine",
    duration: m
  } = e;
  let u, p = () => {
  };
  if (a) {
    const X = W().createGain(), y = Vn(t, o, a, h);
    if (u = y.node, p = y.stop, ![s, d, l, i, r].some((b) => b !== void 0))
      u.connect(t);
    else {
      const [b, V, g, f] = B([s, d, l, i]), M = n + m;
      Q(
        X.gain,
        b,
        V,
        g,
        f,
        0,
        1,
        n,
        M,
        c === "exp" ? "exponential" : "linear"
      ), u.connect(X), X.connect(t);
    }
  }
  return { stop: p };
}
const It = {}, Ft = {}, ao = (t) => It[t];
function fn(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var o = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], a = -1;
  do
    t /= n, ++a;
  while (t >= n);
  return t.toFixed(1) + " " + o[a];
}
function Wn(t, e) {
  const { s: n, n: o = 0, speed: a = 1 } = t;
  let c = mn(t, 36), s = c - 36, d, l = 0;
  if (Array.isArray(e))
    l = re(o, e.length), d = e[l];
  else {
    const h = (u) => Wt(u) - c, m = Object.keys(e).filter((u) => !u.startsWith("_")).reduce(
      (u, p, Z) => !u || Math.abs(h(p)) < Math.abs(h(u)) ? p : u,
      null
    );
    s = -h(m), l = re(o, e[m].length), d = e[m][l];
  }
  const i = `${n}:${l}`;
  let r = Math.abs(a) * Math.pow(2, s / 12);
  return { transpose: s, sampleUrl: d, index: l, midi: c, label: i, playbackRate: r };
}
const xn = async (t, e, n) => {
  let { sampleUrl: o, label: a, playbackRate: c } = Wn(t, e);
  n && (o = await n(o));
  const s = W(), d = await We(o, s, a);
  return t.unit === "c" && (c = c * d.duration), { buffer: d, playbackRate: c };
}, gn = async (t, e, n) => {
  let { buffer: o, playbackRate: a } = await xn(t, e, n);
  t.speed < 0 && (o = Mn(o));
  const s = W().createBufferSource();
  s.buffer = o, s.playbackRate.value = a;
  const { s: d, loopBegin: l = 0, loopEnd: i = 1, begin: r = 0, end: h = 1 } = t, m = r * s.buffer.duration;
  (d.startsWith("wt_") ? 1 : t.loop) && (s.loop = !0, s.loopStart = l * s.buffer.duration - m, s.loopEnd = i * s.buffer.duration - m);
  const p = s.buffer.duration / s.playbackRate.value, Z = (h - r) * p;
  return { bufferSource: s, offset: m, bufferDuration: p, sliceDuration: Z };
}, We = (t, e, n, o = 0) => {
  const a = n ? `sound "${n}:${o}"` : "sample";
  if (t = t.replace("#", "%23"), !Ft[t]) {
    J(`[sampler] load ${a}..`, "load-sample", { url: t });
    const c = Date.now();
    Ft[t] = fetch(t).then((s) => s.arrayBuffer()).then(async (s) => {
      const d = Date.now() - c, l = fn(s.byteLength);
      J(`[sampler] load ${a}... done! loaded ${l} in ${d}ms`, "loaded-sample", { url: t });
      const i = await e.decodeAudioData(s);
      return It[t] = i, i;
    });
  }
  return Ft[t];
};
function Mn(t) {
  const e = W(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let o = 0; o < t.numberOfChannels; o++)
    n.copyToChannel(t.getChannelData(o).slice().reverse(), o, o);
  return n;
}
const lo = (t) => It[t];
function xe(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function ge(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, o] = t.split("github:");
  return o = o.endsWith("/") ? o.slice(0, -1) : o, o.split("/").length === 2 && (o += "/main"), `https://raw.githubusercontent.com/${o}/${e}`;
}
const Rn = (t, e, n = t._base || "") => Object.entries(t).forEach(([o, a]) => {
  if (typeof a == "string" && (a = [a]), typeof a != "object")
    throw new Error("wrong sample map format for " + o);
  n = a._base || n, n = xe(n), n.startsWith("github:") && (n = ge(n, ""));
  const c = (s) => n + s;
  Array.isArray(a) ? a = a.map(c) : a = Object.fromEntries(
    Object.entries(a).map(([s, d]) => [s, (typeof d == "string" ? [d] : d).map(c)])
  ), e(o, a);
});
let Me = {};
function io(t, e) {
  Me[t] = e;
}
function zn(t) {
  const e = Object.entries(Me).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
const Ln = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const c = zn(t);
    if (c)
      return c(t);
    if (t = xe(t), t.startsWith("github:") && (t = ge(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
      let [d, l] = t.split("shabda:");
      t = `https://shabda.ndre.gr/${l}.json?strudel=1`;
    }
    if (t.startsWith("shabda/speech")) {
      let [d, l] = t.split("shabda/speech");
      l = l.startsWith("/") ? l.substring(1) : l;
      let [i, r] = l.split(":"), h = "f", m = "en-GB";
      i && ([m, h] = i.split("/")), t = `https://shabda.ndre.gr/speech/${r}.json?gender=${h}&language=${m}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const s = t.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(t).then((d) => d.json()).then((d) => Ln(d, e || d._base || s, n)).catch((d) => {
      throw console.error(d), new Error(`error loading "${t}"`);
    });
  }
  const { prebake: o, tag: a } = n;
  Rn(
    t,
    (c, s) => q(c, (d, l, i) => Yn(d, l, i, s), {
      type: "sample",
      samples: s,
      baseUrl: e,
      prebake: o,
      tag: a
    }),
    e
  );
}, pe = [];
async function Yn(t, e, n, o, a) {
  let {
    s: c,
    nudge: s = 0,
    // TODO: is this in seconds?
    cut: d,
    loop: l,
    clip: i = void 0,
    // if set, samples will be cut off when the hap ends
    n: r = 0,
    speed: h = 1,
    // sample playback speed
    duration: m
  } = e;
  if (h === 0)
    return;
  const u = W();
  let [p, Z, X, y] = B([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: b, sliceDuration: V, offset: g } = await gn(e, o, a);
  if (u.currentTime > t) {
    J(`[sampler] still loading sound "${c}:${r}"`, "highlight");
    return;
  }
  if (!b) {
    J(`[sampler] could not load "${c}:${r}"`, "error");
    return;
  }
  let f = yt(b.detune, e, t);
  const M = t + s;
  b.start(M, g);
  const w = u.createGain(), Y = b.connect(w);
  i == null && l == null && e.release == null && (m = V);
  let F = t + m;
  Q(Y.gain, p, Z, X, y, 0, 1, t, F, "linear"), Xt(b.detune, e, t, F);
  const S = u.createGain();
  Y.connect(S), b.onended = function() {
    b.disconnect(), f?.stop(), Y.disconnect(), S.disconnect(), n();
  };
  let O = F + y + 0.01;
  b.stop(O);
  const T = { node: S, bufferSource: b, stop: (k) => {
    b.stop(k);
  } };
  if (d !== void 0) {
    const k = pe[d];
    k && (k.node.gain.setValueAtTime(1, M), k.node.gain.linearRampToValueAtTime(0, M + 0.01)), pe[d] = T;
  }
  return T;
}
const Re = 128, Ct = "System Standard";
let ze = Re;
function Sn(t) {
  ze = parseInt(t) ?? Re;
}
let Le = !1;
function Fn(t) {
  Le = t == !0;
}
function Tn(t) {
  return typeof t == "number" ? t % 5 : { tri: 0, triangle: 0, sine: 1, ramp: 2, saw: 3, square: 4 }[t] ?? 0;
}
const j = on();
function q(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), j.setKey(t, { onTrigger: e, data: n });
}
let Ye = (t) => t;
function A(t) {
  return Ye(t);
}
function ro(t) {
  Ye = t;
}
function vt(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = j.get();
  for (const n in e) {
    const [o, a] = n.split("_");
    if (!a) continue;
    const c = t[o];
    if (c) {
      if (typeof c == "string")
        e[`${c}_${a}`.toLowerCase()] = e[n];
      else if (Array.isArray(c))
        for (const s of c)
          e[`${s}_${a}`.toLowerCase()] = e[n];
    }
  }
  j.set({ ...e });
}
async function Hn(t) {
  const n = await (await fetch(t)).json();
  vt(n);
}
async function uo(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? Hn(t[0]) : vt(t[0]);
    case 2:
      return vt({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function Tt(t) {
  return typeof t != "string" ? (console.warn(`getSound: expected string got "${t}". fall back to triangle`), j.get().triangle) : j.get()[t.toLowerCase()];
}
const wn = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(Ct, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
};
let lt = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaysync: 3 / 16,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
const Kn = Object.freeze({ ...lt });
function mo(t, e) {
  lt[t] = e;
}
function ho() {
  lt = { ...Kn };
}
let kt = new Map(Object.entries(lt));
function Se(t, e) {
  kt.set(t, e);
}
function L(t) {
  return kt.get(t);
}
function po(t) {
  Object.keys(t).forEach((e) => {
    Se(e, t[e]);
  });
}
function Jn() {
  kt = new Map(Object.entries(lt));
}
function Zo(t) {
  Jn(), t === "1.0" && Se("fanchor", 0.5);
}
const bo = () => j.set({});
let Gt;
const Nn = () => (Gt = new AudioContext(), Gt), W = () => Gt || Nn();
function Xo() {
  return W().currentTime;
}
let Ht;
function Cn() {
  return Ht || (Ht = W().audioWorklet.addModule(pn)), Ht;
}
async function vn(t = {}) {
  const {
    disableWorklets: e = !1,
    maxPolyphony: n,
    audioDeviceName: o = Ct,
    multiChannelOrbits: a = !1
  } = t;
  if (Sn(n), Fn(a), typeof window > "u")
    return;
  const c = W();
  if (o != null && o != Ct)
    try {
      const d = (await wn()).get(o), l = (d ?? "").length > 0;
      c.sinkId !== d && l && await c.setSinkId(d), J(
        `[superdough] Audio Device set to ${o}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      J("[superdough] failed to set audio interface", "warning");
    }
  if (await c.resume(), e) {
    J("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await Cn(), J("[superdough] AudioWorklets loaded");
  } catch (s) {
    console.warn("could not load AudioWorklet effects", s);
  }
  J("[superdough] ready");
}
let wt;
async function yo(t) {
  return wt || (wt = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await vn(t), e();
    });
  })), wt;
}
let Vt, nt;
function Pn() {
  const t = W(), e = t.destination.maxChannelCount;
  t.destination.channelCount = e, Vt = new ChannelMergerNode(t, { numberOfInputs: t.destination.channelCount }), nt = new GainNode(t), Vt.connect(nt), nt.connect(t.destination);
}
const In = (t, e = [0, 1]) => {
  const n = W();
  Vt == null && Pn();
  const o = new StereoPannerNode(n);
  t.connect(o);
  const a = new ChannelSplitterNode(n, {
    numberOfOutputs: o.channelCount
  });
  o.connect(a), e.forEach((c, s) => {
    a.connect(Vt, s % o.channelCount, c % n.destination.channelCount);
  });
}, Go = () => {
  nt != null && (nt.gain.linearRampToValueAtTime(0, W().currentTime + 0.01), nt = null);
};
function kn(t, e, n, o) {
  if (n = $(n, 0, 0.98), !x[t].delayNode) {
    const c = W().createFeedbackDelay(1, e, n);
    c.start?.(o), ft(c, t), x[t].delayNode = c;
  }
  return x[t].delayNode.delayTime.value !== e && x[t].delayNode.delayTime.setValueAtTime(e, o), x[t].delayNode.feedback.value !== n && x[t].delayNode.feedback.setValueAtTime(n, o), x[t].delayNode;
}
function Qt(t, e, n, o = {}) {
  const { shape: a = 0, ...c } = o, { dcoffset: s = -0.5, depth: d = 1 } = o, l = {
    frequency: 1,
    depth: d,
    skew: 0.5,
    phaseoffset: 0,
    time: e,
    begin: e,
    end: n,
    shape: Tn(a),
    dcoffset: s,
    min: s * d,
    max: s * d + d,
    curve: 1,
    ...c
  };
  return I(t, "lfo-processor", l);
}
function Qn(t, e, n = 1, o = 0.5, a = 1e3, c = 2e3) {
  const s = W(), d = Qt(s, t, e, { frequency: n, depth: c * 2 }), l = 2;
  let i = 0;
  const r = [];
  for (let h = 0; h < l; h++) {
    const m = s.createBiquadFilter();
    m.type = "notch", m.gain.value = 1, m.frequency.value = a + i, m.Q.value = 2 - Math.min(Math.max(o * 2, 0), 1.9), d.connect(m.detune), i += 282, h > 0 && r[h - 1].connect(m), r.push(m);
  }
  return r[r.length - 1];
}
function Bn(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(Ge(t, e.length))] : t;
}
let x = {};
function ft(t, e) {
  x[e] == null && Xe(new Error("target orbit does not exist"), "superdough"), t.connect(x[e].gain);
}
function Un(t, e, n) {
  x[e] == null && (x[e] = {
    gain: new GainNode(t, { gain: 1, channelCount: 2, channelCountMode: "explicit" })
  }, In(x[e].gain, n));
}
function jn(t, e, n, o = 0.1, a = 1) {
  [e].flat().forEach((s) => {
    if (x[s] == null) {
      Xe(new Error(`duck target orbit ${s} does not exist`), "superdough");
      return;
    }
    bt(
      t,
      () => {
        x[s].gain.gain.cancelScheduledValues(n);
        const d = x[s].gain.gain.value;
        x[s].gain.gain.linearRampToValueAtTime($(1 - Math.pow(a, 0.5), 0.01, d), n), x[s].gain.gain.exponentialRampToValueAtTime(1, n + Math.max(2e-3, o));
      },
      0,
      n - 0.01
    );
  });
}
let et = (t, e) => t !== void 0 && t !== e;
function On(t, e, n, o, a, c, s, d) {
  if (!x[t].reverbNode) {
    const i = W().createReverb(e, n, o, a, c, s, d);
    ft(i, t), x[t].reverbNode = i;
  }
  return (et(e, x[t].reverbNode.duration) || et(n, x[t].reverbNode.fade) || et(o, x[t].reverbNode.lp) || et(a, x[t].reverbNode.dim) || et(s, x[t].reverbNode.irspeed) || et(d, x[t].reverbNode.irbegin) || x[t].reverbNode.ir !== c) && x[t].reverbNode.generate(e, n, o, a, c, s, d), x[t].reverbNode;
}
let P = {}, ot = {};
function Dn(t, e = 1024, n = 0.5) {
  if (!P[t]) {
    const o = W().createAnalyser();
    o.fftSize = e, o.smoothingTimeConstant = n, P[t] = o, ot[t] = new Float32Array(P[t].frequencyBinCount);
  }
  return P[t].fftSize !== e && (P[t].fftSize = e, ot[t] = new Float32Array(P[t].frequencyBinCount)), P[t];
}
function Vo(t = "time", e = 1) {
  const n = {
    time: () => P[e]?.getFloatTimeDomainData(ot[e]),
    frequency: () => P[e]?.getFloatFrequencyData(ot[e])
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), ot[e];
}
function Kt(t, e, n) {
  const o = H(n);
  return t.connect(o), o.connect(e), o;
}
function fo() {
  x = {}, P = {}, ot = {};
}
let at = /* @__PURE__ */ new Map();
function Ze(t) {
  return (Array.isArray(t) ? t : [t]).map((e) => e - 1);
}
const En = async (t, e, n, o = 0.5, a = 0.5) => {
  const c = W();
  let { stretch: s } = t;
  if (s != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < c.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${c.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    tremolo: d,
    tremolosync: l,
    tremolodepth: i = 1,
    tremoloskew: r,
    tremolophase: h = 0,
    tremoloshape: m,
    s: u = L("s"),
    bank: p,
    source: Z,
    gain: X = L("gain"),
    postgain: y = L("postgain"),
    density: b = L("density"),
    duckorbit: V,
    duckattack: g,
    duckdepth: f,
    // filters
    fanchor: M = L("fanchor"),
    drive: w = 0.69,
    release: Y = 0,
    // low pass
    cutoff: F,
    lpenv: S,
    lpattack: O,
    lpdecay: z,
    lpsustain: T,
    lprelease: k,
    resonance: xt = L("resonance"),
    // high pass
    hpenv: C,
    hcutoff: _,
    hpattack: D,
    hpdecay: gt,
    hpsustain: Te,
    hprelease: He,
    hresonance: we = L("hresonance"),
    // band pass
    bpenv: Ke,
    bandf: Bt,
    bpattack: Je,
    bpdecay: Ne,
    bpsustain: Ce,
    bprelease: ve,
    bandq: Pe = L("bandq"),
    //phaser
    phaserrate: Ut,
    phaserdepth: jt = L("phaserdepth"),
    phasersweep: Ie,
    phasercenter: ke,
    //
    coarse: Ot,
    crush: Dt,
    dry: it,
    shape: Et,
    shapevol: Mt = L("shapevol"),
    distort: At,
    distortvol: Rt = L("distortvol"),
    pan: qt,
    vowel: $t,
    delay: rt = L("delay"),
    delayfeedback: _t = L("delayfeedback"),
    delaysync: Qe = L("delaysync"),
    delaytime: ut,
    orbit: E = L("orbit"),
    room: te,
    roomfade: Be,
    roomlp: Ue,
    roomdim: je,
    roomsize: Oe,
    ir: zt,
    irspeed: De,
    irbegin: Ee,
    i: ee = L("i"),
    velocity: Lt = L("velocity"),
    analyze: ne,
    // analyser wet
    fft: Ae = L("fft"),
    // fftSize 0 - 10
    compressor: oe,
    compressorRatio: qe,
    compressorKnee: $e,
    compressorAttack: _e,
    compressorRelease: tn
  } = t;
  ut = ut ?? hn(Qe, o);
  const en = Ze(
    Le && E > 0 ? [E * 2 - 1, E * 2] : L("channels")
  ), nn = t.channels != null ? Ze(t.channels) : en;
  Un(c, E, nn), V != null && jn(c, V, e, g, f), X = A(U(X, 1)), y = A(y), Mt = A(Mt), Rt = A(Rt), rt = A(rt), Lt = A(Lt), i = A(i), X *= Lt;
  const mt = e + n, ce = mt + Y, se = Math.round(Math.random() * 1e6);
  for (let G = 0; G <= at.size - ze; G++) {
    const v = at.entries().next(), K = v.value[1], N = v.value[0], ie = e + 0.25;
    K?.node?.gain?.linearRampToValueAtTime(0, ie), K?.stop?.(ie), at.delete(N);
  }
  let tt = [];
  if (["-", "~", "_"].includes(u))
    return;
  p && u && (u = `${p}_${u}`, t.s = u);
  let ht;
  if (Z)
    ht = Z(e, t, n, o);
  else if (Tt(u)) {
    const { onTrigger: G } = Tt(u), K = await G(e, t, () => {
      tt.forEach((N) => N?.disconnect()), at.delete(se);
    });
    K && (ht = K.node, at.set(se, K));
  } else
    throw new Error(`sound ${u} not found! Is it loaded?`);
  if (!ht)
    return;
  if (c.currentTime > e) {
    J("[webaudio] skip hap: still loading", c.currentTime - e);
    return;
  }
  const R = [];
  R.push(ht), s !== void 0 && R.push(I(c, "phase-vocoder-processor", { pitchFactor: s })), R.push(H(X));
  const pt = Bn(t.ftype);
  if (F !== void 0) {
    let G = () => St(
      c,
      "lowpass",
      F,
      xt,
      O,
      z,
      T,
      k,
      S,
      e,
      mt,
      M,
      pt,
      w
    );
    R.push(G()), pt === "24db" && R.push(G());
  }
  if (_ !== void 0) {
    let G = () => St(
      c,
      "highpass",
      _,
      we,
      D,
      gt,
      Te,
      He,
      C,
      e,
      mt,
      M
    );
    R.push(G()), pt === "24db" && R.push(G());
  }
  if (Bt !== void 0) {
    let G = () => St(c, "bandpass", Bt, Pe, Je, Ne, Ce, ve, Ke, e, mt, M);
    R.push(G()), pt === "24db" && R.push(G());
  }
  if ($t !== void 0) {
    const G = c.createVowelFilter($t);
    R.push(G);
  }
  if (Ot !== void 0 && R.push(I(c, "coarse-processor", { coarse: Ot })), Dt !== void 0 && R.push(I(c, "crush-processor", { crush: Dt })), Et !== void 0 && R.push(I(c, "shape-processor", { shape: Et, postgain: Mt })), At !== void 0 && R.push(I(c, "distort-processor", { distort: At, postgain: Rt })), l != null && (d = o * l), d !== void 0) {
    const G = Math.max(1 - i, 0), v = new GainNode(c, { gain: G }), K = a / o;
    Qt(c, e, ce, {
      skew: r ?? (m != null ? 0.5 : 1),
      frequency: d,
      depth: i,
      time: K,
      dcoffset: 0,
      shape: m,
      phaseoffset: h,
      min: 0,
      max: 1,
      curve: 1.5
    }).connect(v.gain), R.push(v);
  }
  if (oe !== void 0 && R.push(
    bn(c, oe, qe, $e, _e, tn)
  ), qt !== void 0) {
    const G = c.createStereoPanner();
    G.pan.value = 2 * qt - 1, R.push(G);
  }
  if (Ut !== void 0 && jt > 0) {
    const G = Qn(e, ce, Ut, jt, ke, Ie);
    R.push(G);
  }
  const st = new GainNode(c, { gain: y });
  R.push(st);
  let ae;
  if (rt > 0 && ut > 0 && _t > 0) {
    const G = kn(E, ut, _t, e);
    ae = Kt(st, G, rt), tt.push(ae);
  }
  let de;
  if (te > 0) {
    let G;
    if (zt !== void 0) {
      let K, N = Tt(zt);
      Array.isArray(N) ? K = N.data.samples[ee % N.data.samples.length] : typeof N == "object" && (K = Object.values(N.data.samples).flat()[ee % Object.values(N.data.samples).length]), G = await We(K, c, zt, 0);
    }
    const v = On(E, Oe, Be, Ue, je, G, De, Ee);
    de = Kt(st, v, te), tt.push(de);
  }
  let le;
  if (ne) {
    const G = Dn(ne, 2 ** (Ae + 5));
    le = Kt(st, G, 1), tt.push(le);
  }
  if (it != null) {
    it = A(it);
    const G = new GainNode(c, { gain: it });
    R.push(G), ft(G, E);
  } else
    ft(st, E);
  R.slice(1).reduce((G, v) => G.connect(v), R[0]), tt = tt.concat(R);
}, Wo = (t, e, n, o) => {
  En(e, t - n, e.duration / o, o);
}, dt = (t, e = 36) => {
  let { note: n, freq: o } = t;
  return n = n || e, typeof n == "string" && (n = Wt(n)), !o && typeof n == "number" && (o = ye(n)), Number(o);
};
function Zt(t) {
  t != null && (t.disconnect(), t.parameters.get("end")?.setValueAtTime(0, 0));
}
const An = ["triangle", "square", "sawtooth", "sine"], qn = [
  ["tri", "triangle"],
  ["sqr", "square"],
  ["saw", "sawtooth"],
  ["sin", "sine"]
];
function $n(t, e) {
  const n = t, o = new Float32Array(e);
  for (let a = 0; a < e; a++) {
    const c = a * 2 / e - 1;
    o[a] = Math.tanh(c * n);
  }
  return o;
}
function xo() {
  [...An].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const [a, c, s, d] = B(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l = to(t, e, n), { node: i, stop: r, triggerRelease: h } = l;
        const m = H(0.3), { duration: u } = n;
        i.onended = () => {
          i.disconnect(), m.disconnect(), o();
        };
        const p = H(1);
        let Z = i.connect(m).connect(p);
        const X = e + u;
        Q(Z.gain, a, c, s, d, 0, 1, e, X, "linear");
        const y = X + d + 0.01;
        return h?.(y), r(y), {
          node: Z,
          stop: (b) => {
            r(b);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), q(
    "sbd",
    (t, e, n) => {
      const { duration: o, decay: a = 0.5, pdecay: c = 0.5, penv: s = 36, clip: d } = e, l = W(), i = 0.02, r = 1.2, h = 0.025, m = 1, u = l.createOscillator();
      u.type = "triangle", u.frequency.value = dt(e, 29), u.detune.setValueAtTime(s * 100, 0), u.detune.setValueAtTime(s * 100, t), u.detune.exponentialRampToValueAtTime(1e-3, t + c);
      const p = H(1);
      p.gain.setValueAtTime(1, t + i), p.gain.exponentialRampToValueAtTime(1e-3, t + i + a), u.start(t);
      const Z = Jt("brown", t, 2), X = H(1);
      X.gain.setValueAtTime(r, t), X.gain.exponentialRampToValueAtTime(1e-3, t + h);
      const y = new WaveShaperNode(l);
      y.curve = $n(2, l.sampleRate);
      const b = H(m);
      u.onended = () => {
        u.disconnect(), p.disconnect(), y.disconnect(), Z.node.disconnect(), X.disconnect(), b.disconnect(), n();
      };
      const V = u.connect(y).connect(p).connect(b);
      Z.node.connect(X).connect(b);
      let f = t + a + 0.01;
      return d != null && (f = Math.min(t + d * o, f)), b.gain.setValueAtTime(m, f - 0.01), b.gain.linearRampToValueAtTime(0, f), u.stop(f), Z.stop(f), {
        node: V,
        stop: (M) => {
          u.stop(M);
        }
      };
    },
    { type: "synth", prebake: !0 }
  ), q(
    "supersaw",
    (t, e, n) => {
      const o = W();
      let { duration: a, n: c, unison: s = 5, spread: d = 0.6, detune: l } = e;
      l = l ?? c ?? 0.18;
      const i = dt(e), [r, h, m, u] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), p = t + a, Z = p + u + 0.01, X = $(s, 1, 100);
      let y = X > 1 ? $(d, 0, 1) : 0, b = I(
        o,
        "supersaw-oscillator",
        {
          frequency: i,
          begin: t,
          end: Z,
          freqspread: l,
          voices: X,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const V = 1 / Math.sqrt(X);
      Xt(b.parameters.get("detune"), e, t, p);
      const g = yt(b.parameters.get("detune"), e, t), f = Nt(b.parameters.get("frequency"), e, t);
      let M = H(1);
      M = b.connect(M), Q(M.gain, r, h, m, u, 0, 0.3 * V, t, p, "linear");
      let w = bt(
        o,
        () => {
          Zt(b), M.disconnect(), n(), f?.stop(), g?.stop();
        },
        t,
        Z
      );
      return {
        node: M,
        stop: (Y) => {
          w.stop(Y);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), q(
    "bytebeat",
    (t, e, n) => {
      const o = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: a = 0 } = e, c = dt(e), { byteBeatExpression: s = o[a % o.length], byteBeatStartTime: d } = e, l = W();
      let { duration: i } = e;
      const [r, h, m, u] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), p = t + i, Z = p + u + 0.01;
      let X = I(
        l,
        "byte-beat-processor",
        {
          frequency: c,
          begin: t,
          end: Z
        },
        {
          outputChannelCount: [2]
        }
      );
      X.port.postMessage({ codeText: s, byteBeatStartTime: d, frequency: c });
      let y = H(1);
      y = X.connect(y), Q(y.gain, r, h, m, u, 0, 1, t, p, "linear");
      let b = bt(
        l,
        () => {
          Zt(X), y.disconnect(), n();
        },
        t,
        Z
      );
      return {
        node: y,
        stop: (V) => {
          b.stop(V);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), q(
    "pulse",
    (t, e, n) => {
      const o = W();
      let { pwrate: a, pwsweep: c } = e;
      c == null && (a != null ? c = 0.3 : c = 0), a == null && c != null && (a = 1);
      let { duration: s, pw: d = 0.5 } = e;
      const l = dt(e), [i, r, h, m] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), u = t + s, p = u + m + 0.01;
      let Z = I(
        o,
        "pulse-oscillator",
        {
          frequency: l,
          begin: t,
          end: p,
          pulsewidth: d
        },
        {
          outputChannelCount: [2]
        }
      );
      Xt(Z.parameters.get("detune"), e, t, u);
      const X = yt(Z.parameters.get("detune"), e, t), y = Nt(Z.parameters.get("frequency"), e, t);
      let b = H(1);
      b = Z.connect(b), Q(b.gain, i, r, h, m, 0, 1, t, u, "linear");
      let V;
      c != 0 && (V = Qt(o, t, p, { frequency: a, depth: c }), V.connect(Z.parameters.get("pulsewidth")));
      let g = bt(
        o,
        () => {
          Zt(Z), Zt(V), b.disconnect(), n(), y?.stop(), X?.stop();
        },
        t,
        p
      );
      return {
        node: b,
        stop: (f) => {
          g.stop(f);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...fe].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const [a, c, s, d] = B(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l, { density: i } = n;
        l = Jt(t, e, i);
        let { node: r, stop: h, triggerRelease: m } = l;
        const u = H(0.3), { duration: p } = n;
        r.onended = () => {
          r.disconnect(), u.disconnect(), o();
        };
        const Z = H(1);
        let X = r.connect(u).connect(Z);
        const y = e + p;
        Q(X.gain, a, c, s, d, 0, 1, e, y, "linear");
        const b = y + d + 0.01;
        return m?.(b), h(b), {
          node: X,
          stop: (V) => {
            h(V);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), qn.forEach(([t, e]) => j.set({ ...j.get(), [t]: j.get()[e] }));
}
function _n(t, e) {
  const n = new Float32Array(t + 1), o = new Float32Array(t + 1), a = W(), c = a.createOscillator(), s = {
    sawtooth: (i) => [0, -1 / i],
    square: (i) => [0, i % 2 === 0 ? 0 : 1 / i],
    triangle: (i) => [i % 2 === 0 ? 0 : 1 / (i * i), 0]
  };
  if (!s[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, o[0] = 0;
  let d = 1;
  for (; d <= t; ) {
    const [i, r] = s[e](d);
    n[d] = i, o[d] = r, d++;
  }
  const l = a.createPeriodicWave(n, o);
  return c.setPeriodicWave(l), c;
}
function to(t, e, n) {
  let { n: o, duration: a, noise: c = 0 } = n, s;
  !o || t === "sine" ? (s = W().createOscillator(), s.type = t || "triangle") : s = _n(o, t), s.frequency.value = dt(n), s.start(e);
  let d = yt(s.detune, n, e);
  Xt(s.detune, n, e, e + a);
  const l = Nt(s.frequency, n, e);
  let i;
  return c && (i = Zn(s, c, e)), {
    node: i?.node || s,
    stop: (r) => {
      l.stop(r), d?.stop(r), i?.stop(r), s.stop(r);
    },
    triggerRelease: (r) => {
    }
  };
}
function eo(t = 1, e = 0.05, n = 220, o = 0, a = 0, c = 0.1, s = 0, d = 1, l = 0, i = 0, r = 0, h = 0, m = 0, u = 0, p = 0, Z = 0, X = 0, y = 1, b = 0, V = 0) {
  let g = Math.PI * 2, f = W().sampleRate, M = (gt) => gt > 0 ? 1 : -1, w = l *= 500 * g / f / f, Y = n *= (1 + e * 2 * Math.random() - e) * g / f, F = [], S = 0, O = 0, z = 0, T = 1, k = 0, xt = 0, C = 0, _, D;
  for (o = o * f + 9, b *= f, a *= f, c *= f, X *= f, i *= 500 * g / f ** 3, p *= g / f, r *= g / f, h *= f, m = m * f | 0, D = o + b + a + c + X | 0; z < D; F[z++] = C)
    ++xt % (Z * 100 | 0) || (C = s ? s > 1 ? s > 2 ? s > 3 ? Math.sin((S % g) ** 3) : Math.max(Math.min(Math.tan(S), 1), -1) : 1 - (2 * S / g % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(S / g) - S / g) : Math.sin(S), C = (m ? 1 - V + V * Math.sin(g * z / m) : 1) * M(C) * Math.abs(C) ** d * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (z < o ? z / o : z < o + b ? 1 - (z - o) / b * (1 - y) : z < o + b + a ? y : z < D - X ? (D - z - X) / c * // release falloff
    y : 0), C = X ? C / 2 + (X > z ? 0 : (z < D - X ? 1 : (D - z) / X) * // release delay
    F[z - X | 0] / 2) : C), _ = (n += l += i) * // frequency
    Math.cos(p * O++), S += _ - _ * u * (1 - (Math.sin(z) + 1) * 1e9 % 2), T && ++T > h && (n += r, Y += r, T = 0), m && !(++k % m) && (n = Y, l = w, T ||= 1);
  return F;
}
const no = (t, e) => {
  let {
    s: n,
    note: o = 36,
    freq: a,
    //
    zrand: c = 0,
    attack: s = 0,
    decay: d = 0,
    sustain: l = 0.8,
    release: i = 0.1,
    curve: r = 1,
    slide: h = 0,
    deltaSlide: m = 0,
    pitchJump: u = 0,
    pitchJumpTime: p = 0,
    lfo: Z = 0,
    znoise: X = 0,
    zmod: y = 0,
    zcrush: b = 0,
    zdelay: V = 0,
    tremolo: g = 0,
    duration: f = 0.2,
    zzfx: M
  } = t;
  const w = Math.max(f - s - d, 0);
  typeof o == "string" && (o = Wt(o)), !a && typeof o == "number" && (a = ye(o)), n = n.replace("z_", "");
  const Y = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  r = n === "square" ? 0 : r;
  const S = (
    /* ZZFX. */
    eo(...M || [
      0.25,
      // volume
      c,
      a,
      s,
      w,
      i,
      Y,
      r,
      h,
      m,
      u,
      p,
      Z,
      X,
      y,
      b,
      V,
      l,
      // sustain volume!
      d,
      g
    ])
  ), O = W(), z = O.createBuffer(1, S.length, O.sampleRate);
  z.getChannelData(0).set(S);
  const T = W().createBufferSource();
  return T.buffer = z, T.start(e), {
    node: T
  };
};
function go() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const { node: a } = no({ s: t, ...n }, e);
        return a.onended = () => {
          a.disconnect(), o();
        }, {
          node: a,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let ct;
async function oo(t, e) {
  const n = `dsp-worklet-${Date.now()}`, o = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, c = `data:text/javascript;base64,${btoa(o)}`;
  await t.audioWorklet.addModule(c);
  const s = new AudioWorkletNode(t, n);
  return { node: s, stop: () => s.port.postMessage("stop") };
}
const Fe = () => {
  ct && (ct?.stop(), ct?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  t.data === "strudel-stop" ? Fe() : t.data?.dough && ct?.node.port.postMessage(t.data);
});
const Mo = async (t) => {
  const e = W();
  Fe(), ct = await oo(e, t), ct.node.connect(e.destination);
};
function Ro(t, e, n, o) {
  window.postMessage({ time: o, dough: t.value, currentTime: e, duration: t.duration, cps: n });
}
export {
  Re as DEFAULT_MAX_POLYPHONY,
  uo as aliasBank,
  P as analysers,
  ot as analysersData,
  Nt as applyFM,
  A as applyGainCurve,
  In as connectToDestination,
  St as createFilter,
  Mo as dough,
  Ro as doughTrigger,
  Xn as drywet,
  oo as dspWorklet,
  Xe as errorLogger,
  H as gainNode,
  B as getADSRValues,
  Dn as getAnalyserById,
  Vo as getAnalyzerData,
  W as getAudioContext,
  Xo as getAudioContextCurrentTime,
  wn as getAudioDevices,
  ao as getCachedBuffer,
  bn as getCompressor,
  L as getDefaultValue,
  Qt as getLfo,
  lo as getLoadedBuffer,
  to as getOscillator,
  Q as getParamADSR,
  Xt as getPitchEnvelope,
  xn as getSampleBuffer,
  gn as getSampleBufferSource,
  Wn as getSampleInfo,
  Tt as getSound,
  yt as getVibratoOscillator,
  I as getWorklet,
  no as getZZFX,
  vn as initAudio,
  yo as initAudioOnFirstClick,
  Pn as initializeAudioOutput,
  We as loadBuffer,
  J as logger,
  fe as noises,
  Yn as onTriggerSample,
  Go as panic,
  Rn as processSampleMap,
  io as registerSamplesPrefix,
  q as registerSound,
  xo as registerSynthSounds,
  go as registerZZFXSounds,
  Jn as resetDefaultValues,
  ho as resetDefaults,
  fo as resetGlobalEffects,
  bo as resetLoadedSounds,
  Mn as reverseBuffer,
  Ln as samples,
  mo as setDefault,
  Nn as setDefaultAudioContext,
  Se as setDefaultValue,
  po as setDefaultValues,
  ro as setGainCurve,
  so as setLogger,
  Sn as setMaxPolyphony,
  Fn as setMultiChannelOrbits,
  Zo as setVersionDefaults,
  j as soundMap,
  En as superdough,
  Wo as superdoughTrigger,
  _n as waveformN,
  bt as webAudioTimeout
};
