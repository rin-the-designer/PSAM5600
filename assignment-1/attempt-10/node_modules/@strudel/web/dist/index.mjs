typeof BigInt > "u" && (BigInt = function(e) {
  if (isNaN(e)) throw new Error("");
  return e;
});
const se = BigInt(0), de = BigInt(1), ti = BigInt(2), su = BigInt(5), yt = BigInt(10), ky = 2e3, K = {
  s: de,
  n: se,
  d: de
};
function mn(e, t) {
  try {
    e = BigInt(e);
  } catch {
    throw kn();
  }
  return e * t;
}
function Zt(e) {
  return typeof e == "bigint" ? e : Math.floor(e);
}
function Xe(e, t) {
  if (t === se)
    throw xu();
  const n = Object.create(Re.prototype);
  n.s = e < se ? -de : de, e = e < se ? -e : e;
  const r = On(e, t);
  return n.n = e / r, n.d = t / r, n;
}
function lr(e) {
  const t = {};
  let n = e, r = ti, i = su - de;
  for (; i <= n; ) {
    for (; n % r === se; )
      n /= r, t[r] = (t[r] || se) + de;
    i += de + ti * r++;
  }
  return n !== e ? n > 1 && (t[n] = (t[n] || se) + de) : t[e] = (t[e] || se) + de, t;
}
const nt = function(e, t) {
  let n = se, r = de, i = de;
  if (e != null) if (t !== void 0) {
    if (typeof e == "bigint")
      n = e;
    else {
      if (isNaN(e))
        throw kn();
      if (e % 1 !== 0)
        throw ao();
      n = BigInt(e);
    }
    if (typeof t == "bigint")
      r = t;
    else {
      if (isNaN(t))
        throw kn();
      if (t % 1 !== 0)
        throw ao();
      r = BigInt(t);
    }
    i = n * r;
  } else if (typeof e == "object") {
    if ("d" in e && "n" in e)
      n = BigInt(e.n), r = BigInt(e.d), "s" in e && (n *= BigInt(e.s));
    else if (0 in e)
      n = BigInt(e[0]), 1 in e && (r = BigInt(e[1]));
    else if (typeof e == "bigint")
      n = e;
    else
      throw kn();
    i = n * r;
  } else if (typeof e == "number") {
    if (isNaN(e))
      throw kn();
    if (e < 0 && (i = -de, e = -e), e % 1 === 0)
      n = BigInt(e);
    else if (e > 0) {
      let s = 1, u = 0, a = 1, o = 1, f = 1, h = 1e7;
      for (e >= 1 && (s = 10 ** Math.floor(1 + Math.log10(e)), e /= s); a <= h && f <= h; ) {
        let m = (u + o) / (a + f);
        if (e === m) {
          a + f <= h ? (n = u + o, r = a + f) : f > a ? (n = o, r = f) : (n = u, r = a);
          break;
        } else
          e > m ? (u += o, a += f) : (o += u, f += a), a > h ? (n = o, r = f) : (n = u, r = a);
      }
      n = BigInt(n) * BigInt(s), r = BigInt(r);
    }
  } else if (typeof e == "string") {
    let s = 0, u = se, a = se, o = se, f = de, h = de, m = e.replace(/_/g, "").match(/\d+|./g);
    if (m === null)
      throw kn();
    if (m[s] === "-" ? (i = -de, s++) : m[s] === "+" && s++, m.length === s + 1 ? a = mn(m[s++], i) : m[s + 1] === "." || m[s] === "." ? (m[s] !== "." && (u = mn(m[s++], i)), s++, (s + 1 === m.length || m[s + 1] === "(" && m[s + 3] === ")" || m[s + 1] === "'" && m[s + 3] === "'") && (a = mn(m[s], i), f = yt ** BigInt(m[s].length), s++), (m[s] === "(" && m[s + 2] === ")" || m[s] === "'" && m[s + 2] === "'") && (o = mn(m[s + 1], i), h = yt ** BigInt(m[s + 1].length) - de, s += 3)) : m[s + 1] === "/" || m[s + 1] === ":" ? (a = mn(m[s], i), f = mn(m[s + 2], de), s += 3) : m[s + 3] === "/" && m[s + 1] === " " && (u = mn(m[s], i), a = mn(m[s + 2], i), f = mn(m[s + 4], de), s += 5), m.length <= s)
      r = f * h, i = /* void */
      n = o + r * u + h * a;
    else
      throw kn();
  } else if (typeof e == "bigint")
    n = e, i = e, r = de;
  else
    throw kn();
  if (r === se)
    throw xu();
  K.s = i < se ? -de : de, K.n = n < se ? -n : n, K.d = r < se ? -r : r;
};
function Vy(e, t, n) {
  let r = de;
  for (; t > se; e = e * e % n, t >>= de)
    t & de && (r = r * e % n);
  return r;
}
function Iy(e, t) {
  for (; t % ti === se; t /= ti)
    ;
  for (; t % su === se; t /= su)
    ;
  if (t === de)
    return se;
  let n = yt % t, r = 1;
  for (; n !== de; r++)
    if (n = n * yt % t, r > ky)
      return se;
  return BigInt(r);
}
function Ty(e, t, n) {
  let r = de, i = Vy(yt, n, t);
  for (let s = 0; s < 300; s++) {
    if (r === i)
      return BigInt(s);
    r = r * yt % t, i = i * yt % t;
  }
  return 0;
}
function On(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  for (; ; ) {
    if (e %= t, !e)
      return t;
    if (t %= e, !t)
      return e;
  }
}
function Re(e, t) {
  if (nt(e, t), this instanceof Re)
    e = On(K.d, K.n), this.s = K.s, this.n = K.n / e, this.d = K.d / e;
  else
    return Xe(K.s * K.n, K.d);
}
var xu = function() {
  return new Error("Division by Zero");
}, kn = function() {
  return new Error("Invalid argument");
}, ao = function() {
  return new Error("Parameters must be integer");
};
Re.prototype = {
  s: de,
  n: se,
  d: de,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return Xe(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return Xe(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(e, t) {
    return nt(e, t), Xe(
      this.s * this.n * K.d + K.s * this.d * K.n,
      this.d * K.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(e, t) {
    return nt(e, t), Xe(
      this.s * this.n * K.d - K.s * this.d * K.n,
      this.d * K.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(e, t) {
    return nt(e, t), Xe(
      this.s * K.s * this.n * K.n,
      this.d * K.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(e, t) {
    return nt(e, t), Xe(
      this.s * K.s * this.n * K.d,
      this.d * K.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return Xe(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
   **/
  mod: function(e, t) {
    if (e === void 0)
      return Xe(this.s * this.n % this.d, de);
    if (nt(e, t), se === K.n * this.d)
      throw xu();
    return Xe(
      this.s * (K.d * this.n) % (K.n * this.d),
      K.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(e, t) {
    return nt(e, t), Xe(On(K.n, this.n) * On(K.d, this.d), K.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(e, t) {
    return nt(e, t), K.n === se && this.n === se ? Xe(se, de) : Xe(K.n * this.n, On(K.n, this.n) * On(K.d, this.d));
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return Xe(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some integer exponent
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(e, t) {
    if (nt(e, t), K.d === de)
      return K.s < se ? Xe((this.s * this.d) ** K.n, this.n ** K.n) : Xe((this.s * this.n) ** K.n, this.d ** K.n);
    if (this.s < se) return null;
    let n = lr(this.n), r = lr(this.d), i = de, s = de;
    for (let u in n)
      if (u !== "1") {
        if (u === "0") {
          i = se;
          break;
        }
        if (n[u] *= K.n, n[u] % K.d === se)
          n[u] /= K.d;
        else return null;
        i *= BigInt(u) ** n[u];
      }
    for (let u in r)
      if (u !== "1") {
        if (r[u] *= K.n, r[u] % K.d === se)
          r[u] /= K.d;
        else return null;
        s *= BigInt(u) ** r[u];
      }
    return K.s < se ? Xe(s, i) : Xe(i, s);
  },
  /**
   * Calculates the logarithm of a fraction to a given rational base
   *
   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
   */
  log: function(e, t) {
    if (nt(e, t), this.s <= se || K.s <= se) return null;
    const n = {}, r = lr(K.n), i = lr(K.d), s = lr(this.n), u = lr(this.d);
    for (const f in i)
      r[f] = (r[f] || se) - i[f];
    for (const f in u)
      s[f] = (s[f] || se) - u[f];
    for (const f in r)
      f !== "1" && (n[f] = !0);
    for (const f in s)
      f !== "1" && (n[f] = !0);
    let a = null, o = null;
    for (const f in n) {
      const h = r[f] || se, m = s[f] || se;
      if (h === se) {
        if (m !== se)
          return null;
        continue;
      }
      let p = m, A = h;
      const M = On(p, A);
      if (p /= M, A /= M, a === null && o === null)
        a = p, o = A;
      else if (p * o !== a * A)
        return null;
    }
    return a !== null && o !== null ? Xe(a, o) : null;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(e, t) {
    return nt(e, t), this.s * this.n * K.d === K.s * K.n * this.d;
  },
  /**
   * Check if this rational number is less than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lt: function(e, t) {
    return nt(e, t), this.s * this.n * K.d < K.s * K.n * this.d;
  },
  /**
   * Check if this rational number is less than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lte: function(e, t) {
    return nt(e, t), this.s * this.n * K.d <= K.s * K.n * this.d;
  },
  /**
   * Check if this rational number is greater than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gt: function(e, t) {
    return nt(e, t), this.s * this.n * K.d > K.s * K.n * this.d;
  },
  /**
   * Check if this rational number is greater than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gte: function(e, t) {
    return nt(e, t), this.s * this.n * K.d >= K.s * K.n * this.d;
  },
  /**
   * Compare two rational numbers
   * < 0 iff this < that
   * > 0 iff this > that
   * = 0 iff this = that
   *
   * Ex: new Fraction(19.6).compare([98, 5]);
   **/
  compare: function(e, t) {
    nt(e, t);
    let n = this.s * this.n * K.d - K.s * K.n * this.d;
    return (se < n) - (n < se);
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(e) {
    return e = yt ** BigInt(e || 0), Xe(
      Zt(this.s * e * this.n / this.d) + (e * this.n % this.d > se && this.s >= se ? de : se),
      e
    );
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(e) {
    return e = yt ** BigInt(e || 0), Xe(
      Zt(this.s * e * this.n / this.d) - (e * this.n % this.d > se && this.s < se ? de : se),
      e
    );
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(e) {
    return e = yt ** BigInt(e || 0), Xe(
      Zt(this.s * e * this.n / this.d) + this.s * ((this.s >= se ? de : se) + ti * (e * this.n % this.d) > this.d ? de : se),
      e
    );
  },
  /**
    * Rounds a rational number to a multiple of another rational number
    *
    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
    **/
  roundTo: function(e, t) {
    nt(e, t);
    const n = this.n * K.d, r = this.d * K.n, i = n % r;
    let s = Zt(n / r);
    return i + i >= r && s++, Xe(this.s * s * K.n, K.d);
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(e, t) {
    return nt(e, t), !(!(K.n * this.d) || this.n * K.d % (K.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return Number(this.s * this.n) / Number(this.d);
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(e) {
    let t = this.n, n = this.d;
    e = e || 15;
    let r = Iy(t, n), i = Ty(t, n, r), s = this.s < se ? "-" : "";
    if (s += Zt(t / n), t %= n, t *= yt, t && (s += "."), r) {
      for (let u = i; u--; )
        s += Zt(t / n), t %= n, t *= yt;
      s += "(";
      for (let u = r; u--; )
        s += Zt(t / n), t %= n, t *= yt;
      s += ")";
    } else
      for (let u = e; t && u--; )
        s += Zt(t / n), t %= n, t *= yt;
    return s;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
   **/
  toFraction: function(e) {
    let t = this.n, n = this.d, r = this.s < se ? "-" : "";
    if (n === de)
      r += t;
    else {
      let i = Zt(t / n);
      e && i > se && (r += i, r += " ", t %= n), r += t, r += "/", r += n;
    }
    return r;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(e) {
    let t = this.n, n = this.d, r = this.s < se ? "-" : "";
    if (n === de)
      r += t;
    else {
      let i = Zt(t / n);
      e && i > se && (r += i, t %= n), r += "\\frac{", r += t, r += "}{", r += n, r += "}";
    }
    return r;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    let e = this.n, t = this.d, n = [];
    do {
      n.push(Zt(e / t));
      let r = e % t;
      e = t, t = r;
    } while (e !== de);
    return n;
  },
  simplify: function(e) {
    const t = BigInt(1 / (e || 1e-3) | 0), n = this.abs(), r = n.toContinued();
    for (let i = 1; i < r.length; i++) {
      let s = Xe(r[i - 1], de);
      for (let a = i - 2; a >= 0; a--)
        s = s.inverse().add(r[a]);
      let u = s.sub(n);
      if (u.n * t < u.d)
        return s.mul(this.s);
    }
    return this;
  }
};
const wu = "strudel.log";
let Ny = 1e3, oo, co;
function Su(e, t = "cyclist") {
  Ue(`[${t}] error: ${e.message}`);
}
function Ue(e, t, n = {}) {
  let r = performance.now();
  oo === e && r - co < Ny || (oo = e, co = r, console.log(`%c${e}`, "background-color: black;color:white;border-radius:15px"), typeof document < "u" && typeof CustomEvent < "u" && document.dispatchEvent(
    new CustomEvent(wu, {
      detail: {
        message: e,
        type: t,
        data: n
      }
    })
  ));
}
Ue.key = wu;
const Ly = (e) => /^[a-gA-G][#bs]*[0-9]$/.test(e), Un = (e) => /^[a-gA-G][#bsf]*[0-9]?$/.test(e), vc = (e) => {
  if (typeof e != "string")
    return [];
  const [t, n = "", r] = e.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return t ? [t, n, r ? Number(r) : void 0] : [];
}, Ry = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, Gy = { "#": 1, b: -1, s: 1, f: -1 }, Ln = (e, t = 3) => {
  const [n, r, i = t] = vc(e);
  if (!n)
    throw new Error('not a note: "' + e + '"');
  const s = Ry[n.toLowerCase()], u = r?.split("").reduce((a, o) => a + Gy[o], 0) || 0;
  return (Number(i) + 1) * 12 + s + u;
}, Hn = (e) => Math.pow(2, (e - 69) / 12) * 440, Bu = (e) => 12 * Math.log(e / 440) / Math.LN2 + 69, Zy = (e, t) => {
  if (typeof e != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: r } = e;
  if (typeof n == "number")
    return Bu(n);
  if (typeof r == "string")
    return Ln(r);
  if (typeof r == "number")
    return r;
  if (!t)
    throw new Error("valueToMidi: expected freq or note to be set");
  return t;
}, Xy = (e, t) => (e - t) * 1e3, Pc = (e) => Hn(typeof e == "number" ? e : Ln(e)), Wy = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], Oy = (e) => {
  const t = Math.floor(e / 12) - 1;
  return Wy[e % 12] + t;
}, kt = (e, t) => (e % t + t) % t, Dc = (e) => e.reduce((t, n) => t + n) / e.length;
function Fc(e, t = 0) {
  return isNaN(Number(e)) ? (Ue(`"${e}" is not a number, falling back to ${t}`, "warning"), t) : e;
}
const zy = (e, t) => kt(Math.round(Fc(e ?? 0, 0)), t), jy = (e) => {
  let { value: t, context: n } = e, r = t;
  if (typeof r == "object" && !Array.isArray(r) && (r = r.note || r.n || r.value, r === void 0))
    throw new Error(`cannot find a playable note for ${JSON.stringify(t)}`);
  if (typeof r == "number" && n.type !== "frequency")
    r = Hn(e.value);
  else if (typeof r == "number" && n.type === "frequency")
    r = e.value;
  else if (typeof r != "string" || !Un(r))
    throw new Error("not a note: " + JSON.stringify(r));
  return r;
}, Ec = (e) => {
  let { value: t, context: n } = e;
  if (typeof t == "object")
    return t.freq ? t.freq : Pc(t.note || t.n || t.value);
  if (typeof t == "number" && n.type !== "frequency")
    t = Hn(e.value);
  else if (typeof t == "string" && Un(t))
    t = Hn(Ln(e.value));
  else if (typeof t != "number")
    throw new Error("not a note or frequency: " + t);
  return t;
}, xc = (e, t) => e.slice(t).concat(e.slice(0, t)), wc = (...e) => e.reduce(
  (t, n) => (...r) => t(n(...r)),
  (t) => t
), $y = (...e) => wc(...e.reverse()), Cr = (e) => e.filter((t) => t != null), bn = (e) => [].concat(...e), hr = (e) => e, qy = (e, t) => e, _u = (e, t) => Array.from({ length: t - e + 1 }, (n, r) => r + e);
function Ae(e, t, n = e.length) {
  const r = function i(...s) {
    if (s.length >= n)
      return e.apply(this, s);
    {
      const u = function(...a) {
        return i.apply(this, s.concat(a));
      };
      return t && t(u, s), u;
    }
  };
  return t && t(r, []), r;
}
function ku(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  if (Un(e))
    return Ln(e);
  throw new Error(`cannot parse as numeral: "${e}"`);
}
function Vu(e, t) {
  return (...n) => e(...n.map(t));
}
function vt(e) {
  return Vu(e, ku);
}
function Sc(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  const n = {
    pi: Math.PI,
    w: 1,
    h: 0.5,
    q: 0.25,
    e: 0.125,
    s: 0.0625,
    t: 1 / 3,
    f: 0.2,
    x: 1 / 6
  }[e];
  if (typeof n < "u")
    return n;
  throw new Error(`cannot parse as fractional: "${e}"`);
}
const Hy = (e) => Vu(e, Sc), Iu = function(e, t) {
  return [t.slice(0, e), t.slice(e)];
}, qi = (e, t, n) => t.map((r, i) => e(r, n[i])), Bc = function(e) {
  const t = [];
  for (let n = 0; n < e.length - 1; ++n)
    t.push([e[n], e[n + 1]]);
  return t;
}, Hi = (e, t, n) => Math.min(Math.max(e, t), n), Ky = ["Do", "Reb", "Re", "Mib", "Mi", "Fa", "Solb", "Sol", "Lab", "La", "Sib", "Si"], Yy = [
  "Sa",
  "Re",
  "Ga",
  "Ma",
  "Pa",
  "Dha",
  "Ni"
], Jy = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Hb", "H"], Uy = [
  "Ni",
  "Pab",
  "Pa",
  "Voub",
  "Vou",
  "Ga",
  "Dib",
  "Di",
  "Keb",
  "Ke",
  "Zob",
  "Zo"
], Qy = [
  "I",
  "Ro",
  "Ha",
  "Ni",
  "Ho",
  "He",
  "To"
], e3 = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], t3 = (e, t = "letters") => {
  const r = (t === "solfeggio" ? Ky : t === "indian" ? Yy : t === "german" ? Jy : t === "byzantine" ? Uy : t === "japanese" ? Qy : e3)[e % 12], i = Math.floor(e / 12) - 1;
  return r + i;
};
function n3(e) {
  var t = {};
  return e.filter(function(n) {
    return t.hasOwn(n) ? !1 : t[n] = !0;
  });
}
function r3(e) {
  return e.sort().filter(function(t, n, r) {
    return !n || t != r[n - 1];
  });
}
function _c(e) {
  return e.sort((t, n) => t.compare(n)).filter(function(t, n, r) {
    return !n || t.ne(r[n - 1]);
  });
}
function kc(e) {
  const t = new TextEncoder().encode(e);
  return btoa(String.fromCharCode(...t));
}
function Vc(e) {
  const t = new Uint8Array(
    atob(e).split("").map((r) => r.charCodeAt(0))
  );
  return new TextDecoder().decode(t);
}
function i3(e) {
  return encodeURIComponent(kc(e));
}
function s3(e) {
  return Vc(decodeURIComponent(e));
}
function Ic(e, t) {
  return Array.isArray(e) ? e.map(t) : Object.fromEntries(Object.entries(e).map(([n, r], i) => [n, t(r, n, i)]));
}
function uu(e, t) {
  return e / t;
}
class Tc {
  constructor({
    getTargetClockTime: t = a3,
    weight: n = 16,
    offsetDelta: r = 5e-3,
    checkAfterTime: i = 2,
    resetAfterTime: s = 8
  }) {
    this.offsetTime, this.timeAtPrevOffsetSample, this.prevOffsetTimes = [], this.getTargetClockTime = t, this.weight = n, this.offsetDelta = r, this.checkAfterTime = i, this.resetAfterTime = s, this.reset = () => {
      this.prevOffsetTimes = [], this.offsetTime = null, this.timeAtPrevOffsetSample = null;
    };
  }
  calculateOffset(t) {
    const n = this.getTargetClockTime(), r = n - this.timeAtPrevOffsetSample, i = n - t;
    if (r > this.resetAfterTime && this.reset(), this.offsetTime == null && (this.offsetTime = i), this.prevOffsetTimes.push(i), this.prevOffsetTimes.length > this.weight && this.prevOffsetTimes.shift(), this.timeAtPrevOffsetSample == null || r > this.checkAfterTime) {
      this.timeAtPrevOffsetSample = n;
      const s = Dc(this.prevOffsetTimes);
      Math.abs(s - this.offsetTime) > this.offsetDelta && (this.offsetTime = s);
    }
    return this.offsetTime;
  }
  calculateTimestamp(t, n) {
    return this.calculateOffset(t) + n;
  }
}
function u3() {
  return performance.now() * 1e-3;
}
function a3() {
  return Date.now() * 1e-3;
}
const Nc = /* @__PURE__ */ new Map([
  ["control", "Control"],
  ["ctrl", "Control"],
  ["alt", "Alt"],
  ["shift", "Shift"],
  ["down", "ArrowDown"],
  ["up", "ArrowUp"],
  ["left", "ArrowLeft"],
  ["right", "ArrowRight"]
]);
let Rr;
function Lc() {
  if (Rr == null) {
    if (typeof window > "u")
      return;
    Rr = {}, window.addEventListener("keydown", (e) => {
      Rr[e.key] = !0;
    }), window.addEventListener("keyup", (e) => {
      Rr[e.key] = !1;
    });
  }
  return { ...Rr };
}
function Tu(e, t = !1) {
  return typeof e == "object" ? t ? JSON.stringify(e).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(e) : e;
}
Re.prototype.sam = function() {
  return this.floor();
};
Re.prototype.nextSam = function() {
  return this.sam().add(1);
};
Re.prototype.wholeCycle = function() {
  return new He(this.sam(), this.nextSam());
};
Re.prototype.cyclePos = function() {
  return this.sub(this.sam());
};
Re.prototype.lt = function(e) {
  return this.compare(e) < 0;
};
Re.prototype.gt = function(e) {
  return this.compare(e) > 0;
};
Re.prototype.lte = function(e) {
  return this.compare(e) <= 0;
};
Re.prototype.gte = function(e) {
  return this.compare(e) >= 0;
};
Re.prototype.eq = function(e) {
  return this.compare(e) == 0;
};
Re.prototype.ne = function(e) {
  return this.compare(e) != 0;
};
Re.prototype.max = function(e) {
  return this.gt(e) ? this : e;
};
Re.prototype.maximum = function(...e) {
  return e = e.map((t) => new Re(t)), e.reduce((t, n) => n.max(t), this);
};
Re.prototype.min = function(e) {
  return this.lt(e) ? this : e;
};
Re.prototype.mulmaybe = function(e) {
  return e !== void 0 ? this.mul(e) : void 0;
};
Re.prototype.divmaybe = function(e) {
  return e !== void 0 ? this.div(e) : void 0;
};
Re.prototype.addmaybe = function(e) {
  return e !== void 0 ? this.add(e) : void 0;
};
Re.prototype.submaybe = function(e) {
  return e !== void 0 ? this.sub(e) : void 0;
};
Re.prototype.show = function() {
  return this.s * this.n + "/" + this.d;
};
Re.prototype.or = function(e) {
  return this.eq(0) ? e : this;
};
const j = (e) => Re(e), o3 = (...e) => {
  if (e = Cr(e), e.length !== 0)
    return e.reduce((t, n) => t.gcd(n), j(1));
}, zt = (...e) => {
  if (e = Cr(e), e.length === 0)
    return;
  const t = e.pop();
  return e.reduce(
    (n, r) => n === void 0 || r === void 0 ? void 0 : n.lcm(r),
    t
  );
};
j._original = Re;
class He {
  constructor(t, n) {
    this.begin = j(t), this.end = j(n);
  }
  get spanCycles() {
    const t = [];
    var n = this.begin;
    const r = this.end, i = r.sam();
    if (n.equals(r))
      return [new He(n, r)];
    for (; r.gt(n); ) {
      if (n.sam().equals(i)) {
        t.push(new He(n, this.end));
        break;
      }
      const s = n.nextSam();
      t.push(new He(n, s)), n = s;
    }
    return t;
  }
  get duration() {
    return this.end.sub(this.begin);
  }
  cycleArc() {
    const t = this.begin.cyclePos(), n = t.add(this.duration);
    return new He(t, n);
  }
  withTime(t) {
    return new He(t(this.begin), t(this.end));
  }
  withEnd(t) {
    return new He(this.begin, t(this.end));
  }
  withCycle(t) {
    const n = this.begin.sam(), r = n.add(t(this.begin.sub(n))), i = n.add(t(this.end.sub(n)));
    return new He(r, i);
  }
  intersection(t) {
    const n = this.begin.max(t.begin), r = this.end.min(t.end);
    if (!n.gt(r) && !(n.equals(r) && (n.equals(this.end) && this.begin.lt(this.end) || n.equals(t.end) && t.begin.lt(t.end))))
      return new He(n, r);
  }
  intersection_e(t) {
    const n = this.intersection(t);
    if (n == null)
      throw "TimeSpans do not intersect";
    return n;
  }
  midpoint() {
    return this.begin.add(this.duration.div(j(2)));
  }
  equals(t) {
    return this.begin.equals(t.begin) && this.end.equals(t.end);
  }
  show() {
    return this.begin.show() + " → " + this.end.show();
  }
}
class je {
  /*
        Event class, representing a value active during the timespan
        'part'. This might be a fragment of an event, in which case the
        timespan will be smaller than the 'whole' timespan, otherwise the
        two timespans will be the same. The 'part' must never extend outside of the
        'whole'. If the event represents a continuously changing value
        then the whole will be returned as None, in which case the given
        value will have been sampled from the point halfway between the
        start and end of the 'part' timespan.
        The context is to store a list of source code locations causing the event.
  
        The word 'Event' is more or less a reserved word in javascript, hence this
        class is named called 'Hap'.
        */
  constructor(t, n, r, i = {}, s = !1) {
    this.whole = t, this.part = n, this.value = r, this.context = i, this.stateful = s, s && console.assert(typeof this.value == "function", "Stateful values must be functions");
  }
  get duration() {
    let t;
    return typeof this.value?.duration == "number" ? t = j(this.value.duration) : t = this.whole.end.sub(this.whole.begin), typeof this.value?.clip == "number" ? t.mul(this.value.clip) : t;
  }
  get endClipped() {
    return this.whole.begin.add(this.duration);
  }
  isActive(t) {
    return this.whole.begin <= t && this.endClipped >= t;
  }
  isInPast(t) {
    return t > this.endClipped;
  }
  isInNearPast(t, n) {
    return n - t <= this.endClipped;
  }
  isInFuture(t) {
    return t < this.whole.begin;
  }
  isInNearFuture(t, n) {
    return n < this.whole.begin && n > this.whole.begin - t;
  }
  isWithinTime(t, n) {
    return this.whole.begin <= n && this.endClipped >= t;
  }
  wholeOrPart() {
    return this.whole ? this.whole : this.part;
  }
  withSpan(t) {
    const n = this.whole ? t(this.whole) : void 0;
    return new je(n, t(this.part), this.value, this.context);
  }
  withValue(t) {
    return new je(this.whole, this.part, t(this.value), this.context);
  }
  hasOnset() {
    return this.whole != null && this.whole.begin.equals(this.part.begin);
  }
  hasTag(t) {
    return this.context.tags?.includes(t);
  }
  resolveState(t) {
    if (this.stateful && this.hasOnset()) {
      console.log("stateful");
      const n = this.value, [r, i] = n(t);
      return [r, new je(this.whole, this.part, i, this.context, !1)];
    }
    return [t, this];
  }
  spanEquals(t) {
    return this.whole == null && t.whole == null || this.whole.equals(t.whole);
  }
  equals(t) {
    return this.spanEquals(t) && this.part.equals(t.part) && // TODO would == be better ??
    this.value === t.value;
  }
  show(t = !1) {
    const n = typeof this.value == "object" ? t ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value;
    var r = "";
    if (this.whole == null)
      r = "~" + this.part.show;
    else {
      var i = this.whole.begin.equals(this.part.begin) && this.whole.end.equals(this.part.end);
      this.whole.begin.equals(this.part.begin) || (r = this.whole.begin.show() + " ⇜ "), i || (r += "("), r += this.part.show(), i || (r += ")"), this.whole.end.equals(this.part.end) || (r += " ⇝ " + this.whole.end.show());
    }
    return "[ " + r + " | " + n + " ]";
  }
  showWhole(t = !1) {
    return `${this.whole == null ? "~" : this.whole.show()}: ${Tu(this.value, t)}`;
  }
  combineContext(t) {
    const n = this;
    return { ...n.context, ...t.context, locations: (n.context.locations || []).concat(t.context.locations || []) };
  }
  setContext(t) {
    return new je(this.whole, this.part, this.value, t);
  }
  ensureObjectValue() {
    if (typeof this.value != "object")
      throw new Error(
        `expected hap.value to be an object, but got "${this.value}". Hint: append .note() or .s() to the end`,
        "error"
      );
  }
}
class gr {
  constructor(t, n = {}) {
    this.span = t, this.controls = n;
  }
  // Returns new State with different span
  setSpan(t) {
    return new gr(t, this.controls);
  }
  withSpan(t) {
    return this.setSpan(t(this.span));
  }
  // Returns new State with different controls
  setControls(t) {
    return new gr(this.span, t);
  }
}
function c3(e, t, n) {
  if (t?.value !== void 0 && Object.keys(t).length === 1)
    return Ue("[warn]: Can't do arithmetic on control pattern."), e;
  const r = Object.keys(e).filter((i) => Object.keys(t).includes(i));
  return Object.assign({}, e, t, Object.fromEntries(r.map((i) => [i, n(e[i], t[i])])));
}
Ae((e, t) => e * t);
Ae((e, t) => t.map(e));
function Rc(e, t = 60) {
  let n = 0, r = j(0), i = [""], s = "";
  for (; i[0].length < t; ) {
    const u = e.queryArc(n, n + 1), a = u.filter((h) => h.hasOnset()).map((h) => h.duration), o = o3(...a), f = o.inverse();
    i = i.map((h) => h + "|"), s += "|";
    for (let h = 0; h < f; h++) {
      const [m, p] = [r, r.add(o)], A = u.filter((C) => C.whole.begin.lte(m) && C.whole.end.gte(p)), M = A.length - i.length;
      M > 0 && (i = i.concat(Array(M).fill(s))), i = i.map((C, F) => {
        const _ = A[F];
        if (_) {
          const L = _.whole.begin.eq(m) ? "" + _.value : "-";
          return C + L;
        }
        return C + ".";
      }), s += ".", r = r.add(o);
    }
    n++;
  }
  return i.join(`
`);
}
let au, $t = !0;
const l3 = function(e) {
  $t = !!e;
}, Gc = (e) => au = e;
let $ = class it {
  /**
   * Create a pattern. As an end user, you will most likely not create a Pattern directly.
   *
   * @param {function} query - The function that maps a `State` to an array of `Hap`.
   * @noAutocomplete
   */
  constructor(t, n = void 0) {
    this.query = t, this._Pattern = !0, this._steps = n;
  }
  get _steps() {
    return this.__steps;
  }
  set _steps(t) {
    this.__steps = t === void 0 ? void 0 : j(t);
  }
  setSteps(t) {
    return this._steps = t, this;
  }
  withSteps(t) {
    return $t ? new it(this.query, this._steps === void 0 ? void 0 : t(this._steps)) : this;
  }
  get hasSteps() {
    return this._steps !== void 0;
  }
  //////////////////////////////////////////////////////////////////////
  // Haskell-style functor, applicative and monadic operations
  /**
   * Returns a new pattern, with the function applied to the value of
   * each hap. It has the alias `fmap`.
   * @synonyms fmap
   * @param {Function} func to to apply to the value
   * @returns Pattern
   * @example
   * "0 1 2".withValue(v => v + 10).log()
   */
  withValue(t) {
    const n = new it((r) => this.query(r).map((i) => i.withValue(t)));
    return n._steps = this._steps, n;
  }
  // runs func on query state
  withState(t) {
    return this.withHaps((n, r) => (t(r), n));
  }
  /**
   * see `withValue`
   * @noAutocomplete
   */
  fmap(t) {
    return this.withValue(t);
  }
  /**
   * Assumes 'this' is a pattern of functions, and given a function to
   * resolve wholes, applies a given pattern of values to that
   * pattern of functions.
   * @param {Function} whole_func
   * @param {Function} func
   * @noAutocomplete
   * @returns Pattern
   */
  appWhole(t, n) {
    const r = this, i = function(s) {
      const u = r.query(s), a = n.query(s), o = function(f, h) {
        const m = f.part.intersection(h.part);
        if (m != null)
          return new je(
            t(f.whole, h.whole),
            m,
            f.value(h.value),
            h.combineContext(f)
          );
      };
      return bn(
        u.map((f) => Cr(a.map((h) => o(f, h))))
      );
    };
    return new it(i);
  }
  /**
   * When this method is called on a pattern of functions, it matches its haps
   * with those in the given pattern of values.  A new pattern is returned, with
   * each matching value applied to the corresponding function.
   *
   * In this `_appBoth` variant, where timespans of the function and value haps
   * are not the same but do intersect, the resulting hap has a timespan of the
   * intersection. This applies to both the part and the whole timespan.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appBoth(t) {
    const n = this, r = function(s, u) {
      if (!(s == null || u == null))
        return s.intersection_e(u);
    }, i = n.appWhole(r, t);
    return $t && (i._steps = zt(t._steps, n._steps)), i;
  }
  /**
   * As with `appBoth`, but the `whole` timespan is not the intersection,
   * but the timespan from the function of patterns that this method is called
   * on. In practice, this means that the pattern structure, including onsets,
   * are preserved from the pattern of functions (often referred to as the left
   * hand or inner pattern).
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appLeft(t) {
    const n = this, r = function(s) {
      const u = [];
      for (const a of n.query(s)) {
        const o = t.query(s.setSpan(a.wholeOrPart()));
        for (const f of o) {
          const h = a.whole, m = a.part.intersection(f.part);
          if (m) {
            const p = a.value(f.value), A = f.combineContext(a), M = new je(h, m, p, A);
            u.push(M);
          }
        }
      }
      return u;
    }, i = new it(r);
    return i._steps = this._steps, i;
  }
  /**
   * As with `appLeft`, but `whole` timespans are instead taken from the
   * pattern of values, i.e. structure is preserved from the right hand/outer
   * pattern.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appRight(t) {
    const n = this, r = function(s) {
      const u = [];
      for (const a of t.query(s)) {
        const o = n.query(s.setSpan(a.wholeOrPart()));
        for (const f of o) {
          const h = a.whole, m = f.part.intersection(a.part);
          if (m) {
            const p = f.value(a.value), A = a.combineContext(f), M = new je(h, m, p, A);
            u.push(M);
          }
        }
      }
      return u;
    }, i = new it(r);
    return i._steps = t._steps, i;
  }
  bindWhole(t, n) {
    const r = this, i = function(s) {
      const u = function(o, f) {
        return new je(
          t(o.whole, f.whole),
          f.part,
          f.value,
          Object.assign({}, o.context, f.context, {
            locations: (o.context.locations || []).concat(f.context.locations || [])
          })
        );
      }, a = function(o) {
        return n(o.value).query(s.setSpan(o.part)).map((f) => u(o, f));
      };
      return bn(r.query(s).map((o) => a(o)));
    };
    return new it(i);
  }
  bind(t) {
    const n = function(r, i) {
      if (!(r == null || i == null))
        return r.intersection_e(i);
    };
    return this.bindWhole(n, t);
  }
  join() {
    return this.bind(hr);
  }
  outerBind(t) {
    return this.bindWhole((n) => n, t).setSteps(this._steps);
  }
  outerJoin() {
    return this.outerBind(hr);
  }
  innerBind(t) {
    return this.bindWhole((n, r) => r, t);
  }
  innerJoin() {
    return this.innerBind(hr);
  }
  // Flatterns patterns of patterns, by retriggering/resetting inner patterns at onsets of outer pattern haps
  resetJoin(t = !1) {
    const n = this;
    return new it((r) => n.discreteOnly().query(r).map((i) => i.value.late(t ? i.whole.begin : i.whole.begin.cyclePos()).query(r).map(
      (s) => new je(
        // Supports continuous haps in the inner pattern
        s.whole ? s.whole.intersection(i.whole) : void 0,
        s.part.intersection(i.part),
        s.value
      ).setContext(i.combineContext(s))
    ).filter((s) => s.part)).flat());
  }
  restartJoin() {
    return this.resetJoin(!0);
  }
  // Like the other joins above, joins a pattern of patterns of values, into a flatter
  // pattern of values. In this case it takes whole cycles of the inner pattern to fit each event
  // in the outer pattern.
  squeezeJoin() {
    const t = this;
    function n(r) {
      const i = t.discreteOnly().query(r);
      function s(a) {
        const f = a.value._focusSpan(a.wholeOrPart()).query(r.setSpan(a.part));
        function h(m, p) {
          let A;
          if (p.whole && m.whole && (A = p.whole.intersection(m.whole), !A))
            return;
          const M = p.part.intersection(m.part);
          if (!M)
            return;
          const C = p.combineContext(m);
          return new je(A, M, p.value, C);
        }
        return f.map((m) => h(a, m));
      }
      return bn(i.map(s)).filter((a) => a);
    }
    return new it(n);
  }
  squeezeBind(t) {
    return this.fmap(t).squeezeJoin();
  }
  polyJoin = function() {
    const t = this;
    return t.fmap((n) => n.extend(t._steps.div(n._steps))).outerJoin();
  };
  polyBind(t) {
    return this.fmap(t).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // Utility methods mainly for internal use
  /**
   * Query haps inside the given time span.
   *
   * @param {Fraction | number} begin from time
   * @param {Fraction | number} end to time
   * @returns Hap[]
   * @example
   * const pattern = sequence('a', ['b', 'c'])
   * const haps = pattern.queryArc(0, 1)
   * console.log(haps)
   * silence
   * @noAutocomplete
   */
  queryArc(t, n, r = {}) {
    try {
      return this.query(new gr(new He(t, n), r));
    } catch (i) {
      return Ue(`[query]: ${i.message}`, "error"), [];
    }
  }
  /**
   * Returns a new pattern, with queries split at cycle boundaries. This makes
   * some calculations easier to express, as all haps are then constrained to
   * happen within a cycle.
   * @returns Pattern
   * @noAutocomplete
   */
  splitQueries() {
    const t = this, n = (r) => bn(r.span.spanCycles.map((i) => t.query(r.setSpan(i))));
    return new it(n);
  }
  /**
   * Returns a new pattern, where the given function is applied to the query
   * timespan before passing it to the original pattern.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQuerySpan(t) {
    return new it((n) => this.query(n.withSpan(t)));
  }
  withQuerySpanMaybe(t) {
    const n = this;
    return new it((r) => {
      const i = r.withSpan(t);
      return i.span ? n.query(i) : [];
    });
  }
  /**
   * As with `withQuerySpan`, but the function is applied to both the
   * begin and end time of the query timespan.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQueryTime(t) {
    return new it((n) => this.query(n.withSpan((r) => r.withTime(t))));
  }
  /**
   * Similar to `withQuerySpan`, but the function is applied to the timespans
   * of all haps returned by pattern queries (both `part` timespans, and where
   * present, `whole` timespans).
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHapSpan(t) {
    return new it((n) => this.query(n).map((r) => r.withSpan(t)));
  }
  /**
   * As with `withHapSpan`, but the function is applied to both the
   * begin and end time of the hap timespans.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withHapTime(t) {
    return this.withHapSpan((n) => n.withTime(t));
  }
  /**
   * Returns a new pattern with the given function applied to the list of haps returned by every query.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHaps(t) {
    const n = new it((r) => t(this.query(r), r));
    return n._steps = this._steps, n;
  }
  /**
   * As with `withHaps`, but applies the function to every hap, rather than every list of haps.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHap(t) {
    return this.withHaps((n) => n.map(t));
  }
  /**
   * Returns a new pattern with the context field set to every hap set to the given value.
   * @param {*} context
   * @returns Pattern
   * @noAutocomplete
   */
  setContext(t) {
    return this.withHap((n) => n.setContext(t));
  }
  /**
   * Returns a new pattern with the given function applied to the context field of every hap.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withContext(t) {
    const n = this.withHap((r) => r.setContext(t(r.context)));
    return this.__pure !== void 0 && (n.__pure = this.__pure, n.__pure_loc = this.__pure_loc), n;
  }
  /**
   * Returns a new pattern with the context field of every hap set to an empty object.
   * @returns Pattern
   * @noAutocomplete
   */
  stripContext() {
    return this.withHap((t) => t.setContext({}));
  }
  /**
   * Returns a new pattern with the given location information added to the
   * context of every hap.
   * @param {Number} start start offset
   * @param {Number} end end offset
   * @returns Pattern
   * @noAutocomplete
   */
  withLoc(t, n) {
    const r = {
      start: t,
      end: n
    }, i = this.withContext((s) => {
      const u = (s.locations || []).concat([r]);
      return { ...s, locations: u };
    });
    return this.__pure && (i.__pure = this.__pure, i.__pure_loc = r), i;
  }
  /**
   * Returns a new Pattern, which only returns haps that meet the given test.
   * @param {Function} hap_test - a function which returns false for haps to be removed from the pattern
   * @returns Pattern
   * @noAutocomplete
   */
  filterHaps(t) {
    return new it((n) => this.query(n).filter(t));
  }
  /**
   * As with `filterHaps`, but the function is applied to values
   * inside haps.
   * @param {Function} value_test
   * @returns Pattern
   * @noAutocomplete
   */
  filterValues(t) {
    return new it((n) => this.query(n).filter((r) => t(r.value))).setSteps(this._steps);
  }
  /**
   * Returns a new pattern, with haps containing undefined values removed from
   * query results.
   * @returns Pattern
   * @noAutocomplete
   */
  removeUndefineds() {
    return this.filterValues((t) => t != null);
  }
  /**
   * Returns a new pattern, with all haps without onsets filtered out. A hap
   * with an onset is one with a `whole` timespan that begins at the same time
   * as its `part` timespan.
   * @returns Pattern
   * @noAutocomplete
   */
  onsetsOnly() {
    return this.filterHaps((t) => t.hasOnset());
  }
  /**
   * Returns a new pattern, with 'continuous' haps (those without 'whole'
   * timespans) removed from query results.
   * @returns Pattern
   * @noAutocomplete
   */
  discreteOnly() {
    return this.filterHaps((t) => t.whole);
  }
  /**
   * Combines adjacent haps with the same value and whole.  Only
   * intended for use in tests.
   * @noAutocomplete
   */
  defragmentHaps() {
    return this.discreteOnly().withHaps((n) => {
      const r = [];
      for (var i = 0; i < n.length; ++i) {
        for (var s = !0, u = n[i]; s; ) {
          const f = JSON.stringify(n[i].value);
          for (var a = !1, o = i + 1; o < n.length; o++) {
            const h = n[o];
            if (u.whole.equals(h.whole)) {
              if (u.part.begin.eq(h.part.end)) {
                if (f === JSON.stringify(h.value)) {
                  u = new je(u.whole, new He(h.part.begin, u.part.end), u.value), n.splice(o, 1), a = !0;
                  break;
                }
              } else if (h.part.begin.eq(u.part.end) && f == JSON.stringify(h.value)) {
                u = new je(u.whole, new He(u.part.begin, h.part.end), u.value), n.splice(o, 1), a = !0;
                break;
              }
            }
          }
          s = a;
        }
        r.push(u);
      }
      return r;
    });
  }
  /**
   * Queries the pattern for the first cycle, returning Haps. Mainly of use when
   * debugging a pattern.
   * @param {Boolean} with_context - set to true, otherwise the context field
   * will be stripped from the resulting haps.
   * @returns [Hap]
   * @noAutocomplete
   */
  firstCycle(t = !1) {
    var n = this;
    return t || (n = n.stripContext()), n.query(new gr(new He(j(0), j(1))));
  }
  /**
   * Accessor for a list of values returned by querying the first cycle.
   * @noAutocomplete
   */
  get firstCycleValues() {
    return this.firstCycle().map((t) => t.value);
  }
  /**
   * More human-readable version of the `firstCycleValues` accessor.
   * @noAutocomplete
   */
  get showFirstCycle() {
    return this.firstCycle().map(
      (t) => `${t.value}: ${t.whole.begin.toFraction()} - ${t.whole.end.toFraction()}`
    );
  }
  /**
   * Returns a new pattern, which returns haps sorted in temporal order. Mainly
   * of use when comparing two patterns for equality, in tests.
   * @returns Pattern
   * @noAutocomplete
   */
  sortHapsByPart() {
    return this.withHaps(
      (t) => t.sort(
        (n, r) => n.part.begin.sub(r.part.begin).or(n.part.end.sub(r.part.end)).or(n.whole.begin.sub(r.whole.begin).or(n.whole.end.sub(r.whole.end)))
      )
    );
  }
  asNumber() {
    return this.fmap(ku);
  }
  //////////////////////////////////////////////////////////////////////
  // Operators - see 'make composers' later..
  _opIn(t, n) {
    return this.fmap(n).appLeft(q(t));
  }
  _opOut(t, n) {
    return this.fmap(n).appRight(q(t));
  }
  _opMix(t, n) {
    return this.fmap(n).appBoth(q(t));
  }
  _opSqueeze(t, n) {
    const r = q(t);
    return this.fmap((i) => r.fmap((s) => n(i)(s))).squeezeJoin();
  }
  _opSqueezeOut(t, n) {
    const r = this;
    return q(t).fmap((s) => r.fmap((u) => n(u)(s))).squeezeJoin();
  }
  _opReset(t, n) {
    return q(t).fmap((i) => this.fmap((s) => n(s)(i))).resetJoin();
  }
  _opRestart(t, n) {
    return q(t).fmap((i) => this.fmap((s) => n(s)(i))).restartJoin();
  }
  _opPoly(t, n) {
    const r = q(t);
    return this.fmap((i) => r.fmap((s) => n(s)(i))).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // End-user methods.
  // Those beginning with an underscore (_) are 'patternified',
  // i.e. versions are created without the underscore, that are
  // magically transformed to accept patterns for all their arguments.
  //////////////////////////////////////////////////////////////////////
  // Methods without corresponding toplevel functions
  /**
   * Layers the result of the given function(s). Like `superimpose`, but without the original pattern:
   * @name layer
   * @memberof Pattern
   * @synonyms apply
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .layer(x=>x.add("0,2"))
   *   .scale('C minor').note()
   */
  layer(...t) {
    return Le(...t.map((n) => n(this)));
  }
  /**
   * Superimposes the result of the given function(s) on top of the original pattern:
   * @name superimpose
   * @memberof Pattern
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .superimpose(x=>x.add(2))
   *   .scale('C minor').note()
   */
  superimpose(...t) {
    return this.stack(...t.map((n) => n(this)));
  }
  //////////////////////////////////////////////////////////////////////
  // Multi-pattern functions
  stack(...t) {
    return Le(this, ...t);
  }
  sequence(...t) {
    return qt(this, ...t);
  }
  seq(...t) {
    return qt(this, ...t);
  }
  cat(...t) {
    return zc(this, ...t);
  }
  fastcat(...t) {
    return ot(this, ...t);
  }
  slowcat(...t) {
    return Rn(this, ...t);
  }
  //////////////////////////////////////////////////////////////////////
  // Context methods - ones that deal with metadata
  onTrigger(t, n = !0) {
    return this.withHap(
      (r) => r.setContext({
        ...r.context,
        onTrigger: (...i) => {
          r.context.onTrigger?.(...i), t(...i);
        },
        // if dominantTrigger is set to true, the default output (webaudio) will be disabled
        // when using multiple triggers, you cannot flip this flag to false again!
        // example: x.csound('CooLSynth').log() as well as x.log().csound('CooLSynth') should work the same
        dominantTrigger: r.context.dominantTrigger || n
      })
    );
  }
  /**
   * Writes the content of the current event to the console (visible in the side menu).
   * @name log
   * @memberof Pattern
   * @example
   * s("bd sd").log()
   */
  log(t = (r) => `[hap] ${r.showWhole(!0)}`, n = (r) => ({ hap: r })) {
    return this.onTrigger((...r) => {
      Ue(t(...r), void 0, n(...r));
    }, !1);
  }
  /**
   * A simplified version of `log` which writes all "values" (various configurable parameters)
   * within the event to the console (visible in the side menu).
   * @name logValues
   * @memberof Pattern
   * @example
   * s("bd sd").gain("0.25 0.5 1").n("2 1 0").logValues()
   */
  logValues(t = (n) => `[hap] ${Tu(n, !0)}`) {
    return this.log((n) => t(n.value));
  }
  //////////////////////////////////////////////////////////////////////
  // Visualisation
  drawLine() {
    return console.log(Rc(this)), this;
  }
  //////////////////////////////////////////////////////////////////////
  // methods relating to breaking patterns into subcycles
  // Breaks a pattern into a pattern of patterns, according to the structure of the given binary pattern.
  unjoin(t, n = hr) {
    return t.withHap(
      (r) => r.withValue((i) => i ? n(this.ribbon(r.whole.begin, r.whole.duration)) : this)
    );
  }
  /**
   * Breaks a pattern into pieces according to the structure of a given pattern.
   * True values in the given pattern cause the corresponding subcycle of the
   * source pattern to be looped, and for an (optional) given function to be
   * applied. False values result in the corresponding part of the source pattern
   * to be played unchanged.
   * @name into
   * @memberof Pattern
   * @example
   * sound("bd sd ht lt").into("1 0", hurry(2))
   */
  into(t, n) {
    return this.unjoin(t, n).innerJoin();
  }
};
function f3(e, t) {
  let n = [];
  return t.forEach((r) => {
    const i = n.findIndex(([s]) => e(r, s));
    i === -1 ? n.push([r]) : n[i].push(r);
  }), n;
}
const h3 = (e, t) => e.spanEquals(t);
$.prototype.collect = function() {
  return this.withHaps(
    (e) => f3(h3, e).map((t) => new je(t[0].whole, t[0].part, t, {}))
  );
};
const p3 = N("arpWith", (e, t) => t.collect().fmap((n) => q(e(n))).innerJoin().withHap((n) => new je(n.whole, n.part, n.value.value, n.combineContext(n.value)))), d3 = N(
  "arp",
  (e, t) => t.arpWith((n) => q(e).fmap((r) => n[r % n.length])),
  !1
);
function Pi(e) {
  return !Array.isArray(e) && typeof e == "object";
}
function m3(e, t, n) {
  return Pi(e) || Pi(t) ? (Pi(e) || (e = { value: e }), Pi(t) || (t = { value: t }), c3(e, t, n)) : n(e, t);
}
(function() {
  const e = {
    set: [(n, r) => r],
    keep: [(n) => n],
    keepif: [(n, r) => r ? n : void 0],
    // numerical functions
    /**
     *
     * Assumes a pattern of numbers. Adds the given number to each item in the pattern.
     * @name add
     * @memberof Pattern
     * @example
     * // Here, the triad 0, 2, 4 is shifted by different amounts
     * n("0 2 4".add("<0 3 4 0>")).scale("C:major")
     * // Without add, the equivalent would be:
     * // n("<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>").scale("C:major")
     * @example
     * // You can also use add with notes:
     * note("c3 e3 g3".add("<0 5 7 0>"))
     * // Behind the scenes, the notes are converted to midi numbers:
     * // note("48 52 55".add("<0 5 7 0>"))
     */
    add: [vt((n, r) => n + r)],
    // support string concatenation
    /**
     *
     * Like add, but the given numbers are subtracted.
     * @name sub
     * @memberof Pattern
     * @example
     * n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
     * // See add for more information.
     */
    sub: [vt((n, r) => n - r)],
    /**
     *
     * Multiplies each number by the given factor.
     * @name mul
     * @memberof Pattern
     * @example
     * "<1 1.5 [1.66, <2 2.33>]>*4".mul(150).freq()
     */
    mul: [vt((n, r) => n * r)],
    /**
     *
     * Divides each number by the given factor.
     * @name div
     * @memberof Pattern
     */
    div: [vt((n, r) => n / r)],
    mod: [vt(kt)],
    pow: [vt(Math.pow)],
    log2: [vt(Math.log2)],
    band: [vt((n, r) => n & r)],
    bor: [vt((n, r) => n | r)],
    bxor: [vt((n, r) => n ^ r)],
    blshift: [vt((n, r) => n << r)],
    brshift: [vt((n, r) => n >> r)],
    // TODO - force numerical comparison if both look like numbers?
    lt: [(n, r) => n < r],
    gt: [(n, r) => n > r],
    lte: [(n, r) => n <= r],
    gte: [(n, r) => n >= r],
    eq: [(n, r) => n == r],
    eqt: [(n, r) => n === r],
    ne: [(n, r) => n != r],
    net: [(n, r) => n !== r],
    and: [(n, r) => n && r],
    or: [(n, r) => n || r],
    //  bitwise ops
    func: [(n, r) => r(n)]
  }, t = ["In", "Out", "Mix", "Squeeze", "SqueezeOut", "Reset", "Restart", "Poly"];
  for (const [n, [r, i]] of Object.entries(e)) {
    $.prototype["_" + n] = function(s) {
      return this.fmap((u) => r(u, s));
    }, Object.defineProperty($.prototype, n, {
      // a getter that returns a function, so 'pat' can be
      // accessed by closures that are methods of that function..
      get: function() {
        const s = this, u = (...a) => s[n].in(...a);
        for (const a of t)
          u[a.toLowerCase()] = function(...o) {
            var f = s;
            o = qt(o), i && (f = i(f), o = i(o));
            var h;
            return n === "keepif" ? (h = f["_op" + a](o, (m) => (p) => r(m, p)), h = h.removeUndefineds()) : h = f["_op" + a](o, (m) => (p) => m3(m, p, r)), h;
          };
        return u.squeezein = u.squeeze, u;
      }
    });
    for (const s of t)
      $.prototype[s.toLowerCase()] = function(...u) {
        return this.set[s.toLowerCase()](u);
      };
  }
  $.prototype.struct = function(...n) {
    return this.keepif.out(...n);
  }, $.prototype.structAll = function(...n) {
    return this.keep.out(...n);
  }, $.prototype.mask = function(...n) {
    return this.keepif.in(...n);
  }, $.prototype.maskAll = function(...n) {
    return this.keep.in(...n);
  }, $.prototype.reset = function(...n) {
    return this.keepif.reset(...n);
  }, $.prototype.resetAll = function(...n) {
    return this.keep.reset(...n);
  }, $.prototype.restart = function(...n) {
    return this.keepif.restart(...n);
  }, $.prototype.restartAll = function(...n) {
    return this.keep.restart(...n);
  };
})();
const g3 = Le, y3 = Le, A3 = Ki, vr = (e) => new $(() => [], e), Se = vr(1), Dt = vr(0);
function Je(e) {
  function t(r) {
    return r.span.spanCycles.map((i) => new je(j(i.begin).wholeCycle(), i, e));
  }
  const n = new $(t, 1);
  return n.__pure = e, n;
}
function Nu(e) {
  return e instanceof $ || e?._Pattern;
}
function q(e) {
  return Nu(e) ? e : au && typeof e == "string" ? au(e) : Je(e);
}
function Zc(e) {
  let t = Je([]);
  for (const n of e)
    t = t.bind((r) => n.fmap((i) => r.concat([i])));
  return t;
}
function Le(...e) {
  e = e.map((r) => Array.isArray(r) ? qt(...r) : q(r));
  const t = (r) => bn(e.map((i) => i.query(r))), n = new $(t);
  return $t && (n._steps = zt(...e.map((r) => r._steps))), n;
}
function Lu(e, t) {
  if (t = t.map((s) => Array.isArray(s) ? qt(...s) : q(s)), t.length === 0)
    return Se;
  if (t.length === 1)
    return t[0];
  const [n, ...r] = t.map((s) => s._steps), i = $t ? n.maximum(...r) : void 0;
  return Le(...e(i, t));
}
function Xc(...e) {
  return Lu(
    (t, n) => n.map((r) => r._steps.eq(t) ? r : At(r, vr(t.sub(r._steps)))),
    e
  );
}
function Wc(...e) {
  return Lu(
    (t, n) => n.map((r) => r._steps.eq(t) ? r : At(vr(t.sub(r._steps)), r)),
    e
  );
}
function Oc(...e) {
  return Lu(
    (t, n) => n.map((r) => {
      if (r._steps.eq(t))
        return r;
      const i = vr(t.sub(r._steps).div(2));
      return At(i, r, i);
    }),
    e
  );
}
function b3(e, ...t) {
  const [n, ...r] = t.map((u) => u._steps), i = n.maximum(...r), s = {
    centre: Oc,
    left: Xc,
    right: Wc,
    expand: Le,
    repeat: (...u) => Ki(...u).steps(i)
  };
  return e.inhabit(s).fmap((u) => u(...t)).innerJoin().setSteps(i);
}
function Rn(...e) {
  if (e = e.map((r) => Array.isArray(r) ? ot(...r) : q(r)), e.length == 1)
    return e[0];
  const t = function(r) {
    const i = r.span, s = kt(i.begin.sam(), e.length), u = e[s];
    if (!u)
      return [];
    const a = i.begin.floor().sub(i.begin.div(e.length).floor());
    return u.withHapTime((o) => o.add(a)).query(r.setSpan(i.withTime((o) => o.sub(a))));
  }, n = $t ? zt(...e.map((r) => r._steps)) : void 0;
  return new $(t).splitQueries().setSteps(n);
}
function Ru(...e) {
  e = e.map(q);
  const t = function(n) {
    const r = Math.floor(n.span.begin) % e.length;
    return e[r]?.query(n) || [];
  };
  return new $(t).splitQueries();
}
function zc(...e) {
  return Rn(...e);
}
function M3(...e) {
  const t = e.reduce((n, [r]) => n + r, 0);
  return e = e.map(([n, r]) => [n, r.fast(n)]), At(...e).slow(t);
}
function C3(...e) {
  let t = j(0);
  for (let n of e)
    n.length == 2 && n.unshift(t), t = n[1];
  return Le(
    ...e.map(
      ([n, r, i]) => Je(q(i)).compress(j(n).div(t), j(r).div(t))
    )
  ).slow(t).innerJoin();
}
function ot(...e) {
  let t = Rn(...e);
  return e.length > 1 && (t = t._fast(e.length), t._steps = e.length), e.length == 1 && e[0].__steps_source && (e._steps = e[0]._steps), t;
}
function qt(...e) {
  return ot(...e);
}
function jc(...e) {
  return ot(...e);
}
function ou(e) {
  return Array.isArray(e) ? e.length == 0 ? [Se, 0] : e.length == 1 ? ou(e[0]) : [ot(...e.map((t) => ou(t)[0])), e.length] : [q(e), 1];
}
const v3 = Ae((e, t) => q(t).mask(e)), P3 = Ae((e, t) => q(t).struct(e)), D3 = Ae((e, t) => q(t).superimpose(...e)), F3 = Ae((e, t) => q(t).withValue(e)), E3 = Ae((e, t) => q(t).bind(e)), x3 = Ae((e, t) => q(t).innerBind(e)), w3 = Ae((e, t) => q(t).outerBind(e)), S3 = Ae((e, t) => q(t).squeezeBind(e)), B3 = Ae((e, t) => q(t).stepBind(e)), _3 = Ae((e, t) => q(t).polyBind(e)), k3 = Ae((e, t) => q(t).set(e)), V3 = Ae((e, t) => q(t).keep(e)), I3 = Ae((e, t) => q(t).keepif(e)), T3 = Ae((e, t) => q(t).add(e)), N3 = Ae((e, t) => q(t).sub(e)), L3 = Ae((e, t) => q(t).mul(e)), R3 = Ae((e, t) => q(t).div(e)), G3 = Ae((e, t) => q(t).mod(e)), Z3 = Ae((e, t) => q(t).pow(e)), X3 = Ae((e, t) => q(t).band(e)), W3 = Ae((e, t) => q(t).bor(e)), O3 = Ae((e, t) => q(t).bxor(e)), z3 = Ae((e, t) => q(t).blshift(e)), j3 = Ae((e, t) => q(t).brshift(e)), $3 = Ae((e, t) => q(t).lt(e)), q3 = Ae((e, t) => q(t).gt(e)), H3 = Ae((e, t) => q(t).lte(e)), K3 = Ae((e, t) => q(t).gte(e)), Y3 = Ae((e, t) => q(t).eq(e)), J3 = Ae((e, t) => q(t).eqt(e)), U3 = Ae((e, t) => q(t).ne(e)), Q3 = Ae((e, t) => q(t).net(e)), eA = Ae((e, t) => q(t).and(e)), tA = Ae((e, t) => q(t).or(e)), nA = Ae((e, t) => q(t).func(e));
function N(e, t, n = !0, r = !1, i = (s) => s.innerJoin()) {
  if (Array.isArray(e)) {
    const a = {};
    for (const o of e)
      a[o] = N(o, t, n, r, i);
    return a;
  }
  const s = t.length;
  var u;
  return n ? u = function(...a) {
    a = a.map(q);
    const o = a[a.length - 1];
    let f;
    if (s === 1)
      f = t(o);
    else {
      const h = a.slice(0, -1);
      if (h.every((m) => m.__pure != null)) {
        const m = h.map((A) => A.__pure), p = h.filter((A) => A.__pure_loc).map((A) => A.__pure_loc);
        f = t(...m, o), f = f.withContext((A) => {
          const M = (A.locations || []).concat(p);
          return { ...A, locations: M };
        });
      } else {
        const [m, ...p] = h;
        let A = (...M) => t(...M, o);
        A = Ae(A, null, s - 1), f = i(p.reduce((M, C) => M.appLeft(C), m.fmap(A)));
      }
    }
    return r && (f._steps = o._steps), f;
  } : u = function(...a) {
    a = a.map(q);
    const o = t(...a);
    return r && (o._steps = a[a.length - 1]._steps), o;
  }, $.prototype[e] = function(...a) {
    if (s === 2 && a.length !== 1)
      a = [qt(...a)];
    else if (s !== a.length + 1)
      throw new Error(`.${e}() expects ${s - 1} inputs but got ${a.length}.`);
    return a = a.map(q), u(...a, this);
  }, s > 1 && ($.prototype["_" + e] = function(...a) {
    const o = t(...a, this);
    return r && o.setSteps(this._steps), o;
  }), Ae(u, null, s);
}
function ci(e, t, n = !0, r = !1, i = (s) => s.stepJoin()) {
  return N(e, t, n, r, i);
}
const rA = N("round", function(e) {
  return e.asNumber().fmap((t) => Math.round(t));
}), iA = N("floor", function(e) {
  return e.asNumber().fmap((t) => Math.floor(t));
}), sA = N("ceil", function(e) {
  return e.asNumber().fmap((t) => Math.ceil(t));
}), uA = N("toBipolar", function(e) {
  return e.fmap((t) => t * 2 - 1);
}), aA = N("fromBipolar", function(e) {
  return e.fmap((t) => (t + 1) / 2);
}), oA = N("range", function(e, t, n) {
  return n.mul(t - e).add(e);
}), cA = N("rangex", function(e, t, n) {
  return n._range(Math.log(e), Math.log(t)).fmap(Math.exp);
}), lA = N("range2", function(e, t, n) {
  return n.fromBipolar()._range(e, t);
}), fA = N(
  "ratio",
  (e) => e.fmap((t) => Array.isArray(t) ? t.slice(1).reduce((n, r) => n / r, t[0]) : t)
), hA = N("compress", function(e, t, n) {
  return e = j(e), t = j(t), e.gt(t) || e.gt(1) || t.gt(1) || e.lt(0) || t.lt(0) ? Se : n._fastGap(j(1).div(t.sub(e)))._late(e);
}), { compressSpan: pA, compressspan: dA } = N(["compressSpan", "compressspan"], function(e, t) {
  return t._compress(e.begin, e.end);
}), { fastGap: mA, fastgap: gA } = N(["fastGap", "fastgap"], function(e, t) {
  const n = function(i) {
    const s = i.begin.sam(), u = i.begin.sub(s).mul(e).min(1), a = i.end.sub(s).mul(e).min(1);
    if (!(u >= 1))
      return new He(s.add(u), s.add(a));
  }, r = function(i) {
    const s = i.part.begin, u = i.part.end, a = s.sam(), o = s.sub(a).div(e).min(1), f = u.sub(a).div(e).min(1), h = new He(a.add(o), a.add(f)), m = i.whole ? new He(
      h.begin.sub(s.sub(i.whole.begin).div(e)),
      h.end.add(i.whole.end.sub(u).div(e))
    ) : void 0;
    return new je(m, h, i.value, i.context);
  };
  return t.withQuerySpanMaybe(n).withHap(r).splitQueries();
}), yA = N("focus", function(e, t, n) {
  return e = j(e), t = j(t), n._early(e.sam())._fast(j(1).div(t.sub(e)))._late(e);
}), { focusSpan: AA, focusspan: bA } = N(["focusSpan", "focusspan"], function(e, t) {
  return t._focus(e.begin, e.end);
}), MA = N("ply", function(e, t) {
  const n = t.fmap((r) => Je(r)._fast(e)).squeezeJoin();
  return $t && (n._steps = j(e).mulmaybe(t._steps)), n;
}), { fast: CA, density: mE } = N(
  ["fast", "density"],
  function(e, t) {
    return e === 0 ? Se : (e = j(e), t.withQueryTime((r) => r.mul(e)).withHapTime((r) => r.div(e)).setSteps(t._steps));
  },
  !0,
  !0
), vA = N("hurry", function(e, t) {
  return t._fast(e).mul(Je({ speed: e }));
}), { slow: PA, sparsity: DA } = N(["slow", "sparsity"], function(e, t) {
  return e === 0 ? Se : t._fast(j(1).div(e));
}), FA = N("inside", function(e, t, n) {
  return t(n._slow(e))._fast(e);
}), EA = N("outside", function(e, t, n) {
  return t(n._fast(e))._slow(e);
}), xA = N("lastOf", function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.push(t(n)), Ru(...r);
}), { firstOf: wA, every: SA } = N(["firstOf", "every"], function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.unshift(t(n)), Ru(...r);
}), BA = N("apply", function(e, t) {
  return e(t);
}), _A = N("cpm", function(e, t) {
  return t._fast(e / 60 / 1);
}), kA = N(
  "early",
  function(e, t) {
    return e = j(e), t.withQueryTime((n) => n.add(e)).withHapTime((n) => n.sub(e));
  },
  !0,
  !0
), $c = N(
  "late",
  function(e, t) {
    return e = j(e), t._early(j(0).sub(e));
  },
  !0,
  !0
), VA = N("zoom", function(e, t, n) {
  if (t = j(t), e = j(e), e.gte(t))
    return Dt;
  const r = t.sub(e), i = $t ? n._steps?.mulmaybe(r) : void 0;
  return n.withQuerySpan((s) => s.withCycle((u) => u.mul(r).add(e))).withHapSpan((s) => s.withCycle((u) => u.sub(e).div(r))).splitQueries().setSteps(i);
}), { zoomArc: IA, zoomarc: TA } = N(["zoomArc", "zoomarc"], function(e, t) {
  return t.zoom(e.begin, e.end);
}), NA = N(
  "bite",
  (e, t, n) => t.fmap((r) => (i) => {
    const s = j(r).div(i).mod(1), u = s.add(j(1).div(i));
    return n.zoom(s, u);
  }).appLeft(e).squeezeJoin(),
  !1
), LA = N(
  "linger",
  function(e, t) {
    return e == 0 ? Se : e < 0 ? t._zoom(e.add(1), 1)._slow(e) : t._zoom(0, e)._slow(e);
  },
  !0,
  !0
), { segment: RA, seg: GA } = N(["segment", "seg"], function(e, t) {
  return t.struct(Je(!0)._fast(e)).setSteps(e);
}), ZA = N("swingBy", (e, t, n) => n.inside(t, $c(jc(0, e / 2)))), XA = N("swing", (e, t) => t.swingBy(1 / 3, e)), { invert: WA, inv: OA } = N(
  ["invert", "inv"],
  function(e) {
    return e.fmap((t) => !t);
  },
  !0,
  !0
), zA = N("when", function(e, t, n) {
  return e ? t(n) : n;
}), jA = N("off", function(e, t, n) {
  return Le(n, t(n.late(e)));
}), $A = N("brak", function(e) {
  return e.when(Rn(!1, !0), (t) => ot(t, Se)._late(0.25));
}), qc = N(
  "rev",
  function(e) {
    const t = function(n) {
      const r = n.span, i = r.begin.sam(), s = r.begin.nextSam(), u = function(o) {
        const f = o.withTime((m) => i.add(s.sub(m))), h = f.begin;
        return f.begin = f.end, f.end = h, f;
      };
      return e.query(n.setSpan(u(r))).map((o) => o.withSpan(u));
    };
    return new $(t).splitQueries();
  },
  !1,
  !0
), qA = N("pressBy", function(e, t) {
  return t.fmap((n) => Je(n).compress(e, 1)).squeezeJoin();
}), HA = N("press", function(e) {
  return e._pressBy(0.5);
});
$.prototype.hush = function() {
  return Se;
};
const KA = N(
  "palindrome",
  function(e) {
    return e.lastOf(2, qc);
  },
  !0,
  !0
), { juxBy: YA, juxby: JA } = N(["juxBy", "juxby"], function(e, t, n) {
  e /= 2;
  const r = function(u, a, o) {
    return a in u ? u[a] : o;
  }, i = n.withValue((u) => Object.assign({}, u, { pan: r(u, "pan", 0.5) - e })), s = t(n.withValue((u) => Object.assign({}, u, { pan: r(u, "pan", 0.5) + e })));
  return Le(i, s).setSteps($t ? zt(i._steps, s._steps) : void 0);
}), UA = N("jux", function(e, t) {
  return t._juxBy(1, e, t);
}), { echoWith: QA, echowith: eb, stutWith: tb, stutwith: nb } = N(
  ["echoWith", "echowith", "stutWith", "stutwith"],
  function(e, t, n, r) {
    return Le(..._u(0, e - 1).map((i) => n(r.late(j(t).mul(i)), i)));
  }
), rb = N("echo", function(e, t, n, r) {
  return r._echoWith(e, t, (i, s) => i.gain(Math.pow(n, s)));
}), ib = N("stut", function(e, t, n, r) {
  return r._echoWith(e, n, (i, s) => i.gain(Math.pow(t, s)));
}), Gu = function(e, t, n = !1) {
  return e = j(e), Rn(
    ..._u(0, e.sub(1)).map(
      (r) => n ? t.late(j(r).div(e)) : t.early(j(r).div(e))
    )
  );
}, sb = N(
  "iter",
  function(e, t) {
    return Gu(e, t, !1);
  },
  !0,
  !0
), { iterBack: ub, iterback: ab } = N(
  ["iterBack", "iterback"],
  function(e, t) {
    return Gu(e, t, !0);
  },
  !0,
  !0
), { repeatCycles: ob } = N(
  "repeatCycles",
  function(e, t) {
    return new $(function(n) {
      const r = n.span.begin.sam(), i = r.div(e).sam(), s = r.sub(i);
      return n = n.withSpan((u) => u.withTime((a) => a.sub(s))), t.query(n).map((u) => u.withSpan((a) => a.withTime((o) => o.add(s))));
    }).splitQueries();
  },
  !0,
  !0
), Zu = function(e, t, n, r = !1, i = !1) {
  const s = Array(e - 1).fill(!1);
  s.unshift(!0);
  const u = Gu(e, qt(...s), !r);
  return i || (n = n.repeatCycles(e)), n.when(u, t);
}, { chunk: cb, slowchunk: lb, slowChunk: fb } = N(
  ["chunk", "slowchunk", "slowChunk"],
  function(e, t, n) {
    return Zu(e, t, n, !1, !1);
  },
  !0,
  !0
), { chunkBack: hb, chunkback: pb } = N(
  ["chunkBack", "chunkback"],
  function(e, t, n) {
    return Zu(e, t, n, !0);
  },
  !0,
  !0
), { fastchunk: db, fastChunk: mb } = N(
  ["fastchunk", "fastChunk"],
  function(e, t, n) {
    return Zu(e, t, n, !1, !0);
  },
  !0,
  !0
), { chunkinto: gb, chunkInto: yb } = N(["chunkinto", "chunkInto"], function(e, t, n) {
  return n.into(ot(!0, ...Array(e - 1).fill(!1))._iterback(e), t);
}), { chunkbackinto: Ab, chunkBackInto: bb } = N(["chunkbackinto", "chunkBackInto"], function(e, t, n) {
  return n.into(
    ot(!0, ...Array(e - 1).fill(!1))._iter(e)._early(1),
    t
  );
}), Mb = N(
  "bypass",
  function(e, t) {
    return e = !!parseInt(e), e ? Se : t;
  },
  !0,
  !0
), { ribbon: Cb, rib: vb } = N(
  ["ribbon", "rib"],
  (e, t, n) => n.early(e).restart(Je(1).slow(t))
), Pb = N("hsla", (e, t, n, r, i) => i.color(`hsla(${e}turn,${t * 100}%,${n * 100}%,${r})`)), Db = N("hsl", (e, t, n, r) => r.color(`hsl(${e}turn,${t * 100}%,${n * 100}%)`));
$.prototype.tag = function(e) {
  return this.withContext((t) => ({ ...t, tags: (t.tags || []).concat([e]) }));
};
const Fb = N("filter", (e, t) => t.withHaps((n) => n.filter(e))), Eb = N("filterWhen", (e, t) => t.filter((n) => e(n.whole.begin))), xb = N(
  "within",
  (e, t, n, r) => Le(
    n(r.filterWhen((i) => i.cyclePos() >= e && i.cyclePos() <= t)),
    r.filterWhen((i) => i.cyclePos() < e || i.cyclePos() > t)
  )
);
$.prototype.stepJoin = function() {
  const e = this, t = At(...cu(lu(e.queryArc(0, 1))))._steps, n = function(r) {
    const s = e.early(r.span.begin.sam()).query(r.setSpan(new He(j(0), j(1))));
    return At(...cu(lu(s))).query(r);
  };
  return new $(n, t);
};
$.prototype.stepBind = function(e) {
  return this.fmap(e).stepJoin();
};
function cu(e) {
  const t = e.filter((s, u) => u.hasSteps).reduce((s, u) => s.add(u), j(0)), n = Cr(e.map((s, u) => u._steps)).reduce(
    (s, u) => s.add(u),
    j(0)
  ), r = t.eq(0) ? void 0 : n.div(t);
  function i(s, u) {
    return u._steps === void 0 ? [s.mulmaybe(r), u] : [u._steps, u];
  }
  return e.map((s) => i(...s));
}
function lu(e) {
  const t = bn(e.map((i) => [i.part.begin, i.part.end])), n = _c([j(0), j(1), ...t]);
  return Bc(n).map((i) => [
    i[1].sub(i[0]),
    Le(...Hc(new He(...i), e).map((s) => s.value.withHap((u) => u.setContext(u.combineContext(s)))))
  ]);
}
function Hc(e, t) {
  return Cr(t.map((n) => Kc(e, n)));
}
function Kc(e, t) {
  const n = e.intersection(t.part);
  if (n != null)
    return new je(t.whole, n, t.value, t.context);
}
const Yc = N("pace", function(e, t) {
  return t._steps === void 0 ? t : t._steps.eq(j(0)) ? Dt : t._fast(j(e).div(t._steps)).setSteps(e);
});
function Jc(e, ...t) {
  const n = t.map((i) => ou(i));
  if (n.length == 0)
    return Se;
  e == 0 && (e = n[0][1]);
  const r = [];
  for (const i of n)
    i[1] != 0 && (e == i[1] ? r.push(i[0]) : r.push(i[0]._fast(j(e).div(j(i[1])))));
  return Le(...r);
}
function Ki(...e) {
  if (Array.isArray(e[0]))
    return Jc(0, ...e);
  if (e = e.filter((r) => r.hasSteps), e.length == 0)
    return Se;
  const t = zt(...e.map((r) => r._steps));
  if (t.eq(j(0)))
    return Dt;
  const n = Le(...e.map((r) => r.pace(t)));
  return n._steps = t, n;
}
function At(...e) {
  if (e.length === 0)
    return Dt;
  const t = (u) => Array.isArray(u) ? u : [u._steps ?? 1, u];
  if (e = e.map(t), e.find((u) => u[0] === void 0)) {
    const u = e.map((o) => o[0]).filter((o) => o !== void 0);
    if (u.length === 0)
      return ot(...e.map((o) => o[1]));
    if (u.length === e.length)
      return Dt;
    const a = u.reduce((o, f) => o.add(f), j(0)).div(u.length);
    for (let o of e)
      o[0] === void 0 && (o[0] = a);
  }
  if (e.length == 1)
    return q(e[0][1]).withSteps((a) => e[0][0]);
  const n = e.map((u) => u[0]).reduce((u, a) => u.add(a), j(0));
  let r = j(0);
  const i = [];
  for (const [u, a] of e) {
    if (j(u).eq(0))
      continue;
    const o = r.add(u);
    i.push(q(a)._compress(r.div(n), o.div(n))), r = o;
  }
  const s = Le(...i);
  return s._steps = n, s;
}
function Uc(...e) {
  e = e.map((i) => Array.isArray(i) ? i.map(q) : [q(i)]);
  const t = zt(...e.map((i) => j(i.length)));
  let n = [];
  for (let i = 0; i < t; ++i)
    n.push(...e.map((s) => s.length == 0 ? Se : s[i % s.length]));
  n = n.filter((i) => i.hasSteps && i._steps > 0);
  const r = n.reduce((i, s) => i.add(s._steps), j(0));
  return n = At(...n), n._steps = r, n;
}
const Qc = ci("take", function(e, t) {
  if (!t.hasSteps || t._steps.lte(0) || (e = j(e), e.eq(0)))
    return Dt;
  const n = e < 0;
  n && (e = e.abs());
  const r = e.div(t._steps);
  return r.lte(0) ? Dt : r.gte(1) ? t : n ? t.zoom(j(1).sub(r), 1) : t.zoom(0, r);
}), el = ci("drop", function(e, t) {
  return t.hasSteps ? (e = j(e), e.lt(0) ? t.take(t._steps.add(e)) : t.take(j(0).sub(t._steps.sub(e)))) : Dt;
}), tl = ci("extend", function(e, t) {
  return t.fast(e).expand(e);
}), nl = ci("expand", function(e, t) {
  return t.withSteps((n) => n.mul(j(e)));
}), rl = ci("contract", function(e, t) {
  return t.withSteps((n) => n.div(j(e)));
});
$.prototype.shrinklist = function(e) {
  const t = this;
  if (!t.hasSteps)
    return [t];
  let [n, r] = Array.isArray(e) ? e : [e, t._steps];
  if (n = j(n), r === 0 || n === 0)
    return [t];
  const i = n > 0, s = [];
  if (i) {
    const u = j(1).div(t._steps).mul(n);
    for (let a = 0; a < r; ++a) {
      const o = u.mul(a);
      if (o.gt(1))
        break;
      s.push([o, 1]);
    }
  } else {
    n = j(0).sub(n);
    const u = j(1).div(t._steps).mul(n);
    for (let a = 0; a < r; ++a) {
      const o = j(1).sub(u.mul(a));
      if (o.lt(0))
        break;
      s.push([j(0), o]);
    }
  }
  return s.map((u) => t.zoom(...u));
};
const il = (e, t) => t.shrinklist(e), sl = N(
  "shrink",
  function(e, t) {
    if (!t.hasSteps)
      return Dt;
    const n = t.shrinklist(e), r = At(...n);
    return r._steps = n.reduce((i, s) => i.add(s._steps), j(0)), r;
  },
  !0,
  !1,
  (e) => e.stepJoin()
), wb = N(
  "grow",
  function(e, t) {
    if (!t.hasSteps)
      return Dt;
    const n = t.shrinklist(j(0).sub(e));
    n.reverse();
    const r = At(...n);
    return r._steps = n.reduce((i, s) => i.add(s._steps), j(0)), r;
  },
  !0,
  !1,
  (e) => e.stepJoin()
), ul = function(e, ...t) {
  return e.tour(...t);
};
$.prototype.tour = function(...e) {
  return At(
    ...[].concat(
      ...e.map((t, n) => [...e.slice(0, e.length - n), this, ...e.slice(e.length - n)]),
      this,
      ...e
    )
  );
};
const al = function(...e) {
  e = e.filter((r) => r.hasSteps);
  const t = Rn(...e.map((r) => r._slow(r._steps))), n = zt(...e.map((r) => r._steps));
  return t._fast(n).setSteps(n);
}, Sb = At, Xu = At, Bb = At, _b = Uc, kb = Ki;
$.prototype.s_polymeter = $.prototype.polymeter;
const Vb = sl;
$.prototype.s_taper = $.prototype.shrink;
const Ib = il;
$.prototype.s_taperlist = $.prototype.shrinklist;
const Tb = Qc;
$.prototype.s_add = $.prototype.take;
const Nb = el;
$.prototype.s_sub = $.prototype.drop;
const Lb = nl;
$.prototype.s_expand = $.prototype.expand;
const Rb = tl;
$.prototype.s_extend = $.prototype.extend;
const Gb = rl;
$.prototype.s_contract = $.prototype.contract;
const Zb = ul;
$.prototype.s_tour = $.prototype.tour;
const Xb = al;
$.prototype.s_zip = $.prototype.zip;
const Wb = Yc;
$.prototype.steps = $.prototype.pace;
const Ob = N("chop", function(e, t) {
  const r = Array.from({ length: e }, (u, a) => a).map((u) => ({ begin: u / e, end: (u + 1) / e })), i = function(u, a) {
    if ("begin" in u && "end" in u && u.begin !== void 0 && u.end !== void 0) {
      const o = u.end - u.begin;
      a = { begin: u.begin + a.begin * o, end: u.begin + a.end * o };
    }
    return Object.assign({}, u, a);
  }, s = function(u) {
    return qt(r.map((a) => i(u, a)));
  };
  return t.squeezeBind(s).setSteps($t ? j(e).mulmaybe(t._steps) : void 0);
}), zb = N("striate", function(e, t) {
  const r = Array.from({ length: e }, (s, u) => u).map((s) => ({ begin: s / e, end: (s + 1) / e })), i = Rn(...r);
  return t.set(i)._fast(e).setSteps($t ? j(e).mulmaybe(t._steps) : void 0);
}), ol = function(e, t, n = 0.5) {
  return t.speed(1 / e * n).unit("c").slow(e);
}, cl = N(
  "slice",
  function(e, t, n) {
    return e.innerBind(
      (r) => t.outerBind(
        (i) => n.outerBind((s) => {
          s = s instanceof Object ? s : { s };
          const u = Array.isArray(r) ? r[i] : i / r, a = Array.isArray(r) ? r[i + 1] : (i + 1) / r;
          return Je({ begin: u, end: a, _slices: r, ...s });
        })
      )
    ).setSteps(t._steps);
  },
  !1
  // turns off auto-patternification
);
$.prototype.onTriggerTime = function(e) {
  return this.onTrigger((t, n, r, i) => {
    const s = i - n;
    window.setTimeout(() => {
      e(t);
    }, s * 1e3);
  }, !1);
};
const jb = N(
  "splice",
  function(e, t, n) {
    const r = cl(e, t, n);
    return new $((i) => {
      const s = i.controls._cps || 1;
      return r.query(i).map(
        (a) => a.withValue((o) => ({
          speed: s / o._slices / a.whole.duration * (o.speed || 1),
          unit: "c",
          ...o
        }))
      );
    }).setSteps(t._steps);
  },
  !1
  // turns off auto-patternification
), { loopAt: $b, loopat: qb } = N(["loopAt", "loopat"], function(e, t) {
  const n = t._steps ? t._steps.div(e) : void 0;
  return new $((r) => ol(e, t, r.controls._cps).query(r), n);
}), Hb = N(
  "fit",
  (e) => e.withHaps(
    (t, n) => t.map(
      (r) => r.withValue((i) => {
        const s = ("end" in i ? i.end : 1) - ("begin" in i ? i.begin : 0);
        return {
          ...i,
          speed: (n.controls._cps || 1) / r.whole.duration * s,
          unit: "c"
        };
      })
    )
  )
), { loopAtCps: Kb, loopatcps: Yb } = N(["loopAtCps", "loopatcps"], function(e, t, n) {
  return ol(e, n, t);
}), Jb = (e) => Je(1).withValue(() => q(e())).innerJoin();
let lo = (e) => e < 0.5 ? 1 : 1 - (e - 0.5) / 0.5, ll = (e, t, n) => {
  t = q(t), e = q(e), n = q(n);
  let r = t.fmap((s) => ({ gain: lo(s) })), i = t.fmap((s) => ({ gain: lo(1 - s) }));
  return Le(e.mul(r), n.mul(i));
};
$.prototype.xfade = function(e, t) {
  return ll(this, e, t);
};
const Ub = (e) => (t, n, r) => {
  t = j(t).mod(n), n = j(n);
  const i = t.div(n), s = t.add(1).div(n);
  return e(r.fmap((u) => Je(u)._compress(i, s)));
}, { beat: Qb } = N(
  ["beat"],
  Ub((e) => e.innerJoin())
), Wu = (e, t, n) => {
  n = j(n);
  const r = j(1).div(e.length), i = (a) => {
    const o = [];
    for (const [f, h] of a.entries())
      h && o.push([j(f).div(a.length), h]);
    return o;
  }, s = qi(
    ([a, o], [f, h]) => {
      const m = n.mul(f - a).add(a), p = m.add(r);
      return new He(m, p);
    },
    i(e),
    i(t)
  );
  function u(a) {
    const o = a.span.begin.sam(), f = a.span.cycleArc(), h = [];
    for (const m of s) {
      const p = m.intersection(f);
      p !== void 0 && h.push(
        new je(
          m.withTime((A) => A.add(o)),
          p.withTime((A) => A.add(o)),
          !0
        )
      );
    }
    return h;
  }
  return new $(u).splitQueries();
}, eM = (e, t, n) => (e = q(e), t = q(t), n = q(n), e.innerBind((r) => t.innerBind((i) => n.innerBind((s) => Wu(r, i, s)))));
function Yi(e) {
  let t = Array.isArray(e);
  e = t ? e : [e];
  const n = e[0], r = (s) => {
    let u;
    if (typeof s == "object" && s.value !== void 0 && (u = { ...s }, s = s.value, delete u.value), t && Array.isArray(s)) {
      const a = u || {};
      return s.forEach((o, f) => {
        f < e.length && (a[e[f]] = o);
      }), a;
    } else return u ? (u[n] = s, u) : { [n]: s };
  }, i = function(s, u) {
    return u ? typeof s > "u" ? u.fmap(r) : u.set(q(s).withValue(r)) : q(s).withValue(r);
  };
  return $.prototype[n] = function(s) {
    return i(s, this);
  }, i;
}
const ni = /* @__PURE__ */ new Map();
function fl(e) {
  return ni.has(e);
}
function w(e, ...t) {
  const n = Array.isArray(e) ? e[0] : e;
  let r = {};
  return r[n] = Yi(e), ni.set(n, n), t.forEach((i) => {
    r[i] = r[n], ni.set(i, n), $.prototype[i] = $.prototype[n];
  }), r;
}
const { s: hl, sound: pl } = w(["s", "n", "gain"], "sound"), { source: dl, src: ml } = w("source", "src"), { n: gl } = w("n"), { note: yl } = w(["note", "n"]), { accelerate: Al } = w("accelerate"), { velocity: bl } = w("velocity"), { gain: Ml } = w("gain"), { postgain: Cl } = w("postgain"), { amp: vl } = w("amp"), { attack: Pl, att: Dl } = w("attack", "att"), { fmh: Fl } = w(["fmh", "fmi"], "fmh"), { fmi: El, fm: xl } = w(["fmi", "fmh"], "fm"), { fmenv: wl } = w("fmenv"), { fmattack: Sl } = w("fmattack"), { fmwave: Bl } = w("fmwave"), { fmdecay: _l } = w("fmdecay"), { fmsustain: kl } = w("fmsustain"), { fmrelease: Vl } = w("fmrelease"), { fmvelocity: Il } = w("fmvelocity"), { bank: Tl } = w("bank"), { analyze: Nl } = w("analyze"), { fft: Ll } = w("fft"), { decay: Rl, dec: Gl } = w("decay", "dec"), { sustain: Zl, sus: Xl } = w("sustain", "sus"), { release: Wl, rel: Ol } = w("release", "rel"), { hold: zl } = w("hold"), { bandf: jl, bpf: $l, bp: ql } = w(["bandf", "bandq", "bpenv"], "bpf", "bp"), { bandq: Hl, bpq: Kl } = w("bandq", "bpq"), { begin: Yl } = w("begin"), { end: Jl } = w("end"), { loop: Ul } = w("loop"), { loopBegin: Ql, loopb: e0 } = w("loopBegin", "loopb"), { loopEnd: t0, loope: n0 } = w("loopEnd", "loope"), { crush: r0 } = w("crush"), { coarse: i0 } = w("coarse"), { tremolo: s0 } = w(["tremolo", "tremolodepth", "tremoloskew", "tremolophase"], "trem"), { tremolosync: u0 } = w(
  ["tremolosync", "tremolodepth", "tremoloskew", "tremolophase"],
  "tremsync"
), { tremolodepth: a0 } = w("tremolodepth", "tremdepth"), { tremoloskew: o0 } = w("tremoloskew", "tremskew"), { tremolophase: c0 } = w("tremolophase", "tremphase"), { tremoloshape: l0 } = w("tremoloshape", "tremshape"), { duck: f0 } = w("duckorbit", "duck"), { duckdepth: h0 } = w("duckdepth"), { duckattack: p0 } = w("duckattack", "duckatt"), { drive: d0 } = w("drive"), { byteBeatExpression: m0, bbexpr: g0 } = w("byteBeatExpression", "bbexpr"), { byteBeatStartTime: y0, bbst: A0 } = w("byteBeatStartTime", "bbst"), { channels: b0, ch: M0 } = w("channels", "ch"), { pw: C0 } = w(["pw", "pwrate", "pwsweep"]), { pwrate: v0 } = w("pwrate"), { pwsweep: P0 } = w("pwsweep"), { phaserrate: D0, ph: F0, phaser: E0 } = w(
  ["phaserrate", "phaserdepth", "phasercenter", "phasersweep"],
  "ph",
  "phaser"
), { phasersweep: x0, phs: w0 } = w("phasersweep", "phs"), { phasercenter: S0, phc: B0 } = w("phasercenter", "phc"), { phaserdepth: _0, phd: k0, phasdp: V0 } = w("phaserdepth", "phd", "phasdp"), { channel: I0 } = w("channel"), { cut: T0 } = w("cut"), { cutoff: N0, ctf: L0, lpf: R0, lp: G0 } = w(["cutoff", "resonance", "lpenv"], "ctf", "lpf", "lp"), { lpenv: Z0, lpe: X0 } = w("lpenv", "lpe"), { hpenv: W0, hpe: O0 } = w("hpenv", "hpe"), { bpenv: z0, bpe: j0 } = w("bpenv", "bpe"), { lpattack: $0, lpa: q0 } = w("lpattack", "lpa"), { hpattack: H0, hpa: K0 } = w("hpattack", "hpa"), { bpattack: Y0, bpa: J0 } = w("bpattack", "bpa"), { lpdecay: U0, lpd: Q0 } = w("lpdecay", "lpd"), { hpdecay: ef, hpd: tf } = w("hpdecay", "hpd"), { bpdecay: nf, bpd: rf } = w("bpdecay", "bpd"), { lpsustain: sf, lps: uf } = w("lpsustain", "lps"), { hpsustain: af, hps: of } = w("hpsustain", "hps"), { bpsustain: cf, bps: lf } = w("bpsustain", "bps"), { lprelease: ff, lpr: hf } = w("lprelease", "lpr"), { hprelease: pf, hpr: df } = w("hprelease", "hpr"), { bprelease: mf, bpr: gf } = w("bprelease", "bpr"), { ftype: yf } = w("ftype"), { fanchor: Af } = w("fanchor"), { vib: bf, vibrato: Mf, v: Cf } = w(["vib", "vibmod"], "vibrato", "v"), { noise: vf } = w("noise"), { vibmod: Pf, vmod: Df } = w(["vibmod", "vib"], "vmod"), { hcutoff: Ff, hpf: Ef, hp: xf } = w(["hcutoff", "hresonance", "hpenv"], "hpf", "hp"), { hresonance: wf, hpq: Sf } = w("hresonance", "hpq"), { resonance: Bf, lpq: _f } = w("resonance", "lpq"), { djf: kf } = w("djf"), { delay: Vf } = w(["delay", "delaytime", "delayfeedback"]), { delayfeedback: If, delayfb: Tf, dfb: Nf } = w("delayfeedback", "delayfb", "dfb"), { delaytime: Lf, delayt: Rf, dt: Gf } = w("delaytime", "delayt", "dt"), { delaysync: Zf } = w("delaysync"), { lock: Xf } = w("lock"), { detune: Wf, det: Of } = w("detune", "det"), { unison: zf } = w("unison"), { spread: jf } = w("spread"), { dry: $f } = w("dry"), { fadeTime: qf, fadeOutTime: Hf } = w("fadeTime", "fadeOutTime"), { fadeInTime: Kf } = w("fadeInTime"), { freq: Yf } = w("freq"), { pattack: Jf, patt: Uf } = w("pattack", "patt"), { pdecay: Qf, pdec: eh } = w("pdecay", "pdec"), { psustain: th, psus: nh } = w("psustain", "psus"), { prelease: rh, prel: ih } = w("prelease", "prel"), { penv: sh } = w("penv"), { pcurve: uh } = w("pcurve"), { panchor: ah } = w("panchor"), { gate: oh, gat: ch } = w("gate", "gat"), { leslie: lh } = w("leslie"), { lrate: fh } = w("lrate"), { lsize: hh } = w("lsize"), { activeLabel: ph } = w("activeLabel"), { label: dh } = w(["label", "activeLabel"]), { degree: mh } = w("degree"), { mtranspose: gh } = w("mtranspose"), { ctranspose: yh } = w("ctranspose"), { harmonic: Ah } = w("harmonic"), { stepsPerOctave: bh } = w("stepsPerOctave"), { octaveR: Mh } = w("octaveR"), { nudge: Ch } = w("nudge"), { octave: vh } = w("octave"), { orbit: Ph } = w("orbit"), { overgain: Dh } = w("overgain"), { overshape: Fh } = w("overshape"), { pan: Eh } = w("pan"), { panspan: xh } = w("panspan"), { pansplay: wh } = w("pansplay"), { panwidth: Sh } = w("panwidth"), { panorient: Bh } = w("panorient"), { rate: _h } = w("rate"), { slide: kh } = w("slide"), { semitone: Vh } = w("semitone"), { voice: Ih } = w("voice"), { chord: Th } = w("chord"), { dictionary: Nh, dict: Lh } = w("dictionary", "dict"), { anchor: Rh } = w("anchor"), { offset: Gh } = w("offset"), { octaves: Zh } = w("octaves"), { mode: Xh } = w(["mode", "anchor"]), { room: Wh } = w(["room", "size"]), { roomlp: Oh, rlp: zh } = w("roomlp", "rlp"), { roomdim: jh, rdim: $h } = w("roomdim", "rdim"), { roomfade: qh, rfade: Hh } = w("roomfade", "rfade"), { ir: Kh, iresponse: Yh } = w(["ir", "i"], "iresponse"), { irspeed: Jh } = w("irspeed"), { irbegin: Uh } = w("irbegin"), { roomsize: Qh, size: e1, sz: t1, rsize: n1 } = w("roomsize", "size", "sz", "rsize"), { shape: r1 } = w(["shape", "shapevol"]), { distort: i1, dist: s1 } = w(["distort", "distortvol"], "dist"), { compressor: u1 } = w([
  "compressor",
  "compressorRatio",
  "compressorKnee",
  "compressorAttack",
  "compressorRelease"
]), { compressorKnee: a1 } = w("compressorKnee"), { compressorRatio: o1 } = w("compressorRatio"), { compressorAttack: c1 } = w("compressorAttack"), { compressorRelease: l1 } = w("compressorRelease"), { speed: Ou } = w("speed"), { stretch: f1 } = w("stretch"), { unit: h1 } = w("unit"), { squiz: p1 } = w("squiz"), { vowel: d1 } = w("vowel"), { waveloss: m1 } = w("waveloss"), { density: tM } = w("density"), { expression: g1 } = w("expression"), { sustainpedal: y1 } = w("sustainpedal"), { fshift: A1 } = w("fshift"), { fshiftnote: b1 } = w("fshiftnote"), { fshiftphase: M1 } = w("fshiftphase"), { triode: C1 } = w("triode"), { krush: v1 } = w("krush"), { kcutoff: P1 } = w("kcutoff"), { octer: D1 } = w("octer"), { octersub: F1 } = w("octersub"), { octersubsub: E1 } = w("octersubsub"), { ring: x1 } = w("ring"), { ringf: w1 } = w("ringf"), { ringdf: S1 } = w("ringdf"), { freeze: B1 } = w("freeze"), { xsdelay: _1 } = w("xsdelay"), { tsdelay: k1 } = w("tsdelay"), { real: V1 } = w("real"), { imag: I1 } = w("imag"), { enhance: T1 } = w("enhance"), { partials: N1 } = w("partials"), { comb: L1 } = w("comb"), { smear: R1 } = w("smear"), { scram: G1 } = w("scram"), { binshift: Z1 } = w("binshift"), { hbrick: X1 } = w("hbrick"), { lbrick: W1 } = w("lbrick"), { frameRate: O1 } = w("frameRate"), { frames: z1 } = w("frames"), { hours: j1 } = w("hours"), { minutes: $1 } = w("minutes"), { seconds: q1 } = w("seconds"), { songPtr: H1 } = w("songPtr"), { uid: K1 } = w("uid"), { val: Y1 } = w("val"), { cps: J1 } = w("cps"), { clip: U1, legato: Q1 } = w("clip", "legato"), { duration: ep, dur: tp } = w("duration", "dur"), { zrand: np } = w("zrand"), { curve: rp } = w("curve"), { deltaSlide: ip } = w("deltaSlide"), { pitchJump: sp } = w("pitchJump"), { pitchJumpTime: up } = w("pitchJumpTime"), { lfo: ap, repeatTime: op } = w("lfo", "repeatTime"), { znoise: cp } = w("znoise"), { zmod: lp } = w("zmod"), { zcrush: fp } = w("zcrush"), { zdelay: hp } = w("zdelay"), { zzfx: pp } = w("zzfx"), { color: dp, colour: mp } = w(["color", "colour"]);
let zu = (...e) => e.reduce((t, n) => Object.assign(t, { [n]: Yi(n) }), {});
const gp = N("adsr", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r, i, s] = e;
  return t.set({ attack: n, decay: r, sustain: i, release: s });
}), yp = N("ad", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.attack(n).decay(r);
}), Ap = N("ds", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = 0] = e;
  return t.set({ decay: n, sustain: r });
}), bp = N("ar", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.set({ attack: n, release: r });
}), { midichan: Mp } = w("midichan"), { midimap: Cp } = w("midimap"), { midiport: vp } = w("midiport"), { midicmd: Pp } = w("midicmd"), Dp = N("control", (e, t) => {
  if (!Array.isArray(e))
    throw new Error("control expects an array of [ccn, ccv]");
  const [n, r] = e;
  return t.ccn(n).ccv(r);
}), { ccn: Fp } = w("ccn"), { ccv: Ep } = w("ccv"), { ctlNum: xp } = w("ctlNum"), { nrpnn: wp } = w("nrpnn"), { nrpv: Sp } = w("nrpv"), { progNum: Bp } = w("progNum"), _p = N("sysex", (e, t) => {
  if (!Array.isArray(e))
    throw new Error("sysex expects an array of [id, data]");
  const [n, r] = e;
  return t.sysexid(n).sysexdata(r);
}), { sysexid: kp } = w("sysexid"), { sysexdata: Vp } = w("sysexdata"), { midibend: Ip } = w("midibend"), { miditouch: Tp } = w("miditouch"), { polyTouch: Np } = w("polyTouch"), ju = (e) => ni.has(e) ? ni.get(e) : e, Lp = N("as", (e, t) => (e = Array.isArray(e) ? e : [e], t.fmap((n) => (n = Array.isArray(n) ? n : [n], n = Object.fromEntries(e.map((r, i) => [ju(r), n[i]])), n)))), Rp = N(
  "scrub",
  (e, t) => e.outerBind((n) => {
    Array.isArray(n) || (n = [n]);
    const [r, i = 1] = n;
    return t.begin(r).mul(Ou(i)).clip(1);
  }),
  !1
), nM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accelerate: Al,
  activeLabel: ph,
  ad: yp,
  adsr: gp,
  amp: vl,
  analyze: Nl,
  anchor: Rh,
  ar: bp,
  as: Lp,
  att: Dl,
  attack: Pl,
  bandf: jl,
  bandq: Hl,
  bank: Tl,
  bbexpr: g0,
  bbst: A0,
  begin: Yl,
  binshift: Z1,
  bp: ql,
  bpa: J0,
  bpattack: Y0,
  bpd: rf,
  bpdecay: nf,
  bpe: j0,
  bpenv: z0,
  bpf: $l,
  bpq: Kl,
  bpr: gf,
  bprelease: mf,
  bps: lf,
  bpsustain: cf,
  byteBeatExpression: m0,
  byteBeatStartTime: y0,
  ccn: Fp,
  ccv: Ep,
  ch: M0,
  channel: I0,
  channels: b0,
  chord: Th,
  clip: U1,
  coarse: i0,
  color: dp,
  colour: mp,
  comb: L1,
  compressor: u1,
  compressorAttack: c1,
  compressorKnee: a1,
  compressorRatio: o1,
  compressorRelease: l1,
  control: Dp,
  cps: J1,
  createParam: Yi,
  createParams: zu,
  crush: r0,
  ctf: L0,
  ctlNum: xp,
  ctranspose: yh,
  curve: rp,
  cut: T0,
  cutoff: N0,
  dec: Gl,
  decay: Rl,
  degree: mh,
  delay: Vf,
  delayfb: Tf,
  delayfeedback: If,
  delaysync: Zf,
  delayt: Rf,
  delaytime: Lf,
  deltaSlide: ip,
  density: tM,
  det: Of,
  detune: Wf,
  dfb: Nf,
  dict: Lh,
  dictionary: Nh,
  dist: s1,
  distort: i1,
  djf: kf,
  drive: d0,
  dry: $f,
  ds: Ap,
  dt: Gf,
  duck: f0,
  duckattack: p0,
  duckdepth: h0,
  dur: tp,
  duration: ep,
  end: Jl,
  enhance: T1,
  expression: g1,
  fadeInTime: Kf,
  fadeOutTime: Hf,
  fadeTime: qf,
  fanchor: Af,
  fft: Ll,
  fm: xl,
  fmattack: Sl,
  fmdecay: _l,
  fmenv: wl,
  fmh: Fl,
  fmi: El,
  fmrelease: Vl,
  fmsustain: kl,
  fmvelocity: Il,
  fmwave: Bl,
  frameRate: O1,
  frames: z1,
  freeze: B1,
  freq: Yf,
  fshift: A1,
  fshiftnote: b1,
  fshiftphase: M1,
  ftype: yf,
  gain: Ml,
  gat: ch,
  gate: oh,
  getControlName: ju,
  harmonic: Ah,
  hbrick: X1,
  hcutoff: Ff,
  hold: zl,
  hours: j1,
  hp: xf,
  hpa: K0,
  hpattack: H0,
  hpd: tf,
  hpdecay: ef,
  hpe: O0,
  hpenv: W0,
  hpf: Ef,
  hpq: Sf,
  hpr: df,
  hprelease: pf,
  hps: of,
  hpsustain: af,
  hresonance: wf,
  imag: I1,
  ir: Kh,
  irbegin: Uh,
  iresponse: Yh,
  irspeed: Jh,
  isControlName: fl,
  kcutoff: P1,
  krush: v1,
  label: dh,
  lbrick: W1,
  legato: Q1,
  leslie: lh,
  lfo: ap,
  lock: Xf,
  loop: Ul,
  loopBegin: Ql,
  loopEnd: t0,
  loopb: e0,
  loope: n0,
  lp: G0,
  lpa: q0,
  lpattack: $0,
  lpd: Q0,
  lpdecay: U0,
  lpe: X0,
  lpenv: Z0,
  lpf: R0,
  lpq: _f,
  lpr: hf,
  lprelease: ff,
  lps: uf,
  lpsustain: sf,
  lrate: fh,
  lsize: hh,
  midibend: Ip,
  midichan: Mp,
  midicmd: Pp,
  midimap: Cp,
  midiport: vp,
  miditouch: Tp,
  minutes: $1,
  mode: Xh,
  mtranspose: gh,
  n: gl,
  noise: vf,
  note: yl,
  nrpnn: wp,
  nrpv: Sp,
  nudge: Ch,
  octave: vh,
  octaveR: Mh,
  octaves: Zh,
  octer: D1,
  octersub: F1,
  octersubsub: E1,
  offset: Gh,
  orbit: Ph,
  overgain: Dh,
  overshape: Fh,
  pan: Eh,
  panchor: ah,
  panorient: Bh,
  panspan: xh,
  pansplay: wh,
  panwidth: Sh,
  partials: N1,
  patt: Uf,
  pattack: Jf,
  pcurve: uh,
  pdec: eh,
  pdecay: Qf,
  penv: sh,
  ph: F0,
  phasdp: V0,
  phaser: E0,
  phasercenter: S0,
  phaserdepth: _0,
  phaserrate: D0,
  phasersweep: x0,
  phc: B0,
  phd: k0,
  phs: w0,
  pitchJump: sp,
  pitchJumpTime: up,
  polyTouch: Np,
  postgain: Cl,
  prel: ih,
  prelease: rh,
  progNum: Bp,
  psus: nh,
  psustain: th,
  pw: C0,
  pwrate: v0,
  pwsweep: P0,
  rate: _h,
  rdim: $h,
  real: V1,
  registerControl: w,
  rel: Ol,
  release: Wl,
  repeatTime: op,
  resonance: Bf,
  rfade: Hh,
  ring: x1,
  ringdf: S1,
  ringf: w1,
  rlp: zh,
  room: Wh,
  roomdim: jh,
  roomfade: qh,
  roomlp: Oh,
  roomsize: Qh,
  rsize: n1,
  s: hl,
  scram: G1,
  scrub: Rp,
  seconds: q1,
  semitone: Vh,
  shape: r1,
  size: e1,
  slide: kh,
  smear: R1,
  songPtr: H1,
  sound: pl,
  source: dl,
  speed: Ou,
  spread: jf,
  squiz: p1,
  src: ml,
  stepsPerOctave: bh,
  stretch: f1,
  sus: Xl,
  sustain: Zl,
  sustainpedal: y1,
  sysex: _p,
  sysexdata: Vp,
  sysexid: kp,
  sz: t1,
  tremolo: s0,
  tremolodepth: a0,
  tremolophase: c0,
  tremoloshape: l0,
  tremoloskew: o0,
  tremolosync: u0,
  triode: C1,
  tsdelay: k1,
  uid: K1,
  unison: zf,
  unit: h1,
  v: Cf,
  val: Y1,
  velocity: bl,
  vib: bf,
  vibmod: Pf,
  vibrato: Mf,
  vmod: Df,
  voice: Ih,
  vowel: d1,
  waveloss: m1,
  xsdelay: _1,
  zcrush: fp,
  zdelay: hp,
  zmod: lp,
  znoise: cp,
  zrand: np,
  zzfx: pp
}, Symbol.toStringTag, { value: "Module" })), rM = function(e, t) {
  const [n, r] = e, [i, s] = t, [u, a] = Iu(r, i);
  return [
    [r, n - r],
    [qi((o, f) => o.concat(f), u, s), a]
  ];
}, iM = function(e, t) {
  const [n, r] = e, [i, s] = t, [u, a] = Iu(n, s);
  return [
    [n, r - n],
    [qi((f, h) => f.concat(h), i, u), a]
  ];
}, Gp = function(e, t) {
  const [n, r] = e;
  return Math.min(n, r) <= 1 ? [e, t] : Gp(...n > r ? rM(e, t) : iM(e, t));
}, $u = function(e, t) {
  const n = e < 0, r = Math.abs(e), i = t - r, s = Array(r).fill([1]), u = Array(i).fill([0]), a = Gp([r, i], [s, u]), o = bn(a[1][0]).concat(bn(a[1][1]));
  return n ? o.map((f) => 1 - f) : o;
}, Ji = function(e, t, n) {
  const r = $u(e, t);
  return n ? xc(r, -n) : r;
}, sM = N("euclid", function(e, t, n) {
  return n.struct(Ji(e, t, 0));
}), uM = N("e", function(e, t) {
  Array.isArray(e) || (e = [e]);
  const [n, r = n, i = 0] = e;
  return t.struct(Ji(n, r, i));
}), { euclidrot: aM, euclidRot: oM } = N(["euclidrot", "euclidRot"], function(e, t, n, r) {
  return r.struct(Ji(e, t, n));
}), Zp = function(e, t, n, r) {
  if (e < 1)
    return Se;
  const s = Ji(e, t, 0).join("").split("1").slice(1).map((u) => [u.length + 1, !0]);
  return r.struct(Xu(...s)).late(j(n).div(t));
}, cM = N(["euclidLegato"], function(e, t, n) {
  return Zp(e, t, 0, n);
}), lM = N(["euclidLegatoRot"], function(e, t, n, r) {
  return Zp(e, t, n, r);
}), { euclidish: fM, eish: hM } = N(["euclidish", "eish"], function(e, t, n, r) {
  const i = Wu($u(e, t), new Array(e).fill(1), n);
  return r.struct(i).setSteps(t);
});
function Xp(e, t, n = 0.05, r = 0.1, i = 0.1, s = globalThis.setInterval, u = globalThis.clearInterval, a = !0) {
  let o = 0, f = 0, h = 10 ** 4, m = 0.01;
  const p = (S) => n = S(n);
  i = i || r / 2;
  const A = () => {
    const S = e(), x = S + r + i;
    for (f === 0 && (f = S + m); f < x; )
      f = a ? Math.round(f * h) / h : f, t(f, n, o, S), f += n, o++;
  };
  let M;
  const C = () => {
    F(), A(), M = s(A, r * 1e3);
  }, F = () => {
    M !== void 0 && u(M), M = void 0;
  };
  return { setDuration: p, start: C, stop: () => {
    o = 0, f = 0, F();
  }, pause: () => F(), duration: n, interval: r, getPhase: () => f, minLatency: m };
}
function pM(e) {
  return new $((t) => [new je(void 0, t.span, e)]);
}
const Vt = (e) => {
  const t = (n) => [new je(void 0, n.span, e(n.span.begin))];
  return new $(t);
}, li = Vt((e) => e % 1), qu = li.toBipolar(), Ui = Vt((e) => 1 - e % 1), Hu = Ui.toBipolar(), Ku = Vt((e) => Math.sin(Math.PI * 2 * e)), Wp = Ku.fromBipolar(), dM = Wp._early(j(1).div(4)), mM = Ku._early(j(1).div(4)), Op = Vt((e) => Math.floor(e * 2 % 2)), gM = Op.toBipolar(), yM = ot(li, Ui), AM = ot(qu, Hu), bM = ot(Ui, li), MM = ot(Hu, qu), Yu = Vt(hr);
let Ju = 0, Uu = 0;
typeof window < "u" && document.addEventListener("mousemove", (e) => {
  Ju = e.clientY / document.body.clientHeight, Uu = e.clientX / document.body.clientWidth;
});
const CM = Vt(() => Ju), vM = Vt(() => Ju), PM = Vt(() => Uu), DM = Vt(() => Uu), zp = (e) => {
  const t = e << 13 ^ e, n = t >> 17 ^ t;
  return n << 5 ^ n;
}, FM = (e) => e - Math.trunc(e), jp = (e) => zp(Math.trunc(FM(e / 300) * 536870912)), $p = (e) => e % 536870912 / 536870912, ri = (e) => Math.abs($p(jp(e))), EM = (e, t) => {
  const n = [];
  for (let r = 0; r < t; ++r)
    n.push($p(e)), e = zp(e);
  return n;
}, xM = (e, t) => EM(jp(e), t), qp = (e) => li.range(0, e).round().segment(e), wM = (e) => {
  const t = q(e).log2(0).floor().add(1);
  return Hp(e, t);
}, Hp = (e, t = 16) => {
  t = q(t);
  const n = qp(t).mul(-1).add(t.sub(1));
  return q(e).segment(t).brshift(n).band(Je(1));
}, Kp = (e) => Vt((t) => {
  const r = xM(t.floor().add(0.5), e).map((s, u) => [s, u]).sort((s, u) => (s[0] > u[0]) - (s[0] < u[0])).map((s) => s[1]), i = t.cyclePos().mul(e).floor() % e;
  return r[i];
})._segment(e), Yp = (e, t, n) => {
  const r = [...Array(t).keys()].map((i) => n.zoom(j(i).div(t), j(i + 1).div(t)));
  return e.fmap((i) => r[i].repeatCycles(t)._fast(t)).innerJoin();
}, SM = N("shuffle", (e, t) => Yp(Kp(e), e, t)), BM = N("scramble", (e, t) => Yp(ea(e)._segment(e), e, t)), ht = Vt(ri), _M = ht.toBipolar(), Qu = (e) => ht.fmap((t) => t < e), kM = (e) => q(e).fmap(Qu).innerJoin(), VM = Qu(0.5), ea = (e) => ht.fmap((t) => Math.trunc(t * e)), IM = (e) => q(e).fmap(ea).innerJoin(), ta = (e, t) => (t = t.map(q), t.length == 0 ? Se : e.range(0, t.length).fmap((n) => {
  const r = Math.min(Math.max(Math.floor(n), 0), t.length - 1);
  return t[r];
})), Qi = (e, t) => ta(e, t).outerJoin(), es = (e, t) => ta(e, t).innerJoin(), Jp = (...e) => Qi(ht, e), TM = (...e) => es(ht, e), NM = Jp;
$.prototype.choose = function(...e) {
  return Qi(this, e);
};
$.prototype.choose2 = function(...e) {
  return Qi(this.fromBipolar(), e);
};
const Up = (...e) => es(ht.segment(1), e), LM = Up, Qp = function(e, ...t) {
  const n = t.map((a) => q(a[0])), r = [];
  let i = Je(0);
  for (const a of t)
    i = i.add(a[1]), r.push(i);
  const s = Zc(r), u = function(a) {
    const o = i.mul(a);
    return s.fmap((f) => (h) => n[f.findIndex((m) => m > h, f)]).appLeft(o);
  };
  return e.bind(u);
}, RM = (...e) => Qp(...e).outerJoin(), GM = (...e) => RM(ht, ...e), ed = (...e) => Qp(ht.segment(1), ...e).innerJoin(), ZM = ed;
function XM(e) {
  let t = Math.floor(e), n = t + 1;
  const r = (u) => 6 * u ** 5 - 15 * u ** 4 + 10 * u ** 3;
  return ((u) => (a) => (o) => a + r(u) * (o - a))(e - t)(ri(t))(ri(n));
}
const td = (e) => e.fmap(XM);
function WM(e) {
  const t = Math.floor(e), n = t + 1, r = ri(t), i = ri(n) + r, s = (e - t) / (n - t);
  return ((a, o, f) => a + (o - a) * f)(r, i, s) / 2;
}
const nd = (e) => e.fmap(WM), OM = td(Yu.fmap((e) => Number(e))), zM = nd(Yu.fmap((e) => Number(e))), jM = N(
  "degradeByWith",
  (e, t, n) => n.fmap((r) => (i) => r).appLeft(e.filterValues((r) => r > t)),
  !0,
  !0
), $M = N(
  "degradeBy",
  function(e, t) {
    return t._degradeByWith(ht, e);
  },
  !0,
  !0
), qM = N("degrade", (e) => e._degradeBy(0.5), !0, !0), HM = N(
  "undegradeBy",
  function(e, t) {
    return t._degradeByWith(
      ht.fmap((n) => 1 - n),
      e
    );
  },
  !0,
  !0
), KM = N("undegrade", (e) => e._undegradeBy(0.5), !0, !0), YM = N("sometimesBy", function(e, t, n) {
  return q(e).fmap((r) => Le(n._degradeBy(r), t(n._undegradeBy(1 - r)))).innerJoin();
}), JM = N("sometimes", function(e, t) {
  return t._sometimesBy(0.5, e);
}), UM = N("someCyclesBy", function(e, t, n) {
  return q(e).fmap(
    (r) => Le(
      n._degradeByWith(ht._segment(1), r),
      t(n._degradeByWith(ht.fmap((i) => 1 - i)._segment(1), 1 - r))
    )
  ).innerJoin();
}), QM = N("someCycles", function(e, t) {
  return t._someCyclesBy(0.5, e);
}), eC = N("often", function(e, t) {
  return t.sometimesBy(0.75, e);
}), tC = N("rarely", function(e, t) {
  return t.sometimesBy(0.25, e);
}), nC = N("almostNever", function(e, t) {
  return t.sometimesBy(0.1, e);
}), rC = N("almostAlways", function(e, t) {
  return t.sometimesBy(0.9, e);
}), iC = N("never", function(e, t) {
  return t;
}), sC = N("always", function(e, t) {
  return e(t);
});
function na(e) {
  Array.isArray(e) === !1 && (e = [e]);
  const t = Lc();
  return e.every((n) => {
    const r = Nc.get(n) ?? n;
    return t[r];
  });
}
const uC = N("whenKey", function(e, t, n) {
  return n.when(na(e), t);
}), aC = N("keyDown", function(e) {
  return e.fmap(na);
}), an = function(e, t, n = !0) {
  const r = Array.isArray(e), i = Object.keys(e).length;
  return e = Ic(e, q), i === 0 ? Se : t.fmap((s) => {
    let u = s;
    return r && (u = n ? Math.round(u) % i : Hi(Math.round(u), 0, e.length - 1)), e[u];
  });
}, rd = function(e, t) {
  return Array.isArray(t) && ([t, e] = [e, t]), oC(e, t);
}, oC = N("pick", function(e, t) {
  return an(e, t, !1).innerJoin();
}), id = N("pickmod", function(e, t) {
  return an(e, t, !0).innerJoin();
}), cC = N("pickF", function(e, t, n) {
  return n.apply(rd(e, t));
}), lC = N("pickmodF", function(e, t, n) {
  return n.apply(id(e, t));
}), fC = N("pickOut", function(e, t) {
  return an(e, t, !1).outerJoin();
}), hC = N("pickmodOut", function(e, t) {
  return an(e, t, !0).outerJoin();
}), pC = N("pickRestart", function(e, t) {
  return an(e, t, !1).restartJoin();
}), dC = N("pickmodRestart", function(e, t) {
  return an(e, t, !0).restartJoin();
}), mC = N("pickReset", function(e, t) {
  return an(e, t, !1).resetJoin();
}), gC = N("pickmodReset", function(e, t) {
  return an(e, t, !0).resetJoin();
}), { inhabit: yC, pickSqueeze: AC } = N(["inhabit", "pickSqueeze"], function(e, t) {
  return an(e, t, !1).squeezeJoin();
}), { inhabitmod: bC, pickmodSqueeze: MC } = N(["inhabitmod", "pickmodSqueeze"], function(e, t) {
  return an(e, t, !0).squeezeJoin();
}), CC = (e, t) => (t = t.map(q), t.length == 0 ? Se : e.fmap((n) => {
  const r = kt(Math.round(n), t.length);
  return t[r];
}).squeezeJoin());
let Ii;
try {
  Ii = window?.speechSynthesis;
} catch {
  console.warn("cannot use window: not in browser?");
}
let fo = Ii?.getVoices();
function vC(e, t, n) {
  Ii.cancel();
  const r = new SpeechSynthesisUtterance(e);
  r.lang = t, fo = Ii.getVoices();
  const i = fo.filter((s) => s.lang.includes(t));
  typeof n == "number" ? r.voice = i[n % i.length] : typeof n == "string" && (r.voice = i.find((s) => s.name === s)), speechSynthesis.speak(r);
}
const PC = N("speak", function(e, t, n) {
  return n.onTrigger((r) => {
    vC(r.value, e, t);
  });
}), sd = {}, Ti = async (...e) => {
  const t = await Promise.allSettled(e), n = t.filter((r) => r.status === "fulfilled").map((r) => r.value);
  return t.forEach((r, i) => {
    r.status === "rejected" && console.warn(`evalScope: module with index ${i} could not be loaded:`, r.reason);
  }), n.forEach((r) => {
    Object.entries(r).forEach(([i, s]) => {
      globalThis[i] = s, sd[i] = s;
    });
  }), n;
};
function DC(e, t = {}) {
  const { wrapExpression: n = !0, wrapAsync: r = !0 } = t;
  n && (e = `{${e}}`), r && (e = `(async ()=>${e})()`);
  const i = `"use strict";return (${e})`;
  return Function(i)();
}
const ud = async (e, t, n) => {
  let r = {};
  if (t) {
    const u = t(e, n);
    e = u.output, r = u;
  }
  return { mode: "javascript", pattern: await DC(e, { wrapExpression: !!t }), meta: r };
};
class FC {
  constructor({ onTrigger: t, onToggle: n, getTime: r }) {
    this.started = !1, this.cps = 0.5, this.getTime = r, this.time_at_last_tick_message = 0, this.collator = new Tc({ getTargetClockTime: r }), this.onToggle = n, this.latency = 0.1, this.cycle = 0, this.id = Math.round(Date.now() * Math.random()), this.worker = new SharedWorker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/clockworker-ZDiUtESR.js", import.meta.url).href,
      import.meta.url
    )), this.worker.port.start(), this.channel = new BroadcastChannel("strudeltick");
    const i = (u) => {
      const { cps: a, begin: o, end: f, cycle: h, time: m } = u;
      this.cps = a, this.cycle = h;
      const p = this.collator.calculateOffset(m) + m;
      s(o, f, p), this.time_at_last_tick_message = p;
    }, s = (u, a, o) => {
      if (this.started === !1)
        return;
      this.pattern.queryArc(u, a, { _cps: this.cps }).forEach((h) => {
        if (h.hasOnset()) {
          const p = uu(h.whole.begin - this.cycle, this.cps) + o + this.latency, A = uu(h.duration, this.cps);
          t?.(h, 0, A, this.cps, p);
        }
      });
    };
    this.channel.onmessage = (u) => {
      if (!this.started)
        return;
      const { payload: a, type: o } = u.data;
      switch (o) {
        case "tick":
          i(a);
      }
    };
  }
  sendMessage(t, n) {
    this.worker.port.postMessage({ type: t, payload: n, id: this.id });
  }
  now() {
    const t = (this.getTime() - this.time_at_last_tick_message) * this.cps;
    return this.cycle + t;
  }
  setCps(t = 1) {
    this.sendMessage("cpschange", { cps: t });
  }
  setCycle(t) {
    this.sendMessage("setcycle", { cycle: t });
  }
  setStarted(t) {
    this.sendMessage("toggle", { started: t }), this.started = t, this.onToggle?.(t);
  }
  start() {
    Ue("[cyclist] start"), this.setStarted(!0);
  }
  stop() {
    Ue("[cyclist] stop"), this.collator.reset(), this.setStarted(!1);
  }
  setPattern(t, n = !1) {
    this.pattern = t, n && !this.started && this.start();
  }
  log(t, n, r) {
    const i = r.filter((s) => s.hasOnset());
    console.log(`${t.toFixed(4)} - ${n.toFixed(4)} ${Array(i.length).fill("I").join("")}`);
  }
}
class ad {
  constructor({
    interval: t,
    onTrigger: n,
    onToggle: r,
    onError: i,
    getTime: s,
    latency: u = 0.1,
    setInterval: a,
    clearInterval: o,
    beforeStart: f
  }) {
    this.started = !1, this.beforeStart = f, this.cps = 0.5, this.num_ticks_since_cps_change = 0, this.lastTick = 0, this.lastBegin = 0, this.lastEnd = 0, this.getTime = s, this.num_cycles_at_cps_change = 0, this.seconds_at_cps_change, this.onToggle = r, this.latency = u, this.clock = Xp(
      s,
      // called slightly before each cycle
      (h, m, p, A) => {
        this.num_ticks_since_cps_change === 0 && (this.num_cycles_at_cps_change = this.lastEnd, this.seconds_at_cps_change = h), this.num_ticks_since_cps_change++;
        const C = this.num_ticks_since_cps_change * m * this.cps;
        try {
          const F = this.lastEnd;
          this.lastBegin = F;
          const _ = this.num_cycles_at_cps_change + C;
          if (this.lastEnd = _, this.lastTick = h, h < A) {
            console.log("skip query: too late");
            return;
          }
          this.pattern.queryArc(F, _, { _cps: this.cps }).forEach((L) => {
            if (L.hasOnset()) {
              const S = (L.whole.begin - this.num_cycles_at_cps_change) / this.cps + this.seconds_at_cps_change + u, x = L.duration / this.cps, B = S - h;
              n?.(L, B, x, this.cps, S), L.value.cps !== void 0 && this.cps != L.value.cps && (this.cps = L.value.cps, this.num_ticks_since_cps_change = 0);
            }
          });
        } catch (F) {
          Su(F), i?.(F);
        }
      },
      t,
      // duration of each cycle
      0.1,
      0.1,
      a,
      o
    );
  }
  now() {
    if (!this.started)
      return 0;
    const t = this.getTime() - this.lastTick - this.clock.duration;
    return this.lastBegin + t * this.cps;
  }
  setStarted(t) {
    this.started = t, this.onToggle?.(t);
  }
  async start() {
    if (await this.beforeStart?.(), this.num_ticks_since_cps_change = 0, this.num_cycles_at_cps_change = 0, !this.pattern)
      throw new Error("Scheduler: no pattern set! call .setPattern first.");
    Ue("[cyclist] start"), this.clock.start(), this.setStarted(!0);
  }
  pause() {
    Ue("[cyclist] pause"), this.clock.pause(), this.setStarted(!1);
  }
  stop() {
    Ue("[cyclist] stop"), this.clock.stop(), this.lastEnd = 0, this.setStarted(!1);
  }
  async setPattern(t, n = !1) {
    this.pattern = t, n && !this.started && await this.start();
  }
  setCps(t = 0.5) {
    this.cps !== t && (this.cps = t, this.num_ticks_since_cps_change = 0);
  }
  log(t, n, r) {
    const i = r.filter((s) => s.hasOnset());
    console.log(`${t.toFixed(4)} - ${n.toFixed(4)} ${Array(i.length).fill("I").join("")}`);
  }
}
let fu;
function hu() {
  if (!fu)
    throw new Error("no time set! use setTime to define a time source");
  return fu();
}
function Ni(e) {
  fu = e;
}
function EC({
  defaultOutput: e,
  onEvalError: t,
  beforeEval: n,
  beforeStart: r,
  afterEval: i,
  getTime: s,
  transpiler: u,
  onToggle: a,
  editPattern: o,
  onUpdateState: f,
  sync: h = !1,
  setInterval: m,
  clearInterval: p,
  id: A,
  mondo: M = !1
}) {
  const C = {
    schedulerError: void 0,
    evalError: void 0,
    code: "// LOADING",
    activeCode: "// LOADING",
    pattern: void 0,
    miniLocations: [],
    widgets: [],
    pending: !1,
    started: !1
  }, F = {
    id: A
  }, _ = (oe) => {
    Object.assign(C, oe), C.isDirty = C.code !== C.activeCode, C.error = C.evalError || C.schedulerError, f?.(C);
  }, k = {
    onTrigger: od({ defaultOutput: e, getTime: s }),
    getTime: s,
    onToggle: (oe) => {
      _({ started: oe }), a?.(oe);
    },
    setInterval: m,
    clearInterval: p,
    beforeStart: r
  }, L = h && typeof SharedWorker < "u" ? new FC(k) : new ad(k);
  let S = {}, x = 0, B;
  const V = function() {
    return S = {}, x = 0, B = void 0, Se;
  }, T = async (oe, W = !0) => (oe = o?.(oe) || oe, await L.setPattern(oe, W), oe);
  Ni(() => L.now());
  const H = () => L.stop(), X = () => L.start(), U = () => L.pause(), O = () => L.toggle(), z = (oe) => L.setCps(oe), te = (oe) => L.setCps(oe / 60);
  let me = [];
  const pe = function(oe) {
    return me.push(oe), Se;
  }, le = function(oe) {
    return B = oe, Se;
  }, ie = () => {
    $.prototype.p = function(W) {
      return typeof W == "string" && (W.startsWith("_") || W.endsWith("_")) ? Se : (W === "$" && (W = `$${x}`, x++), S[W] = this, this);
    }, $.prototype.q = function(W) {
      return Se;
    };
    try {
      for (let W = 1; W < 10; ++W)
        Object.defineProperty($.prototype, `d${W}`, {
          get() {
            return this.p(W);
          },
          configurable: !0
        }), Object.defineProperty($.prototype, `p${W}`, {
          get() {
            return this.p(W);
          },
          configurable: !0
        }), $.prototype[`q${W}`] = Se;
    } catch (W) {
      console.warn("injectPatternMethods: error:", W);
    }
    const oe = N("cpm", function(W, $e) {
      return $e._fast(W / 60 / L.cps);
    });
    return Ti({
      all: pe,
      each: le,
      hush: V,
      cpm: oe,
      setCps: z,
      setcps: z,
      setCpm: te,
      setcpm: te
    });
  };
  return { scheduler: L, evaluate: async (oe, W = !0, $e = !0) => {
    if (!oe)
      throw new Error("no code to evaluate");
    try {
      _({ code: oe, pending: !0 }), await ie(), Ni(() => L.now()), await n?.({ code: oe }), me = [], $e && V(), M && (oe = `mondolang\`${oe}\``);
      let { pattern: xe, meta: tt } = await ud(oe, u, F);
      if (Object.keys(S).length) {
        let ge = Object.values(S);
        B && (ge = ge.map((qe) => B(qe))), xe = Le(...ge);
      } else B && (xe = B(xe));
      if (me.length)
        for (let ge in me)
          xe = me[ge](xe);
      if (!Nu(xe)) {
        const ge = `got "${typeof evaluated}" instead of pattern`;
        throw new Error(ge + (typeof evaluated == "function" ? ", did you forget to call a function?" : "."));
      }
      return Ue("[eval] code updated"), xe = await T(xe, W), _({
        miniLocations: tt?.miniLocations || [],
        widgets: tt?.widgets || [],
        activeCode: oe,
        pattern: xe,
        evalError: void 0,
        schedulerError: void 0,
        pending: !1
      }), i?.({ code: oe, pattern: xe, meta: tt }), xe;
    } catch (xe) {
      Ue(`[eval] error: ${xe.message}`, "error"), console.error(xe), _({ evalError: xe, pending: !1 }), t?.(xe);
    }
  }, start: X, stop: H, pause: U, setCps: z, setPattern: T, setCode: (oe) => _({ code: oe }), toggle: O, state: C };
}
const od = ({ getTime: e, defaultOutput: t }) => async (n, r, i, s, u) => {
  try {
    (!n.context.onTrigger || !n.context.dominantTrigger) && await t(n, r, i, s, u), n.context.onTrigger && await n.context.onTrigger(n, e(), s, u);
  } catch (a) {
    Su(a, "getTrigger");
  }
}, xC = function(e, t = {}) {
  const n = document.getElementById("code"), r = "background-image:url(" + e + ");background-size:contain;";
  n.style = r;
  const { className: i } = n, s = (o, f) => {
    ({
      style: () => n.style = r + ";" + f,
      className: () => n.className = f + " " + i
    })[o]();
  }, u = Object.entries(t).filter(([o, f]) => typeof f == "function");
  Object.entries(t).filter(([o, f]) => typeof f == "string").forEach(([o, f]) => s(o, f)), u.length;
}, wC = () => {
  const e = document.getElementById("code");
  e && (e.style = "");
};
Ue("🌀 @strudel/core loaded 🌀");
globalThis._strudelLoaded && console.warn(
  `@strudel/core was loaded more than once...
This might happen when you have multiple versions of strudel installed. 
Please check with "npm ls @strudel/core".`
);
globalThis._strudelLoaded = !0;
const cd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClockCollator: Tc,
  Cyclist: ad,
  Fraction: j,
  Hap: je,
  Pattern: $,
  State: gr,
  TimeSpan: He,
  __chooseWith: ta,
  _brandBy: Qu,
  _fitslice: Hc,
  _irand: ea,
  _keyDown: na,
  _match: Kc,
  _mod: kt,
  _morph: Wu,
  _polymeterListSteps: Jc,
  _retime: cu,
  _slices: lu,
  accelerate: Al,
  activeLabel: ph,
  ad: yp,
  add: T3,
  adsr: gp,
  almostAlways: rC,
  almostNever: nC,
  always: sC,
  amp: vl,
  analyze: Nl,
  anchor: Rh,
  and: eA,
  apply: BA,
  ar: bp,
  arp: d3,
  arpWith: p3,
  arrange: M3,
  as: Lp,
  att: Dl,
  attack: Pl,
  averageArray: Dc,
  backgroundImage: xC,
  band: X3,
  bandf: jl,
  bandq: Hl,
  bank: Tl,
  base64ToUnicode: Vc,
  bbexpr: g0,
  bbst: A0,
  beat: Qb,
  begin: Yl,
  berlin: zM,
  berlinWith: nd,
  binary: wM,
  binaryN: Hp,
  bind: E3,
  binshift: Z1,
  bite: NA,
  bjork: $u,
  blshift: z3,
  bor: W3,
  bp: ql,
  bpa: J0,
  bpattack: Y0,
  bpd: rf,
  bpdecay: nf,
  bpe: j0,
  bpenv: z0,
  bpf: $l,
  bpq: Kl,
  bpr: gf,
  bprelease: mf,
  bps: lf,
  bpsustain: cf,
  brak: $A,
  brand: VM,
  brandBy: kM,
  brshift: j3,
  bxor: O3,
  bypass: Mb,
  byteBeatExpression: m0,
  byteBeatStartTime: y0,
  calculateSteps: l3,
  cat: zc,
  ccn: Fp,
  ccv: Ep,
  ceil: sA,
  ch: M0,
  channel: I0,
  channels: b0,
  choose: Jp,
  chooseCycles: Up,
  chooseIn: TM,
  chooseInWith: es,
  chooseOut: NM,
  chooseWith: Qi,
  chop: Ob,
  chord: Th,
  chunk: cb,
  chunkBack: hb,
  chunkBackInto: bb,
  chunkInto: yb,
  chunkback: pb,
  chunkbackinto: Ab,
  chunkinto: gb,
  clamp: Hi,
  cleanupUi: wC,
  clip: U1,
  coarse: i0,
  code2hash: i3,
  color: dp,
  colour: mp,
  comb: L1,
  compose: $y,
  compress: hA,
  compressSpan: pA,
  compressor: u1,
  compressorAttack: c1,
  compressorKnee: a1,
  compressorRatio: o1,
  compressorRelease: l1,
  compressspan: dA,
  constant: qy,
  contract: rl,
  control: Dp,
  controls: nM,
  cosine: dM,
  cosine2: mM,
  cpm: _A,
  cps: J1,
  createClock: Xp,
  createParam: Yi,
  createParams: zu,
  crush: r0,
  ctf: L0,
  ctlNum: xp,
  ctranspose: yh,
  curry: Ae,
  curve: rp,
  cut: T0,
  cutoff: N0,
  cycleToSeconds: uu,
  dec: Gl,
  decay: Rl,
  degrade: qM,
  degradeBy: $M,
  degradeByWith: jM,
  degree: mh,
  delay: Vf,
  delayfb: Tf,
  delayfeedback: If,
  delaysync: Zf,
  delayt: Rf,
  delaytime: Lf,
  deltaSlide: ip,
  det: Of,
  detune: Wf,
  dfb: Nf,
  dict: Lh,
  dictionary: Nh,
  dist: s1,
  distort: i1,
  div: R3,
  djf: kf,
  drawLine: Rc,
  drive: d0,
  drop: el,
  dry: $f,
  ds: Ap,
  dt: Gf,
  duck: f0,
  duckattack: p0,
  duckdepth: h0,
  dur: tp,
  duration: ep,
  e: uM,
  early: kA,
  echo: rb,
  echoWith: QA,
  echowith: eb,
  eish: hM,
  end: Jl,
  enhance: T1,
  eq: Y3,
  eqt: J3,
  errorLogger: Su,
  euclid: sM,
  euclidLegato: cM,
  euclidLegatoRot: lM,
  euclidRot: oM,
  euclidish: fM,
  euclidrot: aM,
  evalScope: Ti,
  evaluate: ud,
  every: SA,
  expand: nl,
  expression: g1,
  extend: tl,
  fadeInTime: Kf,
  fadeOutTime: Hf,
  fadeTime: qf,
  fanchor: Af,
  fast: CA,
  fastChunk: mb,
  fastGap: mA,
  fastcat: ot,
  fastchunk: db,
  fastgap: gA,
  fft: Ll,
  filter: Fb,
  filterWhen: Eb,
  firstOf: wA,
  fit: Hb,
  flatten: bn,
  floor: iA,
  fm: xl,
  fmattack: Sl,
  fmdecay: _l,
  fmenv: wl,
  fmh: Fl,
  fmi: El,
  fmrelease: Vl,
  fmsustain: kl,
  fmvelocity: Il,
  fmwave: Bl,
  focus: yA,
  focusSpan: AA,
  focusspan: bA,
  fractionalArgs: Hy,
  frameRate: O1,
  frames: z1,
  freeze: B1,
  freq: Yf,
  freqToMidi: Bu,
  fromBipolar: aA,
  fshift: A1,
  fshiftnote: b1,
  fshiftphase: M1,
  ftype: yf,
  func: nA,
  gain: Ml,
  gap: vr,
  gat: ch,
  gate: oh,
  getControlName: ju,
  getCurrentKeyboardState: Lc,
  getEventOffsetMs: Xy,
  getFreq: Pc,
  getFrequency: Ec,
  getPerformanceTimeSeconds: u3,
  getPlayableNoteValue: jy,
  getSoundIndex: zy,
  getTime: hu,
  getTrigger: od,
  grow: wb,
  gt: q3,
  gte: K3,
  harmonic: Ah,
  hash2code: s3,
  hbrick: X1,
  hcutoff: Ff,
  hold: zl,
  hours: j1,
  hp: xf,
  hpa: K0,
  hpattack: H0,
  hpd: tf,
  hpdecay: ef,
  hpe: O0,
  hpenv: W0,
  hpf: Ef,
  hpq: Sf,
  hpr: df,
  hprelease: pf,
  hps: of,
  hpsustain: af,
  hresonance: wf,
  hsl: Db,
  hsla: Pb,
  hurry: vA,
  id: hr,
  imag: I1,
  inhabit: yC,
  inhabitmod: bC,
  innerBind: x3,
  inside: FA,
  inv: OA,
  invert: WA,
  ir: Kh,
  irand: IM,
  irbegin: Uh,
  iresponse: Yh,
  irspeed: Jh,
  isControlName: fl,
  isNote: Un,
  isNoteWithOctave: Ly,
  isPattern: Nu,
  isaw: Ui,
  isaw2: Hu,
  iter: sb,
  iterBack: ub,
  iterback: ab,
  itri: bM,
  itri2: MM,
  jux: UA,
  juxBy: YA,
  juxby: JA,
  kcutoff: P1,
  keep: V3,
  keepif: I3,
  keyAlias: Nc,
  keyDown: aC,
  krush: v1,
  label: dh,
  lastOf: xA,
  late: $c,
  lbrick: W1,
  legato: Q1,
  leslie: lh,
  lfo: ap,
  linger: LA,
  listRange: _u,
  lock: Xf,
  logKey: wu,
  logger: Ue,
  loop: Ul,
  loopAt: $b,
  loopAtCps: Kb,
  loopBegin: Ql,
  loopEnd: t0,
  loopat: qb,
  loopatcps: Yb,
  loopb: e0,
  loope: n0,
  lp: G0,
  lpa: q0,
  lpattack: $0,
  lpd: Q0,
  lpdecay: U0,
  lpe: X0,
  lpenv: Z0,
  lpf: R0,
  lpq: _f,
  lpr: hf,
  lprelease: ff,
  lps: uf,
  lpsustain: sf,
  lrate: fh,
  lsize: hh,
  lt: $3,
  lte: H3,
  mapArgs: Vu,
  mask: v3,
  midi2note: Oy,
  midiToFreq: Hn,
  midibend: Ip,
  midichan: Mp,
  midicmd: Pp,
  midimap: Cp,
  midiport: vp,
  miditouch: Tp,
  minutes: $1,
  mod: G3,
  mode: Xh,
  morph: eM,
  mouseX: DM,
  mouseY: vM,
  mousex: PM,
  mousey: CM,
  mtranspose: gh,
  mul: L3,
  n: gl,
  nanFallback: Fc,
  ne: U3,
  net: Q3,
  never: iC,
  noise: vf,
  note: yl,
  noteToMidi: Ln,
  nothing: Dt,
  nrpnn: wp,
  nrpv: Sp,
  nudge: Ch,
  numeralArgs: vt,
  objectMap: Ic,
  octave: vh,
  octaveR: Mh,
  octaves: Zh,
  octer: D1,
  octersub: F1,
  octersubsub: E1,
  off: jA,
  offset: Gh,
  often: eC,
  or: tA,
  orbit: Ph,
  outerBind: w3,
  outside: EA,
  overgain: Dh,
  overshape: Fh,
  pace: Yc,
  pairs: Bc,
  palindrome: KA,
  pan: Eh,
  panchor: ah,
  panorient: Bh,
  panspan: xh,
  pansplay: wh,
  panwidth: Sh,
  parseFractional: Sc,
  parseNumeral: ku,
  partials: N1,
  patt: Uf,
  pattack: Jf,
  pcurve: uh,
  pdec: eh,
  pdecay: Qf,
  penv: sh,
  perlin: OM,
  perlinWith: td,
  ph: F0,
  phasdp: V0,
  phaser: E0,
  phasercenter: S0,
  phaserdepth: _0,
  phaserrate: D0,
  phasersweep: x0,
  phc: B0,
  phd: k0,
  phs: w0,
  pick: rd,
  pickF: cC,
  pickOut: fC,
  pickReset: mC,
  pickRestart: pC,
  pickSqueeze: AC,
  pickmod: id,
  pickmodF: lC,
  pickmodOut: hC,
  pickmodReset: gC,
  pickmodRestart: dC,
  pickmodSqueeze: MC,
  pipe: wc,
  pitchJump: sp,
  pitchJumpTime: up,
  ply: MA,
  pm: A3,
  polyBind: _3,
  polyTouch: Np,
  polymeter: Ki,
  polyrhythm: g3,
  postgain: Cl,
  pow: Z3,
  pr: y3,
  prel: ih,
  prelease: rh,
  press: HA,
  pressBy: qA,
  progNum: Bp,
  psus: nh,
  psustain: th,
  pure: Je,
  pw: C0,
  pwrate: v0,
  pwsweep: P0,
  rand: ht,
  rand2: _M,
  randcat: LM,
  randrun: Kp,
  range: oA,
  range2: lA,
  rangex: cA,
  rarely: tC,
  rate: _h,
  ratio: fA,
  rdim: $h,
  real: V1,
  ref: Jb,
  register: N,
  registerControl: w,
  reify: q,
  rel: Ol,
  release: Wl,
  removeUndefineds: Cr,
  repeatCycles: ob,
  repeatTime: op,
  repl: EC,
  resonance: Bf,
  rev: qc,
  rfade: Hh,
  rib: vb,
  ribbon: Cb,
  ring: x1,
  ringdf: S1,
  ringf: w1,
  rlp: zh,
  room: Wh,
  roomdim: jh,
  roomfade: qh,
  roomlp: Oh,
  roomsize: Qh,
  rotate: xc,
  round: rA,
  rsize: n1,
  run: qp,
  s: hl,
  s_add: Tb,
  s_alt: _b,
  s_cat: Bb,
  s_contract: Gb,
  s_expand: Lb,
  s_extend: Rb,
  s_polymeter: kb,
  s_sub: Nb,
  s_taper: Vb,
  s_taperlist: Ib,
  s_tour: Zb,
  s_zip: Xb,
  saw: li,
  saw2: qu,
  scram: G1,
  scramble: BM,
  scrub: Rp,
  seconds: q1,
  seg: GA,
  segment: RA,
  semitone: Vh,
  seq: jc,
  seqPLoop: C3,
  sequence: qt,
  sequenceP: Zc,
  set: k3,
  setStringParser: Gc,
  setTime: Ni,
  shape: r1,
  shrink: sl,
  shrinklist: il,
  shuffle: SM,
  signal: Vt,
  silence: Se,
  sine: Wp,
  sine2: Ku,
  size: e1,
  slice: cl,
  slide: kh,
  slow: PA,
  slowChunk: fb,
  slowcat: Rn,
  slowcatPrime: Ru,
  slowchunk: lb,
  smear: R1,
  sol2note: t3,
  someCycles: QM,
  someCyclesBy: UM,
  sometimes: JM,
  sometimesBy: YM,
  songPtr: H1,
  sound: pl,
  source: dl,
  sparsity: DA,
  speak: PC,
  speed: Ou,
  splice: jb,
  splitAt: Iu,
  spread: jf,
  square: Op,
  square2: gM,
  squeeze: CC,
  squeezeBind: S3,
  squiz: p1,
  src: ml,
  stack: Le,
  stackBy: b3,
  stackCentre: Oc,
  stackLeft: Xc,
  stackRight: Wc,
  steady: pM,
  stepBind: B3,
  stepalt: Uc,
  stepcat: At,
  steps: Wb,
  stepsPerOctave: bh,
  stretch: f1,
  striate: zb,
  stringifyValues: Tu,
  struct: P3,
  strudelScope: sd,
  stut: ib,
  stutWith: tb,
  stutwith: nb,
  sub: N3,
  superimpose: D3,
  sus: Xl,
  sustain: Zl,
  sustainpedal: y1,
  swing: XA,
  swingBy: ZA,
  sysex: _p,
  sysexdata: Vp,
  sysexid: kp,
  sz: t1,
  take: Qc,
  time: Yu,
  timeCat: Xu,
  timecat: Sb,
  toBipolar: uA,
  tokenizeNote: vc,
  tour: ul,
  tremolo: s0,
  tremolodepth: a0,
  tremolophase: c0,
  tremoloshape: l0,
  tremoloskew: o0,
  tremolosync: u0,
  tri: yM,
  tri2: AM,
  triode: C1,
  tsdelay: k1,
  uid: K1,
  undegrade: KM,
  undegradeBy: HM,
  unicodeToBase64: kc,
  uniq: n3,
  uniqsort: r3,
  uniqsortr: _c,
  unison: zf,
  unit: h1,
  v: Cf,
  val: Y1,
  valueToMidi: Zy,
  velocity: bl,
  vib: bf,
  vibmod: Pf,
  vibrato: Mf,
  vmod: Df,
  voice: Ih,
  vowel: d1,
  waveloss: m1,
  wchoose: GM,
  wchooseCycles: ed,
  when: zA,
  whenKey: uC,
  withValue: F3,
  within: xb,
  wrandcat: ZM,
  xfade: ll,
  xsdelay: _1,
  zcrush: fp,
  zdelay: hp,
  zip: al,
  zipWith: qi,
  zmod: lp,
  znoise: cp,
  zoom: VA,
  zoomArc: IA,
  zoomarc: TA,
  zrand: np,
  zzfx: pp
}, Symbol.toStringTag, { value: "Module" }));
if (typeof DelayNode < "u") {
  class e extends DelayNode {
    constructor(n, r, i, s) {
      super(n), r = Math.abs(r), this.delayTime.value = i;
      const u = n.createGain();
      u.gain.value = Math.min(Math.abs(s), 0.995), this.feedback = u.gain;
      const a = n.createGain();
      return a.gain.value = r, this.delayGain = a, this.connect(u), this.connect(a), u.connect(this), this.connect = (o) => a.connect(o), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(t, n, r) {
    return new e(this, t, n, r);
  };
}
var ra = {};
ra.generateReverb = function(e, t) {
  for (var n = e.audioContext || new AudioContext(), r = n.sampleRate, i = e.numChannels || 2, s = e.decayTime * 1.5, u = Math.round(e.decayTime * r), a = Math.round(s * r), o = Math.round((e.fadeInTime || 0) * r), f = Math.pow(1 / 1e3, 1 / u), h = n.createBuffer(i, a, r), m = 0; m < i; m++) {
    for (var p = h.getChannelData(m), A = 0; A < a; A++)
      p[A] = _C() * Math.pow(f, A);
    for (var A = 0; A < o; A++)
      p[A] *= A / o;
  }
  SC(h, e.lpFreqStart || 0, e.lpFreqEnd || 0, e.decayTime, t);
};
ra.generateGraph = function(e, t, n, r, i) {
  var s = document.createElement("canvas");
  s.width = t, s.height = n;
  var u = s.getContext("2d");
  u.fillStyle = "#000", u.fillRect(0, 0, s.width, s.height), u.fillStyle = "#fff";
  for (var a = t / e.length, o = n / (i - r), f = 0; f < e.length; f++)
    u.fillRect(f * a, n - (e[f] - r) * o, 1, 1);
  return s;
};
var SC = function(e, t, n, r, i) {
  if (t == 0) {
    i(e);
    return;
  }
  var s = BC(e), u = new OfflineAudioContext(e.numberOfChannels, s[0].length, e.sampleRate), a = u.createBufferSource();
  a.buffer = e;
  var o = u.createBiquadFilter();
  t = Math.min(t, e.sampleRate / 2), n = Math.min(n, e.sampleRate / 2), o.type = "lowpass", o.Q.value = 1e-4, o.frequency.setValueAtTime(t, 0), o.frequency.linearRampToValueAtTime(n, r), a.connect(o), o.connect(u.destination), a.start(), u.oncomplete = function(f) {
    i(f.renderedBuffer);
  }, u.startRendering(), window.filterNode = o;
}, BC = function(e) {
  for (var t = [], n = 0; n < e.numberOfChannels; n++)
    t[n] = e.getChannelData(n);
  return t;
}, _C = function() {
  return Math.random() * 2 - 1;
};
let ld = (e) => console.log(e);
function ia(e, t = "cyclist") {
  Pt(`[${t}] error: ${e.message}`);
}
const Pt = (...e) => ld(...e), fd = (e) => {
  ld = e;
}, kC = (e) => {
  if (typeof e != "string")
    return [];
  const [t, n = "", r] = e.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return t ? [t, n, r ? Number(r) : void 0] : [];
}, VC = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, IC = { "#": 1, b: -1, s: 1, f: -1 }, ts = (e, t = 3) => {
  const [n, r, i = t] = kC(e);
  if (!n)
    throw new Error('not a note: "' + e + '"');
  const s = VC[n.toLowerCase()], u = r?.split("").reduce((a, o) => a + IC[o], 0) || 0;
  return (Number(i) + 1) * 12 + s + u;
}, hd = (e) => Math.pow(2, (e - 69) / 12) * 440, Kn = (e, t, n) => Math.min(Math.max(e, t), n), TC = (e) => 12 * Math.log(e / 440) / Math.LN2 + 69, NC = (e, t) => {
  if (typeof e != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: r } = e;
  return typeof n == "number" ? TC(n) : typeof r == "string" ? ts(r) : typeof r == "number" ? r : t;
};
function Mn(e, t = 0, n) {
  return isNaN(Number(e)) ? (!n && Pt(`"${e}" is not a number, falling back to ${t}`, "warning"), t) : e;
}
const pd = (e, t) => (e % t + t) % t, ho = (e, t) => pd(Math.round(Mn(e, 0)), t);
function LC(e, t) {
  return e / t;
}
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(e, t, n = 1, r = 0) {
  const i = Math.floor(Kn(r, 0, 1) * t.length), s = t.sampleRate * e, u = this.createBuffer(t.numberOfChannels, t.length, t.sampleRate);
  for (let a = 0; a < t.numberOfChannels; a++) {
    let o = t.getChannelData(a), f = u.getChannelData(a);
    for (let h = 0; h < s; h++) {
      let m = (i + h * Math.abs(n)) % o.length;
      n < 1 && (m = m * -1), f[h] = o.at(m) || 0;
    }
  }
  return u;
}, AudioContext.prototype.createReverb = function(e, t, n, r, i, s, u) {
  const a = this.createConvolver();
  return a.generate = (o = 2, f = 0.1, h = 15e3, m = 1e3, p, A, M) => {
    a.duration = o, a.fade = f, a.lp = h, a.dim = m, a.ir = p, a.irspeed = A, a.irbegin = M, p ? a.buffer = this.adjustLength(o, p, A, M) : ra.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: o,
        fadeInTime: f,
        lpFreqStart: h,
        lpFreqEnd: m
      },
      (C) => {
        a.buffer = C;
      }
    );
  }, a.generate(e, t, n, r, i, s, u), a;
});
var po = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class e extends GainNode {
    constructor(n, r) {
      if (super(n), !po[r])
        throw new Error("vowel: unknown vowel " + r);
      const { gains: i, qs: s, freqs: u } = po[r], a = n.createGain();
      for (let o = 0; o < 5; o++) {
        const f = n.createGain();
        f.gain.value = i[o];
        const h = n.createBiquadFilter();
        h.type = "bandpass", h.Q.value = s[o], h.frequency.value = u[o], this.connect(h), h.connect(f), f.connect(a);
      }
      return a.gain.value = 8, this.connect = (o) => a.connect(o), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(t) {
    return new e(this, t);
  };
}
const RC = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIGd0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBvPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW8/ITE6KHRoaXMuc3RhcnRlZD1vLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBJdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYT1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYSksZVtzKzFdPS1NYXRoLnNpbihhKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbz0xO3RoaXMuc2l6ZT5vO288PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgdT0wO3U8dGhpcy5fd2lkdGg7dSs9Mil7dmFyIGM9dGhpcy5fd2lkdGgtdS0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj51JjMpPDxjfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG89ZS9yPDwxLGksdSxjPXRoaXMuX2JpdHJldjtpZihvPT09NClmb3IoaT0wLHU9MDtpPGU7aSs9byx1Kyspe2NvbnN0IGQ9Y1t1XTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksZCxyKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZD1jW3VdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxkLHIpfXZhciBhPXRoaXMuX2ludj8tMToxLGg9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bz1lL3I8PDE7dmFyIG09bz4+PjI7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIHA9aSttLGw9aSxmPTA7bDxwO2wrPTIsZis9cil7Y29uc3QgZD1sLHY9ZCttLGc9dittLEk9ZyttLGI9dFtkXSxCPXRbZCsxXSxfPXRbdl0sdz10W3YrMV0sVD10W2ddLFA9dFtnKzFdLHk9dFtJXSxBPXRbSSsxXSx4PWIsVj1CLEY9aFtmXSxNPWEqaFtmKzFdLE89XypGLXcqTSxOPV8qTSt3KkYsWT1oWzIqZl0sTD1hKmhbMipmKzFdLEg9VCpZLVAqTCxVPVQqTCtQKlksSz1oWzMqZl0sWj1hKmhbMypmKzFdLCQ9eSpLLUEqWixHPXkqWitBKkssaj14K0gsaz1WK1Usej14LUgsSj1WLVUsUT1PKyQsRT1OK0csUj1hKihPLSQpLFg9YSooTi1HKSxzdD1qK1EsaXQ9aytFLG90PWotUSxhdD1rLUUsdXQ9eitYLGh0PUotUixjdD16LVgsbHQ9SitSO3RbZF09c3QsdFtkKzFdPWl0LHRbdl09dXQsdFt2KzFdPWh0LHRbZ109b3QsdFtnKzFdPWF0LHRbSV09Y3QsdFtJKzFdPWx0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2UrMV0sYz1vW2Urc10sYT1vW2UrcysxXSxoPWkrYyxtPXUrYSxwPWktYyxsPXUtYTtyW3RdPWgsclt0KzFdPW0sclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLHU9cyoyLGM9cyozLGE9b1tlXSxoPW9bZSsxXSxtPW9bZStzXSxwPW9bZStzKzFdLGw9b1tlK3VdLGY9b1tlK3UrMV0sZD1vW2UrY10sdj1vW2UrYysxXSxnPWErbCxJPWgrZixiPWEtbCxCPWgtZixfPW0rZCx3PXArdixUPWkqKG0tZCksUD1pKihwLXYpLHk9ZytfLEE9SSt3LHg9YitQLFY9Qi1ULEY9Zy1fLE09SS13LE89Yi1QLE49QitUO3JbdF09eSxyW3QrMV09QSxyW3QrMl09eCxyW3QrM109VixyW3QrNF09RixyW3QrNV09TSxyW3QrNl09TyxyW3QrN109Tn1fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxvPWUvcjw8MSxpLHUsYz10aGlzLl9iaXRyZXY7aWYobz09PTQpZm9yKGk9MCx1PTA7aTxlO2krPW8sdSsrKXtjb25zdCBmdD1jW3VdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGksZnQ+Pj4xLHI+Pj4xKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZnQ9Y1t1XTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChpLGZ0Pj4+MSxyPj4+MSl9dmFyIGE9dGhpcy5faW52Py0xOjEsaD10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtvPWUvcjw8MTt2YXIgbT1vPj4+MSxwPW0+Pj4xLGw9cD4+PjE7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIGY9MCxkPTA7Zjw9bDtmKz0yLGQrPXIpe3ZhciB2PWkrZixnPXYrcCxJPWcrcCxiPUkrcCxCPXRbdl0sXz10W3YrMV0sdz10W2ddLFQ9dFtnKzFdLFA9dFtJXSx5PXRbSSsxXSxBPXRbYl0seD10W2IrMV0sVj1CLEY9XyxNPWhbZF0sTz1hKmhbZCsxXSxOPXcqTS1UKk8sWT13Kk8rVCpNLEw9aFsyKmRdLEg9YSpoWzIqZCsxXSxVPVAqTC15KkgsSz1QKkgreSpMLFo9aFszKmRdLCQ9YSpoWzMqZCsxXSxHPUEqWi14KiQsaj1BKiQreCpaLGs9VitVLHo9RitLLEo9Vi1VLFE9Ri1LLEU9TitHLFI9WStqLFg9YSooTi1HKSxzdD1hKihZLWopLGl0PWsrRSxvdD16K1IsYXQ9SitzdCx1dD1RLVg7aWYodFt2XT1pdCx0W3YrMV09b3QsdFtnXT1hdCx0W2crMV09dXQsZj09PTApe3ZhciBodD1rLUUsY3Q9ei1SO3RbSV09aHQsdFtJKzFdPWN0O2NvbnRpbnVlfWlmKGYhPT1sKXt2YXIgbHQ9SixFdD0tUSxSdD1rLER0PS16LHF0PS1hKnN0LFd0PS1hKlgsWXQ9LWEqUixMdD0tYSpFLEh0PWx0K3F0LFV0PUV0K1d0LEt0PVJ0K0x0LFp0PUR0LVl0LG10PWkrcC1mLHZ0PWkrbS1mO3RbbXRdPUh0LHRbbXQrMV09VXQsdFt2dF09S3QsdFt2dCsxXT1adH19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2Urc10sYz1pK3UsYT1pLXU7clt0XT1jLHJbdCsxXT0wLHJbdCsyXT1hLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsbz10aGlzLl9kYXRhLGk9dGhpcy5faW52Py0xOjEsdT1zKjIsYz1zKjMsYT1vW2VdLGg9b1tlK3NdLG09b1tlK3VdLHA9b1tlK2NdLGw9YSttLGY9YS1tLGQ9aCtwLHY9aSooaC1wKSxnPWwrZCxJPWYsYj0tdixCPWwtZCxfPWYsdz12O3JbdF09ZyxyW3QrMV09MCxyW3QrMl09SSxyW3QrM109YixyW3QrNF09QixyW3QrNV09MCxyW3QrNl09XyxyW3QrN109d319Y29uc3QgQz0obix0LGUpPT5NYXRoLm1pbihNYXRoLm1heChuLHQpLGUpLHB0PShuLHQpPT4obiV0K3QpJXQ7ZnVuY3Rpb24gYnQobix0PTEpe3JldHVybiBuPj10P24tPXQ6bjwwJiYobis9dCksbn1jb25zdCBEPTEyODtmdW5jdGlvbiBCdChuLHQpe3JldHVybiB0PU1hdGgubWluKHQsMS10KSxuPHQ/KG4vPXQsbituLW4qbi0xKTpuPjEtdD8obj0obi0xKS90LG4qbituK24rMSk6MH1jb25zdCBydD17dHJpKG4sdD0uNSl7Y29uc3QgZT0xLXQ7cmV0dXJuIG4+PXQ/MS9lLW4vZTpuL3R9LHNpbmUobil7cmV0dXJuIE1hdGguc2luKE1hdGguUEkqMipuKSouNSsuNX0scmFtcChuKXtyZXR1cm4gbn0sc2F3KG4pe3JldHVybiAxLW59LHNxdWFyZShuLHQ9LjUpe3JldHVybiBuPj10PzA6MX0sY3VzdG9tKG4sdD1bMCwxXSl7Y29uc3QgZT10Lmxlbmd0aC0xLHM9TWF0aC5mbG9vcihuKmUpLHI9MS9lLG89Qyh0W3NdLDAsMSksdT1DKHRbcysxXSwwLDEpLGM9byxhPTAsaD1yO3JldHVybih1LWMpLyhoLWEpKihuLXIqcykrb30sc2F3YmxlcChuLHQpe3JldHVybiAyKm4tMS1CdChuLHQpfX07ZnVuY3Rpb24gcShuLHQpe3JldHVybiB0Lmxlbmd0aD4xP3Rbbl06dFswXX1jb25zdCBfdD1PYmplY3Qua2V5cyhydCk7Y2xhc3Mgd3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToidGltZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJza2V3IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJkZXB0aCIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJwaGFzZW9mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJjdXJ2ZSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkY29mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJtaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToibWF4IixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlfWluY3JlbWVudFBoYXNlKHQpe3RoaXMucGhhc2UrPXQsdGhpcy5waGFzZT4xJiYodGhpcy5waGFzZT10aGlzLnBoYXNlLTEpfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9cy5iZWdpblswXTtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXIpcmV0dXJuITA7Y29uc3Qgbz1lWzBdLGk9cy5mcmVxdWVuY3lbMF0sdT1zLnRpbWVbMF0sYz1zLmRlcHRoWzBdLGE9cy5za2V3WzBdLGg9cy5waGFzZW9mZnNldFswXSxtPXMuY3VydmVbMF0scD1zLmRjb2Zmc2V0WzBdLGw9cy5taW5bMF0sZj1zLm1heFswXSxkPV90W3Muc2hhcGVbMF1dLHY9b1swXS5sZW5ndGg/PzA7dGhpcy5waGFzZT09bnVsbCYmKHRoaXMucGhhc2U9cHQodSppK2gsMSkpO2NvbnN0IGc9aS9zYW1wbGVSYXRlO2ZvcihsZXQgST0wO0k8djtJKyspe2ZvcihsZXQgYj0wO2I8by5sZW5ndGg7YisrKXtsZXQgQj0ocnRbZF0odGhpcy5waGFzZSxhKStwKSpjO0I9TWF0aC5wb3coQixtKSxvW2JdW0ldPUMoQixsLGYpfXRoaXMuaW5jcmVtZW50UGhhc2UoZyl9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsZm8tcHJvY2Vzc29yIix3dCk7Y2xhc3MgU3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY29hcnNlIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgdT1zLmNvYXJzZVswXT8/MDt1PU1hdGgubWF4KDEsdSk7Zm9yKGxldCBjPTA7YzxEO2MrKylmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKylvW2FdW2NdPWMldT09PTA/clthXVtjXTpvW2FdW2MtMV07cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjb2Fyc2UtcHJvY2Vzc29yIixTdCk7Y2xhc3MgVHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY3J1c2giLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCB1PXMuY3J1c2hbMF0/Pzg7dT1NYXRoLm1heCgxLHUpO2ZvcihsZXQgYz0wO2M8RDtjKyspZm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspe2NvbnN0IGg9TWF0aC5wb3coMix1LTEpO29bYV1bY109TWF0aC5yb3VuZChyW2FdW2NdKmgpL2h9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjcnVzaC1wcm9jZXNzb3IiLFR0KTtjbGFzcyBQdCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxvPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IHU9cy5zaGFwZVswXTt1PXU8MT91OjEtNGUtMTAsdT0yKnUvKDEtdSk7Y29uc3QgYz1NYXRoLm1heCguMDAxLE1hdGgubWluKDEscy5wb3N0Z2FpblswXSkpO2ZvcihsZXQgYT0wO2E8RDthKyspZm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspb1toXVthXT0oMSt1KSpyW2hdW2FdLygxK3UqTWF0aC5hYnMocltoXVthXSkpKmM7cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzaGFwZS1wcm9jZXNzb3IiLFB0KTtmdW5jdGlvbiBTKG4pe2NvbnN0IHQ9bipuO3JldHVybiBuKigyNyt0KS8oMjcrOSp0KX1jb25zdCBkdD0zLjE0MTU5MjY1MzU5O2NsYXNzIHl0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjUwMH0se25hbWU6InEiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToiZHJpdmUiLGRlZmF1bHRWYWx1ZTouNjl9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExLHRoaXMucDA9WzAsMF0sdGhpcy5wMT1bMCwwXSx0aGlzLnAyPVswLDBdLHRoaXMucDM9WzAsMF0sdGhpcy5wMzI9WzAsMF0sdGhpcy5wMzM9WzAsMF0sdGhpcy5wMzQ9WzAsMF19cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtjb25zdCB1PXMucVswXSxjPUMoTWF0aC5leHAocy5kcml2ZVswXSksLjEsMmUzKTtsZXQgYT1zLmZyZXF1ZW5jeVswXTthPWEqMipkdC9zYW1wbGVSYXRlLGE9YT4xPzE6YTtjb25zdCBoPU1hdGgubWluKDgsdSouMTMpO2xldCBtPTEvYypNYXRoLm1pbigxLjc1LDEraCk7Zm9yKGxldCBwPTA7cDxEO3ArKylmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKyl7Y29uc3QgZj10aGlzLnAzW2xdKi4zNjA4OTErdGhpcy5wMzJbbF0qLjQxNzI5K3RoaXMucDMzW2xdKi4xNzc4OTYrdGhpcy5wMzRbbF0qLjA0Mzk3MjU7dGhpcy5wMzRbbF09dGhpcy5wMzNbbF0sdGhpcy5wMzNbbF09dGhpcy5wMzJbbF0sdGhpcy5wMzJbbF09dGhpcy5wM1tsXSx0aGlzLnAwW2xdKz0oUyhyW2xdW3BdKmMtaCpmKS1TKHRoaXMucDBbbF0pKSphLHRoaXMucDFbbF0rPShTKHRoaXMucDBbbF0pLVModGhpcy5wMVtsXSkpKmEsdGhpcy5wMltsXSs9KFModGhpcy5wMVtsXSktUyh0aGlzLnAyW2xdKSkqYSx0aGlzLnAzW2xdKz0oUyh0aGlzLnAyW2xdKS1TKHRoaXMucDNbbF0pKSphLG9bbF1bcF09ZiptfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGFkZGVyLXByb2Nlc3NvciIseXQpO2NsYXNzIEF0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImRpc3RvcnQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IHU9TWF0aC5leHBtMShzLmRpc3RvcnRbMF0pLGM9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IGE9MDthPEQ7YSsrKWZvcihsZXQgaD0wO2g8ci5sZW5ndGg7aCsrKW9baF1bYV09KDErdSkqcltoXVthXS8oMSt1Kk1hdGguYWJzKHJbaF1bYV0pKSpjO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGlzdG9ydC1wcm9jZXNzb3IiLEF0KTtmdW5jdGlvbiB4dChuLHQsZSl7cmV0dXJuIGUqKHQtbikrbn1mdW5jdGlvbiBWdChuLHQsZSl7cmV0dXJuIG48Mj8wOnh0KC10Ki41LHQqLjUsZS8obi0xKSl9ZnVuY3Rpb24gdHQobix0KXtyZXR1cm4gbipNYXRoLnBvdygyLHQvMTIpfWNsYXNzIEZ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7Y29uc3Qgcj1lWzBdLG89cy52b2ljZXNbMF0saT1zLmZyZXFzcHJlYWRbMF0sdT1zLnBhbnNwcmVhZFswXSouNSsuNSxjPU1hdGguc3FydCgxLXUpLGE9TWF0aC5zcXJ0KHUpO2ZvcihsZXQgaD0wO2g8bztoKyspe2NvbnN0IG09KGgmMSk9PTE7bGV0IHA9YyxsPWE7bSYmKHA9YSxsPWMpO2ZvcihsZXQgZj0wO2Y8clswXS5sZW5ndGg7ZisrKXtsZXQgZD10dChzLmZyZXF1ZW5jeVtmXT8/cy5mcmVxdWVuY3lbMF0scy5kZXR1bmVbMF0vMTAwKTtkPXR0KGQsVnQobyxpLGgpKTtjb25zdCB2PXB0KGQvc2FtcGxlUmF0ZSwxKTt0aGlzLnBoYXNlW2hdPXRoaXMucGhhc2VbaF0/P01hdGgucmFuZG9tKCk7Y29uc3QgZz1ydC5zYXdibGVwKHRoaXMucGhhc2VbaF0sdik7clswXVtmXT1yWzBdW2ZdK2cqcCxyWzFdW2ZdPXJbMV1bZl0rZypsLHRoaXMucGhhc2VbaF09YnQodGhpcy5waGFzZVtoXSt2KX19cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzdXBlcnNhdy1vc2NpbGxhdG9yIixGdCk7Y29uc3QgTXQ9MjA0ODtmdW5jdGlvbiBPdChuKXtsZXQgdD1uZXcgRmxvYXQzMkFycmF5KG4pO2Zvcih2YXIgZT0wO2U8bjtlKyspdFtlXT0uNSooMS1NYXRoLmNvcygyKk1hdGguUEkqZS9uKSk7cmV0dXJuIHR9Y2xhc3MgTnQgZXh0ZW5kcyBndHtzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJwaXRjaEZhY3RvciIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcih0KXt0LnByb2Nlc3Nvck9wdGlvbnM9e2Jsb2NrU2l6ZTpNdH0sc3VwZXIodCksdGhpcy5mZnRTaXplPXRoaXMuYmxvY2tTaXplLHRoaXMudGltZUN1cnNvcj0wLHRoaXMuaGFubldpbmRvdz1PdCh0aGlzLmJsb2NrU2l6ZSksdGhpcy5mZnQ9bmV3IEl0KHRoaXMuZmZ0U2l6ZSksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZD10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLnRpbWVDb21wbGV4QnVmZmVyPXRoaXMuZmZ0LmNyZWF0ZUNvbXBsZXhBcnJheSgpLHRoaXMubWFnbml0dWRlcz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZS8yKzEpLHRoaXMucGVha0luZGV4ZXM9bmV3IEludDMyQXJyYXkodGhpcy5tYWduaXR1ZGVzLmxlbmd0aCksdGhpcy5uYlBlYWtzPTB9cHJvY2Vzc09MQSh0LGUscyl7bGV0IHI9cy5waXRjaEZhY3RvcltzLnBpdGNoRmFjdG9yLmxlbmd0aC0xXTtyPDAmJihyPXIqLjI1KSxyPU1hdGgubWF4KDAscisxKTtmb3IodmFyIG89MDtvPHRoaXMubmJJbnB1dHM7bysrKWZvcih2YXIgaT0wO2k8dFtvXS5sZW5ndGg7aSsrKXt2YXIgdT10W29dW2ldLGM9ZVtvXVtpXTt0aGlzLmFwcGx5SGFubldpbmRvdyh1KSx0aGlzLmZmdC5yZWFsVHJhbnNmb3JtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXIsdSksdGhpcy5jb21wdXRlTWFnbml0dWRlcygpLHRoaXMuZmluZFBlYWtzKCksdGhpcy5zaGlmdFBlYWtzKHIpLHRoaXMuZmZ0LmNvbXBsZXRlU3BlY3RydW0odGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmludmVyc2VUcmFuc2Zvcm0odGhpcy50aW1lQ29tcGxleEJ1ZmZlcix0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZCksdGhpcy5mZnQuZnJvbUNvbXBsZXhBcnJheSh0aGlzLnRpbWVDb21wbGV4QnVmZmVyLGMpLHRoaXMuYXBwbHlIYW5uV2luZG93KGMpfXRoaXMudGltZUN1cnNvcis9dGhpcy5ob3BTaXplfWFwcGx5SGFubldpbmRvdyh0KXtmb3IodmFyIGU9MDtlPHRoaXMuYmxvY2tTaXplO2UrKyl0W2VdPXRbZV0qdGhpcy5oYW5uV2luZG93W2VdKjEuNjJ9Y29tcHV0ZU1hZ25pdHVkZXMoKXtmb3IodmFyIHQ9MCxlPTA7dDx0aGlzLm1hZ25pdHVkZXMubGVuZ3RoOyl7bGV0IHM9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltlXSxyPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZSsxXTt0aGlzLm1hZ25pdHVkZXNbdF09cyoqMityKioyLHQrPTEsZSs9Mn19ZmluZFBlYWtzKCl7dGhpcy5uYlBlYWtzPTA7dmFyIHQ9MjtsZXQgZT10aGlzLm1hZ25pdHVkZXMubGVuZ3RoLTI7Zm9yKDt0PGU7KXtsZXQgcz10aGlzLm1hZ25pdHVkZXNbdF07aWYodGhpcy5tYWduaXR1ZGVzW3QtMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0LTJdPj1zKXt0Kys7Y29udGludWV9aWYodGhpcy5tYWduaXR1ZGVzW3QrMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0KzJdPj1zKXt0Kys7Y29udGludWV9dGhpcy5wZWFrSW5kZXhlc1t0aGlzLm5iUGVha3NdPXQsdGhpcy5uYlBlYWtzKyssdCs9Mn19c2hpZnRQZWFrcyh0KXt0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZC5maWxsKDApO2Zvcih2YXIgZT0wO2U8dGhpcy5uYlBlYWtzO2UrKyl7bGV0IGk9dGhpcy5wZWFrSW5kZXhlc1tlXSx1PU1hdGgucm91bmQoaSp0KTtpZih1PnRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7dmFyIHM9MCxyPXRoaXMuZmZ0U2l6ZTtpZihlPjApe2xldCBoPXRoaXMucGVha0luZGV4ZXNbZS0xXTtzPWktTWF0aC5mbG9vcigoaS1oKS8yKX1pZihlPHRoaXMubmJQZWFrcy0xKXtsZXQgaD10aGlzLnBlYWtJbmRleGVzW2UrMV07cj1pK01hdGguY2VpbCgoaC1pKS8yKX1sZXQgYz1zLWksYT1yLWk7Zm9yKHZhciBvPWM7bzxhO28rKyl7bGV0IGg9aStvLG09dStvO2lmKG0+PXRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7bGV0IHA9MipNYXRoLlBJKihtLWgpL3RoaXMuZmZ0U2l6ZSxsPU1hdGguY29zKHAqdGhpcy50aW1lQ3Vyc29yKSxmPU1hdGguc2luKHAqdGhpcy50aW1lQ3Vyc29yKSxkPWgqMix2PWQrMSxnPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZF0sST10aGlzLmZyZXFDb21wbGV4QnVmZmVyW3ZdLGI9ZypsLUkqZixCPWcqZitJKmwsXz1tKjIsdz1fKzE7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbX10rPWIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbd10rPUJ9fX19cmVnaXN0ZXJQcm9jZXNzb3IoInBoYXNlLXZvY29kZXItcHJvY2Vzc29yIixOdCk7Y2xhc3MgQ3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGk9ZHQsdGhpcy5waGk9LXRoaXMucGksdGhpcy5ZMD0wLHRoaXMuWTE9MCx0aGlzLlBXPXRoaXMucGksdGhpcy5CPTIuMyx0aGlzLmRwaGlmPTAsdGhpcy5lbnZmPTB9c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo0NDAsbWluOk51bWJlci5FUFNJTE9OfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9LHtuYW1lOiJwdWxzZXdpZHRoIixkZWZhdWx0VmFsdWU6MSxtaW46MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXTtsZXQgbz0xLGk7Zm9yKGxldCB1PTA7dTwoclswXS5sZW5ndGg/PzApO3UrKyl7Y29uc3QgYz0oMS1DKHEodSxzLnB1bHNld2lkdGgpLC0uOTksLjk5KSkqdGhpcy5waSxhPXEodSxzLmRldHVuZSksaD10dChxKHUscy5mcmVxdWVuY3kpLGEvMTAwKTtpPWgqKHRoaXMucGkvKHNhbXBsZVJhdGUqLjUpKSx0aGlzLmRwaGlmKz0uMSooaS10aGlzLmRwaGlmKSxvKj0uOTk5OCx0aGlzLmVudmYrPS4xKihvLXRoaXMuZW52ZiksdGhpcy5CPTIuMyooMS0xZS00KmgpLHRoaXMuQjwwJiYodGhpcy5CPTApLHRoaXMucGhpKz10aGlzLmRwaGlmLHRoaXMucGhpPj10aGlzLnBpJiYodGhpcy5waGktPTIqdGhpcy5waSk7bGV0IG09TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTApO3RoaXMuWTA9LjUqKG0rdGhpcy5ZMCk7bGV0IHA9TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTErYyk7dGhpcy5ZMT0uNSoocCt0aGlzLlkxKTtmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKylyW2xdW3VdPS4xNSoobS1wKSp0aGlzLmVudmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJwdWxzZS1vc2NpbGxhdG9yIixDdCk7Y29uc3QgbnQ9e2JpdEM6ZnVuY3Rpb24obix0LGUpe3JldHVybiBuJnQ/ZTowfSxicjpmdW5jdGlvbihuLHQ9OCl7aWYodD4zMil0aHJvdyBuZXcgRXJyb3IoImJyKCkgU2l6ZSBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDMyIik7e2xldCBlPTA7Zm9yKGxldCBzPTA7czx0LTA7cysrKWUrPW50LmJpdEMobiwyKipzLDIqKih0LShzKzEpKSk7cmV0dXJuIGV9fSxzaW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnNpbihuLygxMjgvTWF0aC5QSSkpfSxjb3NmOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLmNvcyhuLygxMjgvTWF0aC5QSSkpfSx0YW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnRhbihuLygxMjgvTWF0aC5QSSkpfSxyZWdHOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQudGVzdChuLnRvU3RyaW5nKDIpKX19O2xldCBXLGV0O2Z1bmN0aW9uIGt0KG4pe2lmKChXfHxldCk9PW51bGwpe1c9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWF0aCksZXQ9Vy5tYXAocz0+TWF0aFtzXSk7Y29uc3QgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhudCksZT10Lm1hcChzPT5udFtzXSk7Vy5wdXNoKCJpbnQiLCJ3aW5kb3ciLC4uLnQpLGV0LnB1c2goTWF0aC5mbG9vcixnbG9iYWxUaGlzLC4uLmUpfXJldHVybiBuZXcgRnVuY3Rpb24oLi4uVywidCIsYHJldHVybiAwLAoke258fDB9O2ApLmJpbmQoZ2xvYmFsVGhpcywuLi5ldCl9Y2xhc3MgenQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucG9ydC5vbm1lc3NhZ2U9dD0+e2xldHtjb2RlVGV4dDplfT10LmRhdGE7Y29uc3R7Ynl0ZUJlYXRTdGFydFRpbWU6c309dC5kYXRhO3MhPW51bGwmJih0aGlzLnQ9MCx0aGlzLmluaXRpYWxPZmZzZXQ9TWF0aC5mbG9vcihzKSksZT1lLnRyaW0oKS5yZXBsYWNlKC9eZXZhbFwodW5lc2NhcGVcKGVzY2FwZSg/OmB8XCgnfFwoInxcKGApKC4qPykoPzpgfCdcKXwiXCl8YFwpKS5yZXBsYWNlXChcL3VcKFwuXC5cKVwvZyxbIidgXVwkMSVbIidgXVwpXClcKSQvLChyLG8pPT51bmVzY2FwZShlc2NhcGUobykucmVwbGFjZSgvdSguLikvZywiJDElIikpKSx0aGlzLmZ1bmM9a3QoZSl9LHRoaXMuaW5pdGlhbE9mZnNldD1udWxsLHRoaXMudD1udWxsLHRoaXMuZnVuYz1udWxsfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO3RoaXMudD09bnVsbCYmKHRoaXMudD1zLmJlZ2luWzBdKnNhbXBsZVJhdGUpO2NvbnN0IHI9ZVswXTtmb3IobGV0IG89MDtvPHJbMF0ubGVuZ3RoO28rKyl7Y29uc3QgaT1xKG8scy5kZXR1bmUpLHU9dHQocShvLHMuZnJlcXVlbmN5KSxpLzEwMCk7bGV0IGM9dGhpcy50LyhzYW1wbGVSYXRlLzI1NikqdSt0aGlzLmluaXRpYWxPZmZzZXQ7Y29uc3QgbT0oKHRoaXMuZnVuYyhjKSYyNTUpLzEyNy41LTEpKi4yO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKXJbcF1bb109QyhtLC0uNCwuNCk7dGhpcy50PXRoaXMudCsxfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiYnl0ZS1iZWF0LXByb2Nlc3NvciIsenQpfSkoKTsK";
let _s = {};
function dd(e, t) {
  const n = Pe();
  if (_s[e])
    return _s[e];
  const r = 2 * n.sampleRate, i = n.createBuffer(1, r, n.sampleRate), s = i.getChannelData(0);
  let u = 0, a, o, f, h, m, p, A;
  a = o = f = h = m = p = A = 0;
  for (let M = 0; M < r; M++)
    if (e === "white")
      s[M] = Math.random() * 2 - 1;
    else if (e === "brown") {
      let C = Math.random() * 2 - 1;
      s[M] = (u + 0.02 * C) / 1.02, u = s[M];
    } else if (e === "pink") {
      let C = Math.random() * 2 - 1;
      a = 0.99886 * a + C * 0.0555179, o = 0.99332 * o + C * 0.0750759, f = 0.969 * f + C * 0.153852, h = 0.8665 * h + C * 0.3104856, m = 0.55 * m + C * 0.5329522, p = -0.7616 * p - C * 0.016898, s[M] = a + o + f + h + m + p + A + C * 0.5362, s[M] *= 0.11, A = C * 0.115926;
    } else if (e === "crackle") {
      const C = t * 0.01;
      Math.random() < C ? s[M] = Math.random() * 2 - 1 : s[M] = 0;
    }
  return e !== "crackle" && (_s[e] = i), i;
}
function pu(e = "white", t, n = 0.02) {
  const i = Pe().createBufferSource();
  return i.buffer = dd(e, n), i.loop = !0, i.start(t), {
    node: i,
    stop: (s) => i.stop(s)
  };
}
function GC(e, t, n) {
  const r = pu("pink", n);
  return {
    node: gd(e, r.node, t),
    stop: (s) => r?.stop(s)
  };
}
const sa = ["pink", "white", "brown", "crackle"];
function gt(e) {
  const t = Pe().createGain();
  return t.gain.value = e, t;
}
const mo = (e, t, n, r) => r - n === 0 ? 0 : (t - e) / (r - n);
function Ot(e, t, n, r) {
  const i = new AudioWorkletNode(e, t, r);
  return Object.entries(n).forEach(([s, u]) => {
    i.parameters.get(s).value = u;
  }), i;
}
const en = (e, t, n, r, i, s, u, a, o, f = "exponential") => {
  t = Mn(t), n = Mn(n), r = Mn(r), i = Mn(i);
  const h = f === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  f === "exponential" && (s = s === 0 ? 1e-3 : s, u = u === 0 ? 1e-3 : u);
  const m = u - s, p = u, A = s + r * m, M = o - a, C = (F) => {
    let _;
    if (t > F) {
      let k = mo(s, p, 0, t);
      _ = F * k + (s > p ? s : 0);
    } else
      _ = (F - t) * mo(p, A, 0, n) + p;
    return f === "exponential" && (_ = _ || 1e-3), _;
  };
  e.setValueAtTime(s, a), t > M ? e[h](C(M), o) : t + n > M ? (e[h](C(t), a + t), e[h](C(M), o)) : (e[h](C(t), a + t), e[h](C(t + n), a + t + n), e.setValueAtTime(A, o)), e[h](s, o + i);
};
function md(e, t, n, r, i, s) {
  const u = {
    threshold: t ?? -3,
    ratio: n ?? 10,
    knee: r ?? 10,
    attack: i ?? 5e-3,
    release: s ?? 0.05
  };
  return new DynamicsCompressorNode(e, u);
}
const tn = (e, t = "linear", n) => {
  const [u, a, o, f] = e;
  if (u == null && a == null && o == null && f == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const h = o ?? (u != null && a == null || u == null && a == null ? 1 : 1e-3);
  return [Math.max(u ?? 0, 1e-3), Math.max(a ?? 0, 1e-3), Math.min(h, 1), Math.max(f ?? 0, 0.01)];
};
function wi(e, t, n, r, i, s, u, a, o, f, h, m, p, A) {
  const M = "exponential", [C, F, _, k] = tn([i, s, u, a], M, [5e-3, 0.14, 0, 0.1]);
  let L, S;
  if (p === "ladder" ? (L = Ot(e, "ladder-processor", { frequency: n, q: r, drive: A }), S = L.parameters.get("frequency")) : (L = e.createBiquadFilter(), L.type = t, L.Q.value = r, L.frequency.value = n, S = L.frequency), (i ?? s ?? u ?? a ?? o) !== void 0) {
    o = Mn(o, 1, !0), m = Mn(m, 0, !0);
    const B = Math.abs(o), V = B * m;
    let T = Kn(2 ** -V * n, 0, 2e4), H = Kn(2 ** (B - V) * n, 0, 2e4);
    return o < 0 && ([T, H] = [H, T]), en(S, C, F, _, k, T, H, f, h, M), L;
  }
  return L;
}
let go = (e) => e < 0.5 ? 1 : 1 - (e - 0.5) / 0.5;
function gd(e, t, n = 0) {
  const r = Pe();
  if (!n)
    return e;
  let i = r.createGain(), s = r.createGain();
  e.connect(i), t.connect(s), i.gain.value = go(n), s.gain.value = go(1 - n);
  let u = r.createGain();
  return i.connect(u), s.connect(u), u;
}
let ZC = ["linear", "exponential"];
function ii(e, t, n, r) {
  if (!(t.pattack ?? t.pdecay ?? t.psustain ?? t.prelease ?? t.penv))
    return;
  const s = Mn(t.penv, 1, !0), u = ZC[t.pcurve ?? 0];
  let [a, o, f, h] = tn(
    [t.pattack, t.pdecay, t.psustain, t.prelease],
    u,
    [0.2, 1e-3, 1, 1e-3]
  ), m = t.panchor ?? f;
  const p = s * 100, A = 0 - p * m, M = p - p * m;
  en(e, a, o, f, h, A, M, n, r, u);
}
function si(e, t, n) {
  const { vibmod: r = 0.5, vib: i } = t;
  let s;
  if (i > 0) {
    s = Pe().createOscillator(), s.frequency.value = i;
    const u = Pe().createGain();
    return u.gain.value = r * 100, s.connect(u), u.connect(e), s.start(n), s;
  }
}
function Yr(e, t, n, r) {
  const i = new ConstantSourceNode(e), s = gt(0);
  return s.connect(e.destination), i.connect(s), i.onended = () => {
    try {
      s.disconnect();
    } catch {
    }
    try {
      i.disconnect();
    } catch {
    }
    t();
  }, i.start(n), i.stop(r), i;
}
const XC = (e, t = 1, n = "sine") => {
  const r = Pe();
  let i;
  sa.includes(n) ? (i = r.createBufferSource(), i.buffer = dd(n, 2), i.loop = !0) : (i = r.createOscillator(), i.type = n, i.frequency.value = e), i.start();
  const s = new GainNode(r, { gain: t });
  return i.connect(s), { node: s, stop: (u) => i.stop(u) };
}, WC = (e, t, n, r = "sine") => {
  const s = e.value * t, u = s * n;
  return XC(s, u, r);
};
function Li(e, t, n) {
  const {
    fmh: r = 1,
    fmi: i,
    fmenv: s = "exp",
    fmattack: u,
    fmdecay: a,
    fmsustain: o,
    fmrelease: f,
    fmvelocity: h,
    fmwave: m = "sine",
    duration: p
  } = t;
  let A, M = () => {
  };
  if (i) {
    const F = Pe().createGain(), _ = WC(e, r, i, m);
    if (A = _.node, M = _.stop, ![u, a, o, f, h].some((k) => k !== void 0))
      A.connect(e);
    else {
      const [k, L, S, x] = tn([u, a, o, f]), B = n + p;
      en(
        F.gain,
        k,
        L,
        S,
        x,
        0,
        1,
        n,
        B,
        s === "exp" ? "exponential" : "linear"
      ), A.connect(F), F.connect(e);
    }
  }
  return { stop: M };
}
let Xt = [], _n = 0;
const Di = 4;
let OC = (e) => {
  let t = [], n = {
    get() {
      return n.lc || n.listen(() => {
      })(), n.value;
    },
    lc: 0,
    listen(r) {
      return n.lc = t.push(r), () => {
        for (let s = _n + Di; s < Xt.length; )
          Xt[s] === r ? Xt.splice(s, Di) : s += Di;
        let i = t.indexOf(r);
        ~i && (t.splice(i, 1), --n.lc || n.off());
      };
    },
    notify(r, i) {
      let s = !Xt.length;
      for (let u of t)
        Xt.push(
          u,
          n.value,
          r,
          i
        );
      if (s) {
        for (_n = 0; _n < Xt.length; _n += Di)
          Xt[_n](
            Xt[_n + 1],
            Xt[_n + 2],
            Xt[_n + 3]
          );
        Xt.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let i = n.value;
      i !== r && (n.value = r, n.notify(i));
    },
    subscribe(r) {
      let i = n.listen(r);
      return r(n.value), i;
    },
    value: e
  };
  return n;
}, zC = (e = {}) => {
  let t = OC(e);
  return t.setKey = function(n, r) {
    let i = t.value;
    typeof r > "u" && n in t.value ? (t.value = { ...t.value }, delete t.value[n], t.notify(i, n)) : t.value[n] !== r && (t.value = {
      ...t.value,
      [n]: r
    }, t.notify(i, n));
  }, t;
};
const ua = {}, ks = {}, jC = (e) => ua[e];
function $C(e, t) {
  var n = 1024;
  if (e < n) return e + " B";
  var r = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], i = -1;
  do
    e /= n, ++i;
  while (e >= n);
  return e.toFixed(1) + " " + r[i];
}
function yd(e, t) {
  const { s: n, n: r = 0, speed: i = 1 } = e;
  let s = NC(e, 36), u = s - 36, a, o = 0;
  if (Array.isArray(t))
    o = ho(r, t.length), a = t[o];
  else {
    const m = (A) => ts(A) - s, p = Object.keys(t).filter((A) => !A.startsWith("_")).reduce(
      (A, M, C) => !A || Math.abs(m(M)) < Math.abs(m(A)) ? M : A,
      null
    );
    u = -m(p), o = ho(r, t[p].length), a = t[p][o];
  }
  const f = `${n}:${o}`;
  let h = Math.abs(i) * Math.pow(2, u / 12);
  return { transpose: u, sampleUrl: a, index: o, midi: s, label: f, playbackRate: h };
}
const Ad = async (e, t, n) => {
  let { sampleUrl: r, label: i, playbackRate: s } = yd(e, t);
  n && (r = await n(r));
  const u = Pe(), a = await aa(r, u, i);
  return e.unit === "c" && (s = s * a.duration), { buffer: a, playbackRate: s };
}, bd = async (e, t, n) => {
  let { buffer: r, playbackRate: i } = await Ad(e, t, n);
  e.speed < 0 && (r = Md(r));
  const u = Pe().createBufferSource();
  u.buffer = r, u.playbackRate.value = i;
  const { s: a, loopBegin: o = 0, loopEnd: f = 1, begin: h = 0, end: m = 1 } = e, p = h * u.buffer.duration;
  (a.startsWith("wt_") ? 1 : e.loop) && (u.loop = !0, u.loopStart = o * u.buffer.duration - p, u.loopEnd = f * u.buffer.duration - p);
  const M = u.buffer.duration / u.playbackRate.value, C = (m - h) * M;
  return { bufferSource: u, offset: p, bufferDuration: M, sliceDuration: C };
}, aa = (e, t, n, r = 0) => {
  const i = n ? `sound "${n}:${r}"` : "sample";
  if (e = e.replace("#", "%23"), !ks[e]) {
    Pt(`[sampler] load ${i}..`, "load-sample", { url: e });
    const s = Date.now();
    ks[e] = fetch(e).then((u) => u.arrayBuffer()).then(async (u) => {
      const a = Date.now() - s, o = $C(u.byteLength);
      Pt(`[sampler] load ${i}... done! loaded ${o} in ${a}ms`, "loaded-sample", { url: e });
      const f = await t.decodeAudioData(u);
      return ua[e] = f, f;
    });
  }
  return ks[e];
};
function Md(e) {
  const t = Pe(), n = t.createBuffer(e.numberOfChannels, e.length, t.sampleRate);
  for (let r = 0; r < e.numberOfChannels; r++)
    n.copyToChannel(e.getChannelData(r).slice().reverse(), r, r);
  return n;
}
const qC = (e) => ua[e];
function Cd(e) {
  if (e.startsWith("bubo:")) {
    const [t, n] = e.split(":");
    e = `github:Bubobubobubobubo/dough-${n}`;
  }
  return e;
}
function vd(e, t = "") {
  if (!e.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, r] = e.split("github:");
  return r = r.endsWith("/") ? r.slice(0, -1) : r, r.split("/").length === 2 && (r += "/main"), `https://raw.githubusercontent.com/${r}/${t}`;
}
const Pd = (e, t, n = e._base || "") => Object.entries(e).forEach(([r, i]) => {
  if (typeof i == "string" && (i = [i]), typeof i != "object")
    throw new Error("wrong sample map format for " + r);
  n = i._base || n, n = Cd(n), n.startsWith("github:") && (n = vd(n, ""));
  const s = (u) => n + u;
  Array.isArray(i) ? i = i.map(s) : i = Object.fromEntries(
    Object.entries(i).map(([u, a]) => [u, (typeof a == "string" ? [a] : a).map(s)])
  ), t(r, i);
});
let Dd = {};
function HC(e, t) {
  Dd[e] = t;
}
function KC(e) {
  const t = Object.entries(Dd).find(([n]) => e.startsWith(n));
  if (t)
    return t[1];
}
const Fd = async (e, t = e._base || "", n = {}) => {
  if (typeof e == "string") {
    const s = KC(e);
    if (s)
      return s(e);
    if (e = Cd(e), e.startsWith("github:") && (e = vd(e, "strudel.json")), e.startsWith("local:") && (e = "http://localhost:5432"), e.startsWith("shabda:")) {
      let [a, o] = e.split("shabda:");
      e = `https://shabda.ndre.gr/${o}.json?strudel=1`;
    }
    if (e.startsWith("shabda/speech")) {
      let [a, o] = e.split("shabda/speech");
      o = o.startsWith("/") ? o.substring(1) : o;
      let [f, h] = o.split(":"), m = "f", p = "en-GB";
      f && ([p, m] = f.split("/")), e = `https://shabda.ndre.gr/speech/${h}.json?gender=${m}&language=${p}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const u = e.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(e).then((a) => a.json()).then((a) => Fd(a, t || a._base || u, n)).catch((a) => {
      throw console.error(a), new Error(`error loading "${e}"`);
    });
  }
  const { prebake: r, tag: i } = n;
  Pd(
    e,
    (s, u) => An(s, (a, o, f) => Ed(a, o, f, u), {
      type: "sample",
      samples: u,
      baseUrl: t,
      prebake: r,
      tag: i
    }),
    t
  );
}, yo = [];
async function Ed(e, t, n, r, i) {
  let {
    s,
    nudge: u = 0,
    // TODO: is this in seconds?
    cut: a,
    loop: o,
    clip: f = void 0,
    // if set, samples will be cut off when the hap ends
    n: h = 0,
    speed: m = 1,
    // sample playback speed
    duration: p
  } = t;
  if (m === 0)
    return;
  const A = Pe();
  let [M, C, F, _] = tn([t.attack, t.decay, t.sustain, t.release]);
  const { bufferSource: k, sliceDuration: L, offset: S } = await bd(t, r, i);
  if (A.currentTime > e) {
    Pt(`[sampler] still loading sound "${s}:${h}"`, "highlight");
    return;
  }
  if (!k) {
    Pt(`[sampler] could not load "${s}:${h}"`, "error");
    return;
  }
  let x = si(k.detune, t, e);
  const B = e + u;
  k.start(B, S);
  const V = A.createGain(), T = k.connect(V);
  f == null && o == null && t.release == null && (p = L);
  let H = e + p;
  en(T.gain, M, C, F, _, 0, 1, e, H, "linear"), ii(k.detune, t, e, H);
  const X = A.createGain();
  T.connect(X), k.onended = function() {
    k.disconnect(), x?.stop(), T.disconnect(), X.disconnect(), n();
  };
  let U = H + _ + 0.01;
  k.stop(U);
  const z = { node: X, bufferSource: k, stop: (te) => {
    k.stop(te);
  } };
  if (a !== void 0) {
    const te = yo[a];
    te && (te.node.gain.setValueAtTime(1, B), te.node.gain.linearRampToValueAtTime(0, B + 0.01)), yo[a] = z;
  }
  return z;
}
const oa = 128, du = "System Standard";
let xd = oa;
function wd(e) {
  xd = parseInt(e) ?? oa;
}
let Sd = !1;
function Bd(e) {
  Sd = e == !0;
}
function YC(e) {
  return typeof e == "number" ? e % 5 : { tri: 0, triangle: 0, sine: 1, ramp: 2, saw: 3, square: 4 }[e] ?? 0;
}
const nn = zC();
function An(e, t, n = {}) {
  e = e.toLowerCase().replace(/\s+/g, "_"), nn.setKey(e, { onTrigger: t, data: n });
}
let _d = (e) => e;
function yn(e) {
  return _d(e);
}
function JC(e) {
  _d = e;
}
function mu(e) {
  for (const n in e)
    e[n.toLowerCase()] = e[n];
  const t = nn.get();
  for (const n in t) {
    const [r, i] = n.split("_");
    if (!i) continue;
    const s = e[r];
    if (s) {
      if (typeof s == "string")
        t[`${s}_${i}`.toLowerCase()] = t[n];
      else if (Array.isArray(s))
        for (const u of s)
          t[`${u}_${i}`.toLowerCase()] = t[n];
    }
  }
  nn.set({ ...t });
}
async function UC(e) {
  const n = await (await fetch(e)).json();
  mu(n);
}
async function QC(...e) {
  switch (e.length) {
    case 1:
      return typeof e[0] == "string" ? UC(e[0]) : mu(e[0]);
    case 2:
      return mu({ [e[0]]: e[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + e.length);
  }
}
function Si(e) {
  return typeof e != "string" ? (console.warn(`getSound: expected string got "${e}". fall back to triangle`), nn.get().triangle) : nn.get()[e.toLowerCase()];
}
const kd = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let e = await navigator.mediaDevices.enumerateDevices();
  e = e.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const t = /* @__PURE__ */ new Map();
  return t.set(du, ""), e.forEach((n) => {
    t.set(n.label, n.deviceId);
  }), t;
};
let fi = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaysync: 3 / 16,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
const ev = Object.freeze({ ...fi });
function tv(e, t) {
  fi[e] = t;
}
function nv() {
  fi = { ...ev };
}
let ca = new Map(Object.entries(fi));
function la(e, t) {
  ca.set(e, t);
}
function Ye(e) {
  return ca.get(e);
}
function rv(e) {
  Object.keys(e).forEach((t) => {
    la(t, e[t]);
  });
}
function Vd() {
  ca = new Map(Object.entries(fi));
}
function iv(e) {
  Vd(), e === "1.0" && la("fanchor", 0.5);
}
const sv = () => nn.set({});
let Ri;
const Id = () => (Ri = new AudioContext(), Ri), Pe = () => Ri || Id();
function uv() {
  return Pe().currentTime;
}
let Vs;
function av() {
  return Vs || (Vs = Pe().audioWorklet.addModule(RC)), Vs;
}
async function Td(e = {}) {
  const {
    disableWorklets: t = !1,
    maxPolyphony: n,
    audioDeviceName: r = du,
    multiChannelOrbits: i = !1
  } = e;
  if (wd(n), Bd(i), typeof window > "u")
    return;
  const s = Pe();
  if (r != null && r != du)
    try {
      const a = (await kd()).get(r), o = (a ?? "").length > 0;
      s.sinkId !== a && o && await s.setSinkId(a), Pt(
        `[superdough] Audio Device set to ${r}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      Pt("[superdough] failed to set audio interface", "warning");
    }
  if (await s.resume(), t) {
    Pt("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await av(), Pt("[superdough] AudioWorklets loaded");
  } catch (u) {
    console.warn("could not load AudioWorklet effects", u);
  }
  Pt("[superdough] ready");
}
let Is;
async function Nd(e) {
  return Is || (Is = new Promise((t) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await Td(e), t();
    });
  })), Is;
}
let Gi, dr;
function Ld() {
  const e = Pe(), t = e.destination.maxChannelCount;
  e.destination.channelCount = t, Gi = new ChannelMergerNode(e, { numberOfInputs: e.destination.channelCount }), dr = new GainNode(e), Gi.connect(dr), dr.connect(e.destination);
}
const Rd = (e, t = [0, 1]) => {
  const n = Pe();
  Gi == null && Ld();
  const r = new StereoPannerNode(n);
  e.connect(r);
  const i = new ChannelSplitterNode(n, {
    numberOfOutputs: r.channelCount
  });
  r.connect(i), t.forEach((s, u) => {
    i.connect(Gi, u % r.channelCount, s % n.destination.channelCount);
  });
}, ov = () => {
  dr != null && (dr.gain.linearRampToValueAtTime(0, Pe().currentTime + 0.01), dr = null);
};
function cv(e, t, n, r) {
  if (n = Kn(n, 0, 0.98), !we[e].delayNode) {
    const s = Pe().createFeedbackDelay(1, t, n);
    s.start?.(r), Zi(s, e), we[e].delayNode = s;
  }
  return we[e].delayNode.delayTime.value !== t && we[e].delayNode.delayTime.setValueAtTime(t, r), we[e].delayNode.feedback.value !== n && we[e].delayNode.feedback.setValueAtTime(n, r), we[e].delayNode;
}
function ns(e, t, n, r = {}) {
  const { shape: i = 0, ...s } = r, { dcoffset: u = -0.5, depth: a = 1 } = r, o = {
    frequency: 1,
    depth: a,
    skew: 0.5,
    phaseoffset: 0,
    time: t,
    begin: t,
    end: n,
    shape: YC(i),
    dcoffset: u,
    min: u * a,
    max: u * a + a,
    curve: 1,
    ...s
  };
  return Ot(e, "lfo-processor", o);
}
function lv(e, t, n = 1, r = 0.5, i = 1e3, s = 2e3) {
  const u = Pe(), a = ns(u, e, t, { frequency: n, depth: s * 2 }), o = 2;
  let f = 0;
  const h = [];
  for (let m = 0; m < o; m++) {
    const p = u.createBiquadFilter();
    p.type = "notch", p.gain.value = 1, p.frequency.value = i + f, p.Q.value = 2 - Math.min(Math.max(r * 2, 0), 1.9), a.connect(p.detune), f += 282, m > 0 && h[m - 1].connect(p), h.push(p);
  }
  return h[h.length - 1];
}
function fv(e) {
  e = e ?? 0;
  const t = ["12db", "ladder", "24db"];
  return typeof e == "number" ? t[Math.floor(pd(e, t.length))] : e;
}
let we = {};
function Zi(e, t) {
  we[t] == null && ia(new Error("target orbit does not exist"), "superdough"), e.connect(we[t].gain);
}
function hv(e, t, n) {
  we[t] == null && (we[t] = {
    gain: new GainNode(e, { gain: 1, channelCount: 2, channelCountMode: "explicit" })
  }, Rd(we[t].gain, n));
}
function pv(e, t, n, r = 0.1, i = 1) {
  [t].flat().forEach((u) => {
    if (we[u] == null) {
      ia(new Error(`duck target orbit ${u} does not exist`), "superdough");
      return;
    }
    Yr(
      e,
      () => {
        we[u].gain.gain.cancelScheduledValues(n);
        const a = we[u].gain.gain.value;
        we[u].gain.gain.linearRampToValueAtTime(Kn(1 - Math.pow(i, 0.5), 0.01, a), n), we[u].gain.gain.exponentialRampToValueAtTime(1, n + Math.max(2e-3, r));
      },
      0,
      n - 0.01
    );
  });
}
let fr = (e, t) => e !== void 0 && e !== t;
function dv(e, t, n, r, i, s, u, a) {
  if (!we[e].reverbNode) {
    const f = Pe().createReverb(t, n, r, i, s, u, a);
    Zi(f, e), we[e].reverbNode = f;
  }
  return (fr(t, we[e].reverbNode.duration) || fr(n, we[e].reverbNode.fade) || fr(r, we[e].reverbNode.lp) || fr(i, we[e].reverbNode.dim) || fr(u, we[e].reverbNode.irspeed) || fr(a, we[e].reverbNode.irbegin) || we[e].reverbNode.ir !== s) && we[e].reverbNode.generate(t, n, r, i, s, u, a), we[e].reverbNode;
}
let ft = {}, zn = {};
function Gd(e, t = 1024, n = 0.5) {
  if (!ft[e]) {
    const r = Pe().createAnalyser();
    r.fftSize = t, r.smoothingTimeConstant = n, ft[e] = r, zn[e] = new Float32Array(ft[e].frequencyBinCount);
  }
  return ft[e].fftSize !== t && (ft[e].fftSize = t, zn[e] = new Float32Array(ft[e].frequencyBinCount)), ft[e];
}
function rs(e = "time", t = 1) {
  const n = {
    time: () => ft[t]?.getFloatTimeDomainData(zn[t]),
    frequency: () => ft[t]?.getFloatFrequencyData(zn[t])
  }[e];
  if (!n)
    throw new Error(`getAnalyzerData: ${e} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), zn[t];
}
function Ts(e, t, n) {
  const r = gt(n);
  return e.connect(r), r.connect(t), r;
}
function mv() {
  we = {}, ft = {}, zn = {};
}
let Gr = /* @__PURE__ */ new Map();
function Ao(e) {
  return (Array.isArray(e) ? e : [e]).map((t) => t - 1);
}
const fa = async (e, t, n, r = 0.5, i = 0.5) => {
  const s = Pe();
  let { stretch: u } = e;
  if (u != null && (t = t - 0.04), typeof e != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${e}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (e.duration = n, t < s.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${t.toFixed(2)}, now: ${s.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    tremolo: a,
    tremolosync: o,
    tremolodepth: f = 1,
    tremoloskew: h,
    tremolophase: m = 0,
    tremoloshape: p,
    s: A = Ye("s"),
    bank: M,
    source: C,
    gain: F = Ye("gain"),
    postgain: _ = Ye("postgain"),
    density: k = Ye("density"),
    duckorbit: L,
    duckattack: S,
    duckdepth: x,
    // filters
    fanchor: B = Ye("fanchor"),
    drive: V = 0.69,
    release: T = 0,
    // low pass
    cutoff: H,
    lpenv: X,
    lpattack: U,
    lpdecay: O,
    lpsustain: z,
    lprelease: te,
    resonance: me = Ye("resonance"),
    // high pass
    hpenv: pe,
    hcutoff: le,
    hpattack: ie,
    hpdecay: ke,
    hpsustain: et,
    hprelease: oe,
    hresonance: W = Ye("hresonance"),
    // band pass
    bpenv: $e,
    bandf: xe,
    bpattack: tt,
    bpdecay: ge,
    bpsustain: qe,
    bprelease: Ee,
    bandq: Ke = Ye("bandq"),
    //phaser
    phaserrate: Ft,
    phaserdepth: bt = Ye("phaserdepth"),
    phasersweep: Ve,
    phasercenter: En,
    //
    coarse: Ge,
    crush: Yt,
    dry: dt,
    shape: Et,
    shapevol: Nt = Ye("shapevol"),
    distort: xn,
    distortvol: Jt = Ye("distortvol"),
    pan: ln,
    vowel: fn,
    delay: ct = Ye("delay"),
    delayfeedback: hn = Ye("delayfeedback"),
    delaysync: be = Ye("delaysync"),
    delaytime: _e,
    orbit: Q = Ye("orbit"),
    room: Oe,
    roomfade: Be,
    roomlp: tr,
    roomdim: Vr,
    roomsize: Mt,
    ir: wn,
    irspeed: Ut,
    irbegin: ze,
    i: Xn = Ye("i"),
    velocity: Wn = Ye("velocity"),
    analyze: Ie,
    // analyser wet
    fft: rt = Ye("fft"),
    // fftSize 0 - 10
    compressor: Qt,
    compressorRatio: Sn,
    compressorKnee: nr,
    compressorAttack: Ir,
    compressorRelease: Tr
  } = e;
  _e = _e ?? LC(be, r);
  const c = Ao(
    Sd && Q > 0 ? [Q * 2 - 1, Q * 2] : Ye("channels")
  ), g = e.channels != null ? Ao(e.channels) : c;
  hv(s, Q, g), L != null && pv(s, L, t, S, x), F = yn(Mn(F, 1)), _ = yn(_), Nt = yn(Nt), Jt = yn(Jt), ct = yn(ct), Wn = yn(Wn), f = yn(f), F *= Wn;
  const d = t + n, y = d + T, P = Math.round(Math.random() * 1e6);
  for (let ye = 0; ye <= Gr.size - xd; ye++) {
    const lt = Gr.entries().next(), Ne = lt.value[1], Ct = lt.value[0], Ai = t + 0.25;
    Ne?.node?.gain?.linearRampToValueAtTime(0, Ai), Ne?.stop?.(Ai), Gr.delete(Ct);
  }
  let I = [];
  if (["-", "~", "_"].includes(A))
    return;
  M && A && (A = `${M}_${A}`, e.s = A);
  let R;
  if (C)
    R = C(t, e, n, r);
  else if (Si(A)) {
    const { onTrigger: ye } = Si(A), Ne = await ye(t, e, () => {
      I.forEach((Ct) => Ct?.disconnect()), Gr.delete(P);
    });
    Ne && (R = Ne.node, Gr.set(P, Ne));
  } else
    throw new Error(`sound ${A} not found! Is it loaded?`);
  if (!R)
    return;
  if (s.currentTime > t) {
    Pt("[webaudio] skip hap: still loading", s.currentTime - t);
    return;
  }
  const Z = [];
  Z.push(R), u !== void 0 && Z.push(Ot(s, "phase-vocoder-processor", { pitchFactor: u })), Z.push(gt(F));
  const Y = fv(e.ftype);
  if (H !== void 0) {
    let ye = () => wi(
      s,
      "lowpass",
      H,
      me,
      U,
      O,
      z,
      te,
      X,
      t,
      d,
      B,
      Y,
      V
    );
    Z.push(ye()), Y === "24db" && Z.push(ye());
  }
  if (le !== void 0) {
    let ye = () => wi(
      s,
      "highpass",
      le,
      W,
      ie,
      ke,
      et,
      oe,
      pe,
      t,
      d,
      B
    );
    Z.push(ye()), Y === "24db" && Z.push(ye());
  }
  if (xe !== void 0) {
    let ye = () => wi(s, "bandpass", xe, Ke, tt, ge, qe, Ee, $e, t, d, B);
    Z.push(ye()), Y === "24db" && Z.push(ye());
  }
  if (fn !== void 0) {
    const ye = s.createVowelFilter(fn);
    Z.push(ye);
  }
  if (Ge !== void 0 && Z.push(Ot(s, "coarse-processor", { coarse: Ge })), Yt !== void 0 && Z.push(Ot(s, "crush-processor", { crush: Yt })), Et !== void 0 && Z.push(Ot(s, "shape-processor", { shape: Et, postgain: Nt })), xn !== void 0 && Z.push(Ot(s, "distort-processor", { distort: xn, postgain: Jt })), o != null && (a = r * o), a !== void 0) {
    const ye = Math.max(1 - f, 0), lt = new GainNode(s, { gain: ye }), Ne = i / r;
    ns(s, t, y, {
      skew: h ?? (p != null ? 0.5 : 1),
      frequency: a,
      depth: f,
      time: Ne,
      dcoffset: 0,
      shape: p,
      phaseoffset: m,
      min: 0,
      max: 1,
      curve: 1.5
    }).connect(lt.gain), Z.push(lt);
  }
  if (Qt !== void 0 && Z.push(
    md(s, Qt, Sn, nr, Ir, Tr)
  ), ln !== void 0) {
    const ye = s.createStereoPanner();
    ye.pan.value = 2 * ln - 1, Z.push(ye);
  }
  if (Ft !== void 0 && bt > 0) {
    const ye = lv(t, y, Ft, bt, En, Ve);
    Z.push(ye);
  }
  const fe = new GainNode(s, { gain: _ });
  Z.push(fe);
  let Te;
  if (ct > 0 && _e > 0 && hn > 0) {
    const ye = cv(Q, _e, hn, t);
    Te = Ts(fe, ye, ct), I.push(Te);
  }
  let xt;
  if (Oe > 0) {
    let ye;
    if (wn !== void 0) {
      let Ne, Ct = Si(wn);
      Array.isArray(Ct) ? Ne = Ct.data.samples[Xn % Ct.data.samples.length] : typeof Ct == "object" && (Ne = Object.values(Ct.data.samples).flat()[Xn % Object.values(Ct.data.samples).length]), ye = await aa(Ne, s, wn, 0);
    }
    const lt = dv(Q, Mt, Be, tr, Vr, ye, Ut, ze);
    xt = Ts(fe, lt, Oe), I.push(xt);
  }
  let Lt;
  if (Ie) {
    const ye = Gd(Ie, 2 ** (rt + 5));
    Lt = Ts(fe, ye, 1), I.push(Lt);
  }
  if (dt != null) {
    dt = yn(dt);
    const ye = new GainNode(s, { gain: dt });
    Z.push(ye), Zi(ye, Q);
  } else
    Zi(fe, Q);
  Z.slice(1).reduce((ye, lt) => ye.connect(lt), Z[0]), I = I.concat(Z);
}, gv = (e, t, n, r) => {
  fa(t, e - n, t.duration / r, r);
}, Kr = (e, t = 36) => {
  let { note: n, freq: r } = e;
  return n = n || t, typeof n == "string" && (n = ts(n)), !r && typeof n == "number" && (r = hd(n)), Number(r);
};
function Fi(e) {
  e != null && (e.disconnect(), e.parameters.get("end")?.setValueAtTime(0, 0));
}
const yv = ["triangle", "square", "sawtooth", "sine"], Av = [
  ["tri", "triangle"],
  ["sqr", "square"],
  ["saw", "sawtooth"],
  ["sin", "sine"]
];
function bv(e, t) {
  const n = e, r = new Float32Array(t);
  for (let i = 0; i < t; i++) {
    const s = i * 2 / t - 1;
    r[i] = Math.tanh(s * n);
  }
  return r;
}
function Zd() {
  [...yv].forEach((e) => {
    An(
      e,
      (t, n, r) => {
        const [i, s, u, a] = tn(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let o = Wd(e, t, n), { node: f, stop: h, triggerRelease: m } = o;
        const p = gt(0.3), { duration: A } = n;
        f.onended = () => {
          f.disconnect(), p.disconnect(), r();
        };
        const M = gt(1);
        let C = f.connect(p).connect(M);
        const F = t + A;
        en(C.gain, i, s, u, a, 0, 1, t, F, "linear");
        const _ = F + a + 0.01;
        return m?.(_), h(_), {
          node: C,
          stop: (k) => {
            h(k);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), An(
    "sbd",
    (e, t, n) => {
      const { duration: r, decay: i = 0.5, pdecay: s = 0.5, penv: u = 36, clip: a } = t, o = Pe(), f = 0.02, h = 1.2, m = 0.025, p = 1, A = o.createOscillator();
      A.type = "triangle", A.frequency.value = Kr(t, 29), A.detune.setValueAtTime(u * 100, 0), A.detune.setValueAtTime(u * 100, e), A.detune.exponentialRampToValueAtTime(1e-3, e + s);
      const M = gt(1);
      M.gain.setValueAtTime(1, e + f), M.gain.exponentialRampToValueAtTime(1e-3, e + f + i), A.start(e);
      const C = pu("brown", e, 2), F = gt(1);
      F.gain.setValueAtTime(h, e), F.gain.exponentialRampToValueAtTime(1e-3, e + m);
      const _ = new WaveShaperNode(o);
      _.curve = bv(2, o.sampleRate);
      const k = gt(p);
      A.onended = () => {
        A.disconnect(), M.disconnect(), _.disconnect(), C.node.disconnect(), F.disconnect(), k.disconnect(), n();
      };
      const L = A.connect(_).connect(M).connect(k);
      C.node.connect(F).connect(k);
      let x = e + i + 0.01;
      return a != null && (x = Math.min(e + a * r, x)), k.gain.setValueAtTime(p, x - 0.01), k.gain.linearRampToValueAtTime(0, x), A.stop(x), C.stop(x), {
        node: L,
        stop: (B) => {
          A.stop(B);
        }
      };
    },
    { type: "synth", prebake: !0 }
  ), An(
    "supersaw",
    (e, t, n) => {
      const r = Pe();
      let { duration: i, n: s, unison: u = 5, spread: a = 0.6, detune: o } = t;
      o = o ?? s ?? 0.18;
      const f = Kr(t), [h, m, p, A] = tn(
        [t.attack, t.decay, t.sustain, t.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), M = e + i, C = M + A + 0.01, F = Kn(u, 1, 100);
      let _ = F > 1 ? Kn(a, 0, 1) : 0, k = Ot(
        r,
        "supersaw-oscillator",
        {
          frequency: f,
          begin: e,
          end: C,
          freqspread: o,
          voices: F,
          panspread: _
        },
        {
          outputChannelCount: [2]
        }
      );
      const L = 1 / Math.sqrt(F);
      ii(k.parameters.get("detune"), t, e, M);
      const S = si(k.parameters.get("detune"), t, e), x = Li(k.parameters.get("frequency"), t, e);
      let B = gt(1);
      B = k.connect(B), en(B.gain, h, m, p, A, 0, 0.3 * L, e, M, "linear");
      let V = Yr(
        r,
        () => {
          Fi(k), B.disconnect(), n(), x?.stop(), S?.stop();
        },
        e,
        C
      );
      return {
        node: B,
        stop: (T) => {
          V.stop(T);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), An(
    "bytebeat",
    (e, t, n) => {
      const r = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: i = 0 } = t, s = Kr(t), { byteBeatExpression: u = r[i % r.length], byteBeatStartTime: a } = t, o = Pe();
      let { duration: f } = t;
      const [h, m, p, A] = tn(
        [t.attack, t.decay, t.sustain, t.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), M = e + f, C = M + A + 0.01;
      let F = Ot(
        o,
        "byte-beat-processor",
        {
          frequency: s,
          begin: e,
          end: C
        },
        {
          outputChannelCount: [2]
        }
      );
      F.port.postMessage({ codeText: u, byteBeatStartTime: a, frequency: s });
      let _ = gt(1);
      _ = F.connect(_), en(_.gain, h, m, p, A, 0, 1, e, M, "linear");
      let k = Yr(
        o,
        () => {
          Fi(F), _.disconnect(), n();
        },
        e,
        C
      );
      return {
        node: _,
        stop: (L) => {
          k.stop(L);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), An(
    "pulse",
    (e, t, n) => {
      const r = Pe();
      let { pwrate: i, pwsweep: s } = t;
      s == null && (i != null ? s = 0.3 : s = 0), i == null && s != null && (i = 1);
      let { duration: u, pw: a = 0.5 } = t;
      const o = Kr(t), [f, h, m, p] = tn(
        [t.attack, t.decay, t.sustain, t.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), A = e + u, M = A + p + 0.01;
      let C = Ot(
        r,
        "pulse-oscillator",
        {
          frequency: o,
          begin: e,
          end: M,
          pulsewidth: a
        },
        {
          outputChannelCount: [2]
        }
      );
      ii(C.parameters.get("detune"), t, e, A);
      const F = si(C.parameters.get("detune"), t, e), _ = Li(C.parameters.get("frequency"), t, e);
      let k = gt(1);
      k = C.connect(k), en(k.gain, f, h, m, p, 0, 1, e, A, "linear");
      let L;
      s != 0 && (L = ns(r, e, M, { frequency: i, depth: s }), L.connect(C.parameters.get("pulsewidth")));
      let S = Yr(
        r,
        () => {
          Fi(C), Fi(L), k.disconnect(), n(), _?.stop(), F?.stop();
        },
        e,
        M
      );
      return {
        node: k,
        stop: (x) => {
          S.stop(x);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...sa].forEach((e) => {
    An(
      e,
      (t, n, r) => {
        const [i, s, u, a] = tn(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let o, { density: f } = n;
        o = pu(e, t, f);
        let { node: h, stop: m, triggerRelease: p } = o;
        const A = gt(0.3), { duration: M } = n;
        h.onended = () => {
          h.disconnect(), A.disconnect(), r();
        };
        const C = gt(1);
        let F = h.connect(A).connect(C);
        const _ = t + M;
        en(F.gain, i, s, u, a, 0, 1, t, _, "linear");
        const k = _ + a + 0.01;
        return p?.(k), m(k), {
          node: F,
          stop: (L) => {
            m(L);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), Av.forEach(([e, t]) => nn.set({ ...nn.get(), [e]: nn.get()[t] }));
}
function Xd(e, t) {
  const n = new Float32Array(e + 1), r = new Float32Array(e + 1), i = Pe(), s = i.createOscillator(), u = {
    sawtooth: (f) => [0, -1 / f],
    square: (f) => [0, f % 2 === 0 ? 0 : 1 / f],
    triangle: (f) => [f % 2 === 0 ? 0 : 1 / (f * f), 0]
  };
  if (!u[t])
    throw new Error(`unknown wave type ${t}`);
  n[0] = 0, r[0] = 0;
  let a = 1;
  for (; a <= e; ) {
    const [f, h] = u[t](a);
    n[a] = f, r[a] = h, a++;
  }
  const o = i.createPeriodicWave(n, r);
  return s.setPeriodicWave(o), s;
}
function Wd(e, t, n) {
  let { n: r, duration: i, noise: s = 0 } = n, u;
  !r || e === "sine" ? (u = Pe().createOscillator(), u.type = e || "triangle") : u = Xd(r, e), u.frequency.value = Kr(n), u.start(t);
  let a = si(u.detune, n, t);
  ii(u.detune, n, t, t + i);
  const o = Li(u.frequency, n, t);
  let f;
  return s && (f = GC(u, s, t)), {
    node: f?.node || u,
    stop: (h) => {
      o.stop(h), a?.stop(h), f?.stop(h), u.stop(h);
    },
    triggerRelease: (h) => {
    }
  };
}
function Mv(e = 1, t = 0.05, n = 220, r = 0, i = 0, s = 0.1, u = 0, a = 1, o = 0, f = 0, h = 0, m = 0, p = 0, A = 0, M = 0, C = 0, F = 0, _ = 1, k = 0, L = 0) {
  let S = Math.PI * 2, x = Pe().sampleRate, B = (ke) => ke > 0 ? 1 : -1, V = o *= 500 * S / x / x, T = n *= (1 + t * 2 * Math.random() - t) * S / x, H = [], X = 0, U = 0, O = 0, z = 1, te = 0, me = 0, pe = 0, le, ie;
  for (r = r * x + 9, k *= x, i *= x, s *= x, F *= x, f *= 500 * S / x ** 3, M *= S / x, h *= S / x, m *= x, p = p * x | 0, ie = r + k + i + s + F | 0; O < ie; H[O++] = pe)
    ++me % (C * 100 | 0) || (pe = u ? u > 1 ? u > 2 ? u > 3 ? Math.sin((X % S) ** 3) : Math.max(Math.min(Math.tan(X), 1), -1) : 1 - (2 * X / S % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(X / S) - X / S) : Math.sin(X), pe = (p ? 1 - L + L * Math.sin(S * O / p) : 1) * B(pe) * Math.abs(pe) ** a * // curve 0=square, 2=pointy
    e * 1 * // envelope
    (O < r ? O / r : O < r + k ? 1 - (O - r) / k * (1 - _) : O < r + k + i ? _ : O < ie - F ? (ie - O - F) / s * // release falloff
    _ : 0), pe = F ? pe / 2 + (F > O ? 0 : (O < ie - F ? 1 : (ie - O) / F) * // release delay
    H[O - F | 0] / 2) : pe), le = (n += o += f) * // frequency
    Math.cos(M * U++), X += le - le * A * (1 - (Math.sin(O) + 1) * 1e9 % 2), z && ++z > m && (n += h, T += h, z = 0), p && !(++te % p) && (n = T, o = V, z ||= 1);
  return H;
}
const Od = (e, t) => {
  let {
    s: n,
    note: r = 36,
    freq: i,
    //
    zrand: s = 0,
    attack: u = 0,
    decay: a = 0,
    sustain: o = 0.8,
    release: f = 0.1,
    curve: h = 1,
    slide: m = 0,
    deltaSlide: p = 0,
    pitchJump: A = 0,
    pitchJumpTime: M = 0,
    lfo: C = 0,
    znoise: F = 0,
    zmod: _ = 0,
    zcrush: k = 0,
    zdelay: L = 0,
    tremolo: S = 0,
    duration: x = 0.2,
    zzfx: B
  } = e;
  const V = Math.max(x - u - a, 0);
  typeof r == "string" && (r = ts(r)), !i && typeof r == "number" && (i = hd(r)), n = n.replace("z_", "");
  const T = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  h = n === "square" ? 0 : h;
  const X = (
    /* ZZFX. */
    Mv(...B || [
      0.25,
      // volume
      s,
      i,
      u,
      V,
      f,
      T,
      h,
      m,
      p,
      A,
      M,
      C,
      F,
      _,
      k,
      L,
      o,
      // sustain volume!
      a,
      S
    ])
  ), U = Pe(), O = U.createBuffer(1, X.length, U.sampleRate);
  O.getChannelData(0).set(X);
  const z = Pe().createBufferSource();
  return z.buffer = O, z.start(t), {
    node: z
  };
};
function Cv() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((e) => {
    An(
      e,
      (t, n, r) => {
        const { node: i } = Od({ s: e, ...n }, t);
        return i.onended = () => {
          i.disconnect(), r();
        }, {
          node: i,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let mr;
async function zd(e, t) {
  const n = `dsp-worklet-${Date.now()}`, r = `${t}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, s = `data:text/javascript;base64,${btoa(r)}`;
  await e.audioWorklet.addModule(s);
  const u = new AudioWorkletNode(e, n);
  return { node: u, stop: () => u.port.postMessage("stop") };
}
const jd = () => {
  mr && (mr?.stop(), mr?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (e) => {
  e.data === "strudel-stop" ? jd() : e.data?.dough && mr?.node.port.postMessage(e.data);
});
const vv = async (e) => {
  const t = Pe();
  jd(), mr = await zd(t, e), mr.node.connect(t.destination);
};
function $d(e, t, n, r) {
  window.postMessage({ time: r, dough: e.value, currentTime: t, duration: e.duration, cps: n });
}
const { Pattern: Pv, logger: Dv, repl: Fv } = cd;
fd(Dv);
const Ev = (e) => (e.ensureObjectValue(), e.value), qd = (e, t, n, r, i) => fa(Ev(e), i, n, r, e.whole?.begin.valueOf());
function Hd(e = {}) {
  return e = {
    getTime: () => Pe().currentTime,
    defaultOutput: qd,
    ...e
  }, Fv(e);
}
Pv.prototype.dough = function() {
  return this.onTrigger($d, 1);
};
const Qn = (e = "test-canvas", t) => {
  let { contextType: n = "2d", pixelated: r = !1, pixelRatio: i = window.devicePixelRatio } = {}, s = document.querySelector("#" + e);
  if (!s) {
    s = document.createElement("canvas"), s.id = e, s.width = window.innerWidth * i, s.height = window.innerHeight * i, s.style = "pointer-events:none;width:100%;height:100%;position:fixed;top:0;left:0", r && (s.style.imageRendering = "pixelated"), document.body.prepend(s);
    let u;
    window.addEventListener("resize", () => {
      u && clearTimeout(u), u = setTimeout(() => {
        s.width = window.innerWidth * i, s.height = window.innerHeight * i;
      }, 200);
    });
  }
  return s.getContext(n, { willReadFrequently: !0 });
};
let Jr = {};
function xv(e) {
  Jr[e] !== void 0 && (cancelAnimationFrame(Jr[e]), delete Jr[e]);
}
let gn = {};
$.prototype.draw = function(e, t) {
  if (typeof window > "u")
    return this;
  let { id: n = 1, lookbehind: r = 0, lookahead: i = 0 } = t, s = Math.max(hu(), 0);
  xv(n), r = Math.abs(r), gn[n] = (gn[n] || []).filter((f) => !f.isInFuture(s));
  let u = this.queryArc(s, s + i).filter((f) => f.hasOnset());
  gn[n] = gn[n].concat(u);
  let a;
  const o = () => {
    const f = hu(), h = f + i;
    gn[n] = gn[n].filter((A) => A.isInNearPast(r, f));
    let m = Math.max(a || h, h - 1 / 10);
    const p = this.queryArc(m, h).filter((A) => A.hasOnset());
    gn[n] = gn[n].concat(p), a = h, e(gn[n], f, h, this), Jr[n] = requestAnimationFrame(o);
  };
  return Jr[n] = requestAnimationFrame(o), this;
};
$.prototype.onPaint = function(e) {
  return this.withState((t) => {
    t.controls.painters || (t.controls.painters = []), t.controls.painters.push(e);
  });
};
$.prototype.getPainters = function() {
  let e = [];
  return this.queryArc(0, 0, { painters: e }), e;
};
let wv = {
  background: "#222",
  foreground: "#75baff",
  caret: "#ffcc00",
  selection: "rgba(128, 203, 196, 0.5)",
  selectionMatch: "#036dd626",
  lineHighlight: "#00000050",
  gutterBackground: "transparent",
  gutterForeground: "#8a919966"
};
function Cn() {
  return wv;
}
let bo = "#22222210";
$.prototype.animate = function({ callback: e, sync: t = !1, smear: n = 0.5 } = {}) {
  window.frame && cancelAnimationFrame(window.frame);
  const r = Qn();
  let { clientWidth: i, clientHeight: s } = r.canvas;
  i *= window.devicePixelRatio, s *= window.devicePixelRatio;
  let u = n === 0 ? "99" : Number((1 - n) * 100).toFixed(0);
  u = u.length === 1 ? `0${u}` : u, bo = `#200010${u}`;
  const a = (o) => {
    let f;
    o = Math.round(o), f = this.slow(1e3).queryArc(o, o), r.fillStyle = bo, r.fillRect(0, 0, i, s), f.forEach((h) => {
      let { x: m, y: p, w: A, h: M, s: C, r: F, angle: _ = 0, fill: k = "darkseagreen" } = h.value;
      if (A *= i, M *= s, F !== void 0 && _ !== void 0) {
        const S = _ * 2 * Math.PI, [x, B] = [(i - A) / 2, (s - M) / 2];
        m = x + Math.cos(S) * F * x, p = B + Math.sin(S) * F * B;
      } else
        m *= i - A, p *= s - M;
      const L = { ...h.value, x: m, y: p, w: A, h: M };
      r.fillStyle = k, C === "rect" ? r.fillRect(m, p, A, M) : C === "ellipse" && (r.beginPath(), r.ellipse(m + A / 2, p + M / 2, A / 2, M / 2, 0, 0, 2 * Math.PI), r.fill()), e && e(r, L, h);
    }), window.frame = requestAnimationFrame(a);
  };
  return window.frame = requestAnimationFrame(a), Se;
};
const { x: Kd, y: gE, w: yE, h: AE, angle: bE, r: ME, fill: CE, smear: vE } = zu("x", "y", "w", "h", "angle", "r", "fill", "smear");
N("rescale", function(e, t) {
  return t.mul(Kd(e).w(e).y(e).h(e));
});
N("moveXY", function(e, t, n) {
  return n.add(Kd(e).y(t));
});
N("zoomIn", function(e, t) {
  const n = Je(1).sub(e).div(2);
  return t.rescale(e).move(n, n);
});
const Zr = (e, t, n) => e * (n - t) + t, Mo = (e) => {
  let { value: t } = e;
  typeof e.value != "object" && (t = { value: t });
  let { note: n, n: r, freq: i, s } = t;
  if (i)
    return Bu(i);
  if (n = n ?? r, typeof n == "string")
    try {
      return Ln(n);
    } catch {
      return 0;
    }
  return typeof n == "number" ? n : s ? "_" + s : t;
};
$.prototype.pianoroll = function(e = {}) {
  let { cycles: t = 4, playhead: n = 0.5, overscan: r = 0, hideNegative: i = !1, ctx: s = Qn(), id: u = 1 } = e, a = -t * n, o = t * (1 - n);
  const f = (h, m) => (!i || h.whole.begin >= 0) && h.isWithinTime(m + a, m + o);
  return this.draw(
    (h, m) => {
      Yd({
        ...e,
        time: m,
        ctx: s,
        haps: h.filter((p) => f(p, m))
      });
    },
    {
      lookbehind: a - r,
      lookahead: o + r,
      id: u
    }
  ), this;
};
function Yd({
  time: e,
  haps: t,
  cycles: n = 4,
  playhead: r = 0.5,
  flipTime: i = 0,
  flipValues: s = 0,
  hideNegative: u = !1,
  inactive: a = Cn().foreground,
  active: o = Cn().foreground,
  background: f = "transparent",
  smear: h = 0,
  playheadColor: m = Cn().foreground,
  minMidi: p = 10,
  maxMidi: A = 90,
  autorange: M = 0,
  timeframe: C,
  fold: F = 1,
  vertical: _ = 0,
  labels: k = !1,
  fill: L = 1,
  fillActive: S = !1,
  strokeActive: x = !0,
  stroke: B,
  hideInactive: V = 0,
  colorizeInactive: T = 1,
  fontFamily: H,
  ctx: X,
  id: U
} = {}) {
  const O = X.canvas.width, z = X.canvas.height;
  let te = -n * r, me = n * (1 - r);
  U && (t = t.filter((Ee) => Ee.hasTag(U))), C && (console.warn("timeframe is deprecated! use from/to instead"), te = 0, me = C);
  const pe = _ ? z : O, le = _ ? O : z;
  let ie = _ ? [pe, 0] : [0, pe];
  const ke = me - te, et = _ ? [0, le] : [le, 0];
  let oe = A - p + 1, W = le / oe, $e = [];
  i && ie.reverse(), s && et.reverse();
  const { min: xe, max: tt, values: ge } = t.reduce(
    ({ min: Ee, max: Ke, values: Ft }, bt) => {
      const Ve = Mo(bt);
      return {
        min: Ve < Ee ? Ve : Ee,
        max: Ve > Ke ? Ve : Ke,
        values: Ft.includes(Ve) ? Ft : [...Ft, Ve]
      };
    },
    { min: 1 / 0, max: -1 / 0, values: [] }
  );
  M && (p = xe, A = tt, oe = A - p + 1), $e = ge.sort(
    (Ee, Ke) => typeof Ee == "number" && typeof Ke == "number" ? Ee - Ke : typeof Ee == "number" ? 1 : String(Ee).localeCompare(String(Ke))
  ), W = F ? le / $e.length : le / oe, X.fillStyle = f, X.globalAlpha = 1, h || (X.clearRect(0, 0, O, z), X.fillRect(0, 0, O, z)), t.forEach((Ee) => {
    const Ke = Ee.whole.begin <= e && Ee.endClipped > e;
    let Ft = B ?? (x && Ke), bt = !Ke && L || Ke && S;
    if (V && !Ke)
      return;
    let Ve = Ee.value?.color;
    o = Ve || o, a = T && Ve || a, Ve = Ke ? o : a, X.fillStyle = bt ? Ve : "transparent", X.strokeStyle = Ve;
    const { velocity: En = 1, gain: Ge = 1 } = Ee.value || {};
    X.globalAlpha = En * Ge;
    const Yt = (Ee.whole.begin - (i ? me : te)) / ke, dt = Zr(Yt, ...ie);
    let Et = Zr(Ee.duration / ke, 0, pe);
    const Nt = Mo(Ee), xn = F ? $e.indexOf(Nt) / $e.length : (Number(Nt) - p) / oe, Jt = Zr(xn, ...et);
    let ln = 0;
    const fn = Zr(e / ke, ...ie);
    let ct;
    if (_ ? ct = [
      Jt + 1 - (s ? W : 0),
      // x
      pe - fn + dt + ln + 1 - (i ? 0 : Et),
      // y
      W - 2,
      // width
      Et - 2
      // height
    ] : ct = [
      dt - fn + ln + 1 - (i ? Et : 0),
      // x
      Jt + 1 - (s ? 0 : W),
      // y
      Et - 2,
      // widith
      W - 2
      // height
    ], Ft && X.strokeRect(...ct), bt && X.fillRect(...ct), k) {
      const hn = Ee.value.note ?? Ee.value.s + (Ee.value.n ? `:${Ee.value.n}` : ""), { label: be, activeLabel: _e } = Ee.value, Oe = (Ke && _e || be) ?? hn;
      let Be = _ ? Et : W * 0.75;
      X.font = `${Be}px ${H || "monospace"}`, X.fillStyle = /* isActive &&  */
      bt ? "black" : Ve, X.textBaseline = "top", X.fillText(Oe, ...ct);
    }
  }), X.globalAlpha = 1;
  const qe = Zr(-te / ke, ...ie);
  return X.strokeStyle = m, X.beginPath(), _ ? (X.moveTo(0, qe), X.lineTo(le, qe)) : (X.moveTo(qe, 0), X.lineTo(qe, le)), X.stroke(), this;
}
function Sv(e, t = {}) {
  let [n, r] = e;
  n = Math.abs(n);
  const i = r + n, s = i !== 0 ? n / i : 0;
  return { fold: 1, ...t, cycles: i, playhead: s };
}
const Bv = (e = {}) => (t, n, r, i) => Yd({ ctx: t, time: n, haps: r, ...Sv(i, e) });
$.prototype.punchcard = function(e) {
  return this.onPaint(Bv(e));
};
$.prototype.wordfall = function(e) {
  return this.punchcard({ vertical: 1, labels: 1, stroke: 0, fillActive: 1, active: "white", ...e });
};
function _v(e, t, n, r) {
  const i = (e - 90) * Math.PI / 180;
  return [n + Math.cos(i) * t, r + Math.sin(i) * t];
}
const Co = (e, t, n, r, i = 0) => _v((e + i) * 360, t * e, n, r);
function vo(e) {
  let {
    ctx: t,
    from: n = 0,
    to: r = 3,
    margin: i = 50,
    cx: s = 100,
    cy: u = 100,
    rotate: a = 0,
    thickness: o = i / 2,
    color: f = Cn().foreground,
    cap: h = "round",
    stretch: m = 1,
    fromOpacity: p = 1,
    toOpacity: A = 1
  } = e;
  n *= m, r *= m, a *= m, t.lineWidth = o, t.lineCap = h, t.strokeStyle = f, t.globalAlpha = p, t.beginPath();
  let [M, C] = Co(n, i, s, u, a);
  t.moveTo(M, C);
  const F = 1 / 60;
  let _ = n;
  for (; _ <= r; ) {
    const [k, L] = Co(_, i, s, u, a);
    t.globalAlpha = (_ - n) / (r - n) * A, t.lineTo(k, L), _ += F;
  }
  t.stroke();
}
function kv(e) {
  let {
    stretch: t = 1,
    size: n = 80,
    thickness: r = n / 2,
    cap: i = "butt",
    // round butt squar,
    inset: s = 3,
    // start angl,
    playheadColor: u = "#ffffff",
    playheadLength: a = 0.02,
    playheadThickness: o = r,
    padding: f = 0,
    steady: h = 1,
    activeColor: m = Cn().foreground,
    inactiveColor: p = Cn().gutterForeground,
    colorizeInactive: A = 0,
    fade: M = !0,
    // logSpiral = true,
    ctx: C,
    time: F,
    haps: _,
    drawTime: k,
    id: L
  } = e;
  L && (_ = _.filter((O) => O.hasTag(L)));
  const [S, x] = [C.canvas.width, C.canvas.height];
  C.clearRect(0, 0, S * 2, x * 2);
  const [B, V] = [S / 2, x / 2], T = {
    margin: n / t,
    cx: B,
    cy: V,
    stretch: t,
    cap: i,
    thickness: r
  }, H = {
    ...T,
    thickness: o,
    from: s - a,
    to: s,
    color: u
  }, [X] = k, U = h * F;
  _.forEach((O) => {
    const z = O.whole.begin <= F && O.endClipped > F, te = O.whole.begin - F + s, me = O.endClipped - F + s - f, pe = O.value?.color || m, le = A || z ? pe : p, ie = M ? 1 - Math.abs((O.whole.begin - F) / X) : 1;
    vo({
      ctx: C,
      ...T,
      from: te,
      to: me,
      rotate: U,
      color: le,
      fromOpacity: ie,
      toOpacity: ie
    });
  }), vo({
    ctx: C,
    ...H,
    rotate: U
  });
}
$.prototype.spiral = function(e = {}) {
  return this.onPaint((t, n, r, i) => kv({ ctx: t, time: n, haps: r, drawTime: i, ...e }));
};
const Vv = Hn(36), Po = (e, t, n, r) => {
  r = r * Math.PI * 2;
  const i = Math.sin(r) * n + e, s = Math.cos(r) * n + t;
  return [i, s];
}, Do = (e, t) => 0.5 - Math.log2(e / t) % 1;
function Iv({
  haps: e,
  ctx: t,
  id: n,
  hapcircles: r = 1,
  circle: i = 0,
  edo: s = 12,
  root: u = Vv,
  thickness: a = 3,
  hapRadius: o = 6,
  mode: f = "flake",
  margin: h = 10
} = {}) {
  const m = f === "polygon", p = f === "flake", A = t.canvas.width, M = t.canvas.height;
  t.clearRect(0, 0, A, M);
  const C = Cn().foreground, _ = Math.min(A, M) / 2 - a / 2 - o - h, k = A / 2, L = M / 2;
  n && (e = e.filter((x) => x.hasTag(n))), t.strokeStyle = C, t.fillStyle = C, t.globalAlpha = 1, t.lineWidth = a, i && (t.beginPath(), t.arc(k, L, _, 0, 2 * Math.PI), t.stroke()), s && (Array.from({ length: s }, (x, B) => {
    const V = Do(u * Math.pow(2, B / s), u), [T, H] = Po(k, L, _, V);
    t.beginPath(), t.arc(T, H, o, 0, 2 * Math.PI), t.fill();
  }), t.stroke());
  let S = [];
  t.lineWidth = o, e.forEach((x) => {
    let B;
    try {
      B = Ec(x);
    } catch {
      return;
    }
    const V = Do(B, u), [T, H] = Po(k, L, _, V), X = x.value.color || C;
    t.strokeStyle = X, t.fillStyle = X;
    const { velocity: U = 1, gain: O = 1 } = x.value || {}, z = U * O;
    t.globalAlpha = z, S.push([T, H, V, X, z]), t.beginPath(), r && (t.moveTo(T + o, H), t.arc(T, H, o, 0, 2 * Math.PI), t.fill()), p && (t.moveTo(k, L), t.lineTo(T, H)), t.stroke();
  }), t.strokeStyle = C, t.globalAlpha = 1, m && S.length && (S = S.sort((x, B) => x[2] - B[2]), t.beginPath(), t.moveTo(S[0][0], S[0][1]), S.forEach(([x, B, V, T, H]) => {
    t.strokeStyle = T, t.globalAlpha = H, t.lineTo(x, B);
  }), t.lineTo(S[0][0], S[0][1]), t.stroke());
}
$.prototype.pitchwheel = function(e = {}) {
  let { ctx: t = Qn(), id: n = 1 } = e;
  return this.tag(n).onPaint(
    (r, i, s) => Iv({
      ...e,
      time: i,
      ctx: t,
      haps: s.filter((u) => u.isActive(i)),
      id: n
    })
  );
};
function Jd(e, {
  align: t = !0,
  color: n = "white",
  thickness: r = 3,
  scale: i = 0.25,
  pos: s = 0.75,
  trigger: u = 0,
  ctx: a = Qn(),
  id: o = 1
} = {}) {
  a.lineWidth = r, a.strokeStyle = n;
  let f = a.canvas;
  if (!e) {
    a.beginPath();
    let C = s * f.height;
    a.moveTo(0, C), a.lineTo(f.width, C), a.stroke();
    return;
  }
  const h = rs("time", o);
  a.beginPath();
  const m = e.frequencyBinCount;
  let p = t ? Array.from(h).findIndex((C, F, _) => F && _[F - 1] > -u && C <= -u) : 0;
  p = Math.max(p, 0);
  const A = f.width * 1 / m;
  let M = 0;
  for (let C = p; C < m; C++) {
    const F = h[C] + 1, _ = (s - i * (F - 1)) * f.height;
    C === 0 ? a.moveTo(M, _) : a.lineTo(M, _), M += A;
  }
  a.stroke();
}
function Ud(e, { color: t = "white", scale: n = 0.25, pos: r = 0.75, lean: i = 0.5, min: s = -150, max: u = 0, ctx: a = Qn(), id: o = 1 } = {}) {
  if (!e) {
    a.beginPath();
    let M = r * h.height;
    a.moveTo(0, M), a.lineTo(h.width, M), a.stroke();
    return;
  }
  const f = rs("frequency", o), h = a.canvas;
  a.fillStyle = t;
  const m = e.frequencyBinCount, p = h.width * 1 / m;
  let A = 0;
  for (let M = 0; M < m; M++) {
    const F = Hi((f[M] - s) / (u - s), 0, 1) * n, _ = F * h.height, k = (r - F * i) * h.height;
    a.fillRect(A, k, Math.max(p, 1), _), A += p;
  }
}
function Qd(e = 0, t = "0,0,0", n = Qn()) {
  e ? (n.fillStyle = `rgba(${t},${1 - e})`, n.fillRect(0, 0, n.canvas.width, n.canvas.height)) : n.clearRect(0, 0, n.canvas.width, n.canvas.height);
}
$.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      Qd(e.smear, "0,0,0", e.ctx), ft[t] && Ud(ft[t], e);
    },
    { id: t }
  );
};
$.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (n) => {
      e.color = n[0]?.value?.color || Cn().foreground, e.color, Qd(e.smear, "0,0,0", e.ctx), Jd(ft[t], e);
    },
    { id: t }
  );
};
$.prototype.scope = $.prototype.tscope;
let Fo = {};
$.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (n) => {
      e.color = n[0]?.value?.color || Fo[t] || Cn().foreground, Fo[t] = e.color, Tv(ft[t], e);
    },
    { id: t }
  );
};
$.prototype.scope = $.prototype.tscope;
const Ns = /* @__PURE__ */ new Map();
function Tv(e, { thickness: t = 3, speed: n = 1, min: r = -80, max: i = 0, ctx: s = Qn(), id: u = 1, color: a } = {}) {
  if (s.lineWidth = t, s.strokeStyle = a, !e)
    return;
  const o = n, f = rs("frequency", u), h = s.canvas;
  s.fillStyle = a;
  const m = e.frequencyBinCount;
  let p = Ns.get(u) || s.getImageData(0, 0, h.width, h.height);
  Ns.set(u, p), s.clearRect(0, 0, s.canvas.width, s.canvas.height), s.putImageData(p, -o, 0);
  let A = h.width - n;
  for (let M = 0; M < m; M++) {
    const C = Hi((f[M] - r) / (i - r), 0, 1);
    s.globalAlpha = C;
    const F = Math.log(M + 1) / Math.log(m) * h.height;
    s.fillRect(A, h.height - F, o, 2);
  }
  Ns.set(u, s.getImageData(0, 0, h.width, h.height));
}
const Nv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_MAX_POLYPHONY: oa,
  aliasBank: QC,
  get analysers() {
    return ft;
  },
  get analysersData() {
    return zn;
  },
  applyFM: Li,
  applyGainCurve: yn,
  connectToDestination: Rd,
  createFilter: wi,
  dough: vv,
  doughTrigger: $d,
  drawFrequencyScope: Ud,
  drawTimeScope: Jd,
  drywet: gd,
  dspWorklet: zd,
  errorLogger: ia,
  gainNode: gt,
  getADSRValues: tn,
  getAnalyserById: Gd,
  getAnalyzerData: rs,
  getAudioContext: Pe,
  getAudioContextCurrentTime: uv,
  getAudioDevices: kd,
  getCachedBuffer: jC,
  getCompressor: md,
  getDefaultValue: Ye,
  getLfo: ns,
  getLoadedBuffer: qC,
  getOscillator: Wd,
  getParamADSR: en,
  getPitchEnvelope: ii,
  getSampleBuffer: Ad,
  getSampleBufferSource: bd,
  getSampleInfo: yd,
  getSound: Si,
  getVibratoOscillator: si,
  getWorklet: Ot,
  getZZFX: Od,
  initAudio: Td,
  initAudioOnFirstClick: Nd,
  initializeAudioOutput: Ld,
  loadBuffer: aa,
  logger: Pt,
  noises: sa,
  onTriggerSample: Ed,
  panic: ov,
  processSampleMap: Pd,
  registerSamplesPrefix: HC,
  registerSound: An,
  registerSynthSounds: Zd,
  registerZZFXSounds: Cv,
  resetDefaultValues: Vd,
  resetDefaults: nv,
  resetGlobalEffects: mv,
  resetLoadedSounds: sv,
  reverseBuffer: Md,
  samples: Fd,
  setDefault: tv,
  setDefaultAudioContext: Id,
  setDefaultValue: la,
  setDefaultValues: rv,
  setGainCurve: JC,
  setLogger: fd,
  setMaxPolyphony: wd,
  setMultiChannelOrbits: Bd,
  setVersionDefaults: iv,
  soundMap: nn,
  superdough: fa,
  superdoughTrigger: gv,
  waveformN: Xd,
  webAudioTimeout: Yr,
  webaudioOutput: qd,
  webaudioRepl: Hd
}, Symbol.toStringTag, { value: "Module" }));
function Lv(e, t) {
  function n() {
    this.constructor = e;
  }
  n.prototype = t.prototype, e.prototype = new n();
}
function Yn(e, t, n, r) {
  var i = Error.call(this, e);
  return Object.setPrototypeOf && Object.setPrototypeOf(i, Yn.prototype), i.expected = t, i.found = n, i.location = r, i.name = "SyntaxError", i;
}
Lv(Yn, Error);
function Ls(e, t, n) {
  return n = n || " ", e.length > t ? e : (t -= e.length, n += n.repeat(t), e + n.slice(0, t));
}
Yn.prototype.format = function(e) {
  var t = "Error: " + this.message;
  if (this.location) {
    var n = null, r;
    for (r = 0; r < e.length; r++)
      if (e[r].source === this.location.source) {
        n = e[r].text.split(/\r\n|\n|\r/g);
        break;
      }
    var i = this.location.start, s = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i, u = this.location.source + ":" + s.line + ":" + s.column;
    if (n) {
      var a = this.location.end, o = Ls("", s.line.toString().length, " "), f = n[i.line - 1], h = i.line === a.line ? a.column : f.length + 1, m = h - i.column || 1;
      t += `
 --> ` + u + `
` + o + ` |
` + s.line + " | " + f + `
` + o + " | " + Ls("", i.column - 1, " ") + Ls("", m, "^");
    } else
      t += `
 at ` + u;
  }
  return t;
};
Yn.buildMessage = function(e, t) {
  var n = {
    literal: function(f) {
      return '"' + i(f.text) + '"';
    },
    class: function(f) {
      var h = f.parts.map(function(m) {
        return Array.isArray(m) ? s(m[0]) + "-" + s(m[1]) : s(m);
      });
      return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
    },
    any: function() {
      return "any character";
    },
    end: function() {
      return "end of input";
    },
    other: function(f) {
      return f.description;
    }
  };
  function r(f) {
    return f.charCodeAt(0).toString(16).toUpperCase();
  }
  function i(f) {
    return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
      return "\\x0" + r(h);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
      return "\\x" + r(h);
    });
  }
  function s(f) {
    return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
      return "\\x0" + r(h);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
      return "\\x" + r(h);
    });
  }
  function u(f) {
    return n[f.type](f);
  }
  function a(f) {
    var h = f.map(u), m, p;
    if (h.sort(), h.length > 0) {
      for (m = 1, p = 1; m < h.length; m++)
        h[m - 1] !== h[m] && (h[p] = h[m], p++);
      h.length = p;
    }
    switch (h.length) {
      case 1:
        return h[0];
      case 2:
        return h[0] + " or " + h[1];
      default:
        return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
    }
  }
  function o(f) {
    return f ? '"' + i(f) + '"' : "end of input";
  }
  return "Expected " + a(e) + " but " + o(t) + " found.";
};
function em(e, t) {
  t = t !== void 0 ? t : {};
  var n = {}, r = t.grammarSource, i = { start: Qa }, s = Qa, u = ".", a = "-", o = "0", f = ",", h = "|", m = "[", p = "]", A = "{", M = "}", C = "%", F = "<", _ = ">", k = "!", L = "(", S = ")", x = "/", B = "*", V = "?", T = ":", H = "..", X = "^", U = "struct", O = "target", z = "euclid", te = "slow", me = "rotL", pe = "rotR", le = "fast", ie = "scale", ke = "//", et = "cat", oe = "$", W = "setcps", $e = "setbpm", xe = "hush", tt = /^[1-9]/, ge = /^[eE]/, qe = /^[+\-]/, Ee = /^[0-9]/, Ke = /^[ \n\r\t\xA0]/, Ft = /^["']/, bt = /^[#\--.0-9A-Z\^-_a-z~\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376-\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4-\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u09FC\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60-\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD-\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, Ve = /^[@_]/, En = /^[^\n]/, Ge = Es("number"), Yt = Ce(".", !1), dt = pn([["1", "9"]], !1, !1), Et = pn(["e", "E"], !1, !1), Nt = pn(["+", "-"], !1, !1), xn = Ce("-", !1), Jt = Ce("0", !1), ln = pn([["0", "9"]], !1, !1), fn = Es("whitespace"), ct = pn([" ", `
`, "\r", "	", " "], !1, !1), hn = Ce(",", !1), be = Ce("|", !1), _e = pn(['"', "'"], !1, !1), Q = Es('a letter, a number, "-", "#", ".", "^", "_"'), Oe = pn(["#", ["-", "."], ["0", "9"], ["A", "Z"], ["^", "_"], ["a", "z"], "~", "ª", "µ", "º", ["À", "Ö"], ["Ø", "ö"], ["ø", "ˁ"], ["ˆ", "ˑ"], ["ˠ", "ˤ"], "ˬ", "ˮ", ["Ͱ", "ʹ"], ["Ͷ", "ͷ"], ["ͺ", "ͽ"], "Ϳ", "Ά", ["Έ", "Ί"], "Ό", ["Ύ", "Ρ"], ["Σ", "ϵ"], ["Ϸ", "ҁ"], ["Ҋ", "ԯ"], ["Ա", "Ֆ"], "ՙ", ["ՠ", "ֈ"], ["א", "ת"], ["ׯ", "ײ"], ["ؠ", "ي"], ["ٮ", "ٯ"], ["ٱ", "ۓ"], "ە", ["ۥ", "ۦ"], ["ۮ", "ۯ"], ["ۺ", "ۼ"], "ۿ", "ܐ", ["ܒ", "ܯ"], ["ݍ", "ޥ"], "ޱ", ["ߊ", "ߪ"], ["ߴ", "ߵ"], "ߺ", ["ࠀ", "ࠕ"], "ࠚ", "ࠤ", "ࠨ", ["ࡀ", "ࡘ"], ["ࡠ", "ࡪ"], ["ࢠ", "ࢴ"], ["ࢶ", "ࢽ"], ["ऄ", "ह"], "ऽ", "ॐ", ["क़", "ॡ"], ["ॱ", "ঀ"], ["অ", "ঌ"], ["এ", "ঐ"], ["ও", "ন"], ["প", "র"], "ল", ["শ", "হ"], "ঽ", "ৎ", ["ড়", "ঢ়"], ["য়", "ৡ"], ["ৰ", "ৱ"], "ৼ", ["ਅ", "ਊ"], ["ਏ", "ਐ"], ["ਓ", "ਨ"], ["ਪ", "ਰ"], ["ਲ", "ਲ਼"], ["ਵ", "ਸ਼"], ["ਸ", "ਹ"], ["ਖ਼", "ੜ"], "ਫ਼", ["ੲ", "ੴ"], ["અ", "ઍ"], ["એ", "ઑ"], ["ઓ", "ન"], ["પ", "ર"], ["લ", "ળ"], ["વ", "હ"], "ઽ", "ૐ", ["ૠ", "ૡ"], "ૹ", ["ଅ", "ଌ"], ["ଏ", "ଐ"], ["ଓ", "ନ"], ["ପ", "ର"], ["ଲ", "ଳ"], ["ଵ", "ହ"], "ଽ", ["ଡ଼", "ଢ଼"], ["ୟ", "ୡ"], "ୱ", "ஃ", ["அ", "ஊ"], ["எ", "ஐ"], ["ஒ", "க"], ["ங", "ச"], "ஜ", ["ஞ", "ட"], ["ண", "த"], ["ந", "ப"], ["ம", "ஹ"], "ௐ", ["అ", "ఌ"], ["ఎ", "ఐ"], ["ఒ", "న"], ["ప", "హ"], "ఽ", ["ౘ", "ౚ"], ["ౠ", "ౡ"], "ಀ", ["ಅ", "ಌ"], ["ಎ", "ಐ"], ["ಒ", "ನ"], ["ಪ", "ಳ"], ["ವ", "ಹ"], "ಽ", "ೞ", ["ೠ", "ೡ"], ["ೱ", "ೲ"], ["അ", "ഌ"], ["എ", "ഐ"], ["ഒ", "ഺ"], "ഽ", "ൎ", ["ൔ", "ൖ"], ["ൟ", "ൡ"], ["ൺ", "ൿ"], ["අ", "ඖ"], ["ක", "න"], ["ඳ", "ර"], "ල", ["ව", "ෆ"], ["ก", "ะ"], ["า", "ำ"], ["เ", "ๆ"], ["ກ", "ຂ"], "ຄ", ["ງ", "ຈ"], "ຊ", "ຍ", ["ດ", "ທ"], ["ນ", "ຟ"], ["ມ", "ຣ"], "ລ", "ວ", ["ສ", "ຫ"], ["ອ", "ະ"], ["າ", "ຳ"], "ຽ", ["ເ", "ໄ"], "ໆ", ["ໜ", "ໟ"], "ༀ", ["ཀ", "ཇ"], ["ཉ", "ཬ"], ["ྈ", "ྌ"], ["က", "ဪ"], "ဿ", ["ၐ", "ၕ"], ["ၚ", "ၝ"], "ၡ", ["ၥ", "ၦ"], ["ၮ", "ၰ"], ["ၵ", "ႁ"], "ႎ", ["Ⴀ", "Ⴥ"], "Ⴧ", "Ⴭ", ["ა", "ჺ"], ["ჼ", "ቈ"], ["ቊ", "ቍ"], ["ቐ", "ቖ"], "ቘ", ["ቚ", "ቝ"], ["በ", "ኈ"], ["ኊ", "ኍ"], ["ነ", "ኰ"], ["ኲ", "ኵ"], ["ኸ", "ኾ"], "ዀ", ["ዂ", "ዅ"], ["ወ", "ዖ"], ["ዘ", "ጐ"], ["ጒ", "ጕ"], ["ጘ", "ፚ"], ["ᎀ", "ᎏ"], ["Ꭰ", "Ᏽ"], ["ᏸ", "ᏽ"], ["ᐁ", "ᙬ"], ["ᙯ", "ᙿ"], ["ᚁ", "ᚚ"], ["ᚠ", "ᛪ"], ["ᛮ", "ᛸ"], ["ᜀ", "ᜌ"], ["ᜎ", "ᜑ"], ["ᜠ", "ᜱ"], ["ᝀ", "ᝑ"], ["ᝠ", "ᝬ"], ["ᝮ", "ᝰ"], ["ក", "ឳ"], "ៗ", "ៜ", ["ᠠ", "ᡸ"], ["ᢀ", "ᢄ"], ["ᢇ", "ᢨ"], "ᢪ", ["ᢰ", "ᣵ"], ["ᤀ", "ᤞ"], ["ᥐ", "ᥭ"], ["ᥰ", "ᥴ"], ["ᦀ", "ᦫ"], ["ᦰ", "ᧉ"], ["ᨀ", "ᨖ"], ["ᨠ", "ᩔ"], "ᪧ", ["ᬅ", "ᬳ"], ["ᭅ", "ᭋ"], ["ᮃ", "ᮠ"], ["ᮮ", "ᮯ"], ["ᮺ", "ᯥ"], ["ᰀ", "ᰣ"], ["ᱍ", "ᱏ"], ["ᱚ", "ᱽ"], ["ᲀ", "ᲈ"], ["Ა", "Ჺ"], ["Ჽ", "Ჿ"], ["ᳩ", "ᳬ"], ["ᳮ", "ᳱ"], ["ᳵ", "ᳶ"], ["ᴀ", "ᶿ"], ["Ḁ", "ἕ"], ["Ἐ", "Ἕ"], ["ἠ", "ὅ"], ["Ὀ", "Ὅ"], ["ὐ", "ὗ"], "Ὑ", "Ὓ", "Ὕ", ["Ὗ", "ώ"], ["ᾀ", "ᾴ"], ["ᾶ", "ᾼ"], "ι", ["ῂ", "ῄ"], ["ῆ", "ῌ"], ["ῐ", "ΐ"], ["ῖ", "Ί"], ["ῠ", "Ῥ"], ["ῲ", "ῴ"], ["ῶ", "ῼ"], "ⁱ", "ⁿ", ["ₐ", "ₜ"], "ℂ", "ℇ", ["ℊ", "ℓ"], "ℕ", ["ℙ", "ℝ"], "ℤ", "Ω", "ℨ", ["K", "ℭ"], ["ℯ", "ℹ"], ["ℼ", "ℿ"], ["ⅅ", "ⅉ"], "ⅎ", ["Ⅰ", "ↈ"], ["Ⰰ", "Ⱞ"], ["ⰰ", "ⱞ"], ["Ⱡ", "ⳤ"], ["Ⳬ", "ⳮ"], ["Ⳳ", "ⳳ"], ["ⴀ", "ⴥ"], "ⴧ", "ⴭ", ["ⴰ", "ⵧ"], "ⵯ", ["ⶀ", "ⶖ"], ["ⶠ", "ⶦ"], ["ⶨ", "ⶮ"], ["ⶰ", "ⶶ"], ["ⶸ", "ⶾ"], ["ⷀ", "ⷆ"], ["ⷈ", "ⷎ"], ["ⷐ", "ⷖ"], ["ⷘ", "ⷞ"], "ⸯ", ["々", "〇"], ["〡", "〩"], ["〱", "〵"], ["〸", "〼"], ["ぁ", "ゖ"], ["ゝ", "ゟ"], ["ァ", "ヺ"], ["ー", "ヿ"], ["ㄅ", "ㄯ"], ["ㄱ", "ㆎ"], ["ㆠ", "ㆺ"], ["ㇰ", "ㇿ"], ["㐀", "䶵"], ["一", "鿯"], ["ꀀ", "ꒌ"], ["ꓐ", "ꓽ"], ["ꔀ", "ꘌ"], ["ꘐ", "ꘟ"], ["ꘪ", "ꘫ"], ["Ꙁ", "ꙮ"], ["ꙿ", "ꚝ"], ["ꚠ", "ꛯ"], ["ꜗ", "ꜟ"], ["Ꜣ", "ꞈ"], ["Ꞌ", "ꞹ"], ["ꟷ", "ꠁ"], ["ꠃ", "ꠅ"], ["ꠇ", "ꠊ"], ["ꠌ", "ꠢ"], ["ꡀ", "ꡳ"], ["ꢂ", "ꢳ"], ["ꣲ", "ꣷ"], "ꣻ", ["ꣽ", "ꣾ"], ["ꤊ", "ꤥ"], ["ꤰ", "ꥆ"], ["ꥠ", "ꥼ"], ["ꦄ", "ꦲ"], "ꧏ", ["ꧠ", "ꧤ"], ["ꧦ", "ꧯ"], ["ꧺ", "ꧾ"], ["ꨀ", "ꨨ"], ["ꩀ", "ꩂ"], ["ꩄ", "ꩋ"], ["ꩠ", "ꩶ"], "ꩺ", ["ꩾ", "ꪯ"], "ꪱ", ["ꪵ", "ꪶ"], ["ꪹ", "ꪽ"], "ꫀ", "ꫂ", ["ꫛ", "ꫝ"], ["ꫠ", "ꫪ"], ["ꫲ", "ꫴ"], ["ꬁ", "ꬆ"], ["ꬉ", "ꬎ"], ["ꬑ", "ꬖ"], ["ꬠ", "ꬦ"], ["ꬨ", "ꬮ"], ["ꬰ", "ꭚ"], ["ꭜ", "ꭥ"], ["ꭰ", "ꯢ"], ["가", "힣"], ["ힰ", "ퟆ"], ["ퟋ", "ퟻ"], ["豈", "舘"], ["並", "龎"], ["ﬀ", "ﬆ"], ["ﬓ", "ﬗ"], "יִ", ["ײַ", "ﬨ"], ["שׁ", "זּ"], ["טּ", "לּ"], "מּ", ["נּ", "סּ"], ["ףּ", "פּ"], ["צּ", "ﮱ"], ["ﯓ", "ﴽ"], ["ﵐ", "ﶏ"], ["ﶒ", "ﷇ"], ["ﷰ", "ﷻ"], ["ﹰ", "ﹴ"], ["ﹶ", "ﻼ"], ["Ａ", "Ｚ"], ["ａ", "ｚ"], ["ｦ", "ﾾ"], ["ￂ", "ￇ"], ["ￊ", "ￏ"], ["ￒ", "ￗ"], ["ￚ", "ￜ"]], !1, !1), Be = Ce("[", !1), tr = Ce("]", !1), Vr = Ce("{", !1), Mt = Ce("}", !1), wn = Ce("%", !1), Ut = Ce("<", !1), ze = Ce(">", !1), Xn = pn(["@", "_"], !1, !1), Wn = Ce("!", !1), Ie = Ce("(", !1), rt = Ce(")", !1), Qt = Ce("/", !1), Sn = Ce("*", !1), nr = Ce("?", !1), Ir = Ce(":", !1), Tr = Ce("..", !1), c = Ce("^", !1), g = Ce("struct", !1), d = Ce("target", !1), y = Ce("euclid", !1), P = Ce("slow", !1), I = Ce("rotL", !1), R = Ce("rotR", !1), Z = Ce("fast", !1), Y = Ce("scale", !1), fe = Ce("//", !1), Te = pn([`
`], !0, !1), xt = Ce("cat", !1), Lt = Ce("$", !1), ye = Ce("setcps", !1), lt = Ce("setbpm", !1), Ne = Ce("hush", !1), Ct = function() {
    return parseFloat(Z2());
  }, Ai = function(l) {
    const v = l.join("");
    return v === "." || v === "_";
  }, r2 = function(l) {
    return new Sy(l.join(""));
  }, i2 = function(l) {
    return l;
  }, s2 = function(l, v) {
    return l.arguments_.stepsPerCycle = v, l;
  }, u2 = function(l) {
    return l;
  }, a2 = function(l) {
    return l.arguments_.alignment = "polymeter_slowcat", l;
  }, o2 = function(l) {
    return (v) => v.options_.weight = (v.options_.weight ?? 1) + (l ?? 2) - 1;
  }, c2 = function(l) {
    return (v) => {
      const E = (v.options_.reps ?? 1) + (l ?? 2) - 1;
      v.options_.reps = E, v.options_.ops = v.options_.ops.filter((G) => G.type_ !== "replicate"), v.options_.ops.push({ type_: "replicate", arguments_: { amount: E } }), v.options_.weight = E;
    };
  }, l2 = function(l, v, E) {
    return (G) => G.options_.ops.push({ type_: "bjorklund", arguments_: { pulse: l, step: v, rotation: E } });
  }, f2 = function(l) {
    return (v) => v.options_.ops.push({ type_: "stretch", arguments_: { amount: l, type: "slow" } });
  }, h2 = function(l) {
    return (v) => v.options_.ops.push({ type_: "stretch", arguments_: { amount: l, type: "fast" } });
  }, p2 = function(l) {
    return (v) => v.options_.ops.push({ type_: "degradeBy", arguments_: { amount: l, seed: Bs++ } });
  }, d2 = function(l) {
    return (v) => v.options_.ops.push({ type_: "tail", arguments_: { element: l } });
  }, m2 = function(l) {
    return (v) => v.options_.ops.push({ type_: "range", arguments_: { element: l } });
  }, g2 = function(l, v) {
    const E = new _y(l, { ops: [], weight: 1, reps: 1 });
    for (const G of v)
      G(E);
    return E;
  }, y2 = function(l, v) {
    return new vi(v, "fastcat", void 0, !!l);
  }, A2 = function(l) {
    return { alignment: "stack", list: l };
  }, b2 = function(l) {
    return { alignment: "rand", list: l, seed: Bs++ };
  }, M2 = function(l) {
    return { alignment: "feet", list: l, seed: Bs++ };
  }, C2 = function(l, v) {
    return v && v.list.length > 0 ? new vi([l, ...v.list], v.alignment, v.seed) : l;
  }, v2 = function(l, v) {
    return new vi(v ? [l, ...v.list] : [l], "polymeter");
  }, P2 = function(l) {
    return l;
  }, D2 = function(l) {
    return { name: "struct", args: { mini: l } };
  }, F2 = function(l) {
    return { name: "target", args: { name: l } };
  }, E2 = function(l, v, E) {
    return { name: "bjorklund", args: { pulse: l, step: parseInt(v) } };
  }, x2 = function(l) {
    return { name: "stretch", args: { amount: l } };
  }, w2 = function(l) {
    return { name: "shift", args: { amount: "-" + l } };
  }, S2 = function(l) {
    return { name: "shift", args: { amount: l } };
  }, B2 = function(l) {
    return { name: "stretch", args: { amount: "1/" + l } };
  }, _2 = function(l) {
    return { name: "scale", args: { scale: l.join("") } };
  }, Ya = function(l, v) {
    return v;
  }, k2 = function(l, v) {
    return v.unshift(l), new vi(v, "slowcat");
  }, V2 = function(l) {
    return l;
  }, I2 = function(l, v) {
    return new By(l.name, l.args, v);
  }, T2 = function(l) {
    return l;
  }, N2 = function(l) {
    return l;
  }, L2 = function(l) {
    return new Ss("setcps", { value: l });
  }, R2 = function(l) {
    return new Ss("setcps", { value: l / 120 / 2 });
  }, G2 = function() {
    return new Ss("hush");
  }, D = t.peg$currPos | 0, he = D, rr = [{ line: 1, column: 1 }], Rt = D, bi = t.peg$maxFailExpected || [], ne = t.peg$silentFails | 0, Nr;
  if (t.startRule) {
    if (!(t.startRule in i))
      throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
    s = i[t.startRule];
  }
  function Z2() {
    return e.substring(he, D);
  }
  function Ja() {
    return xs(he, D);
  }
  function Ce(l, v) {
    return { type: "literal", text: l, ignoreCase: v };
  }
  function pn(l, v, E) {
    return { type: "class", parts: l, inverted: v, ignoreCase: E };
  }
  function X2() {
    return { type: "end" };
  }
  function Es(l) {
    return { type: "other", description: l };
  }
  function Ua(l) {
    var v = rr[l], E;
    if (v)
      return v;
    if (l >= rr.length)
      E = rr.length - 1;
    else
      for (E = l; !rr[--E]; )
        ;
    for (v = rr[E], v = {
      line: v.line,
      column: v.column
    }; E < l; )
      e.charCodeAt(E) === 10 ? (v.line++, v.column = 1) : v.column++, E++;
    return rr[l] = v, v;
  }
  function xs(l, v, E) {
    var G = Ua(l), re = Ua(v), Ze = {
      source: r,
      start: {
        offset: l,
        line: G.line,
        column: G.column
      },
      end: {
        offset: v,
        line: re.line,
        column: re.column
      }
    };
    return Ze;
  }
  function ue(l) {
    D < Rt || (D > Rt && (Rt = D, bi = []), bi.push(l));
  }
  function W2(l, v, E) {
    return new Yn(
      Yn.buildMessage(l, v),
      l,
      v,
      E
    );
  }
  function Qa() {
    var l;
    return l = wy(), l;
  }
  function dn() {
    var l, v;
    return ne++, l = D, H2(), v = Mi(), v !== n ? (q2(), $2(), he = l, l = Ct()) : (D = l, l = n), ne--, l === n && ne === 0 && ue(Ge), l;
  }
  function O2() {
    var l;
    return e.charCodeAt(D) === 46 ? (l = u, D++) : (l = n, ne === 0 && ue(Yt)), l;
  }
  function z2() {
    var l;
    return l = e.charAt(D), tt.test(l) ? D++ : (l = n, ne === 0 && ue(dt)), l;
  }
  function j2() {
    var l;
    return l = e.charAt(D), ge.test(l) ? D++ : (l = n, ne === 0 && ue(Et)), l;
  }
  function $2() {
    var l, v, E, G, re;
    if (l = D, v = j2(), v !== n) {
      if (E = e.charAt(D), qe.test(E) ? D++ : (E = n, ne === 0 && ue(Nt)), E === n && (E = null), G = [], re = ir(), re !== n)
        for (; re !== n; )
          G.push(re), re = ir();
      else
        G = n;
      G !== n ? (v = [v, E, G], l = v) : (D = l, l = n);
    } else
      D = l, l = n;
    return l;
  }
  function q2() {
    var l, v, E, G;
    if (l = D, v = O2(), v !== n) {
      if (E = [], G = ir(), G !== n)
        for (; G !== n; )
          E.push(G), G = ir();
      else
        E = n;
      E !== n ? (v = [v, E], l = v) : (D = l, l = n);
    } else
      D = l, l = n;
    return l;
  }
  function Mi() {
    var l, v, E, G;
    if (l = K2(), l === n)
      if (l = D, v = z2(), v !== n) {
        for (E = [], G = ir(); G !== n; )
          E.push(G), G = ir();
        v = [v, E], l = v;
      } else
        D = l, l = n;
    return l;
  }
  function H2() {
    var l;
    return e.charCodeAt(D) === 45 ? (l = a, D++) : (l = n, ne === 0 && ue(xn)), l;
  }
  function K2() {
    var l;
    return e.charCodeAt(D) === 48 ? (l = o, D++) : (l = n, ne === 0 && ue(Jt)), l;
  }
  function ir() {
    var l;
    return l = e.charAt(D), Ee.test(l) ? D++ : (l = n, ne === 0 && ue(ln)), l;
  }
  function ae() {
    var l, v;
    for (ne++, l = [], v = e.charAt(D), Ke.test(v) ? D++ : (v = n, ne === 0 && ue(ct)); v !== n; )
      l.push(v), v = e.charAt(D), Ke.test(v) ? D++ : (v = n, ne === 0 && ue(ct));
    return ne--, v = n, ne === 0 && ue(fn), l;
  }
  function sr() {
    var l, v, E, G;
    return l = D, v = ae(), e.charCodeAt(D) === 44 ? (E = f, D++) : (E = n, ne === 0 && ue(hn)), E !== n ? (G = ae(), v = [v, E, G], l = v) : (D = l, l = n), l;
  }
  function eo() {
    var l, v, E, G;
    return l = D, v = ae(), e.charCodeAt(D) === 124 ? (E = h, D++) : (E = n, ne === 0 && ue(be)), E !== n ? (G = ae(), v = [v, E, G], l = v) : (D = l, l = n), l;
  }
  function to() {
    var l, v, E, G;
    return l = D, v = ae(), e.charCodeAt(D) === 46 ? (E = u, D++) : (E = n, ne === 0 && ue(Yt)), E !== n ? (G = ae(), v = [v, E, G], l = v) : (D = l, l = n), l;
  }
  function ur() {
    var l;
    return l = e.charAt(D), Ft.test(l) ? D++ : (l = n, ne === 0 && ue(_e)), l;
  }
  function Ci() {
    var l;
    return ne++, l = e.charAt(D), bt.test(l) ? D++ : (l = n, ne === 0 && ue(Oe)), ne--, l === n && ne === 0 && ue(Q), l;
  }
  function no() {
    var l, v, E, G;
    if (l = D, ae(), v = [], E = Ci(), E !== n)
      for (; E !== n; )
        v.push(E), E = Ci();
    else
      v = n;
    return v !== n ? (E = ae(), he = D, G = Ai(v), G ? G = n : G = void 0, G !== n ? (he = l, l = r2(v)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Y2() {
    var l, v, E, G;
    return l = D, ae(), e.charCodeAt(D) === 91 ? (v = m, D++) : (v = n, ne === 0 && ue(Be)), v !== n ? (ae(), E = so(), E !== n ? (ae(), e.charCodeAt(D) === 93 ? (G = p, D++) : (G = n, ne === 0 && ue(tr)), G !== n ? (ae(), he = l, l = i2(E)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function J2() {
    var l, v, E, G, re;
    return l = D, ae(), e.charCodeAt(D) === 123 ? (v = A, D++) : (v = n, ne === 0 && ue(Vr)), v !== n ? (ae(), E = uo(), E !== n ? (ae(), e.charCodeAt(D) === 125 ? (G = M, D++) : (G = n, ne === 0 && ue(Mt)), G !== n ? (re = U2(), re === n && (re = null), ae(), he = l, l = s2(E, re)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function U2() {
    var l, v, E;
    return l = D, e.charCodeAt(D) === 37 ? (v = C, D++) : (v = n, ne === 0 && ue(wn)), v !== n ? (E = ar(), E !== n ? (he = l, l = u2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Q2() {
    var l, v, E, G;
    return l = D, ae(), e.charCodeAt(D) === 60 ? (v = F, D++) : (v = n, ne === 0 && ue(Ut)), v !== n ? (ae(), E = uo(), E !== n ? (ae(), e.charCodeAt(D) === 62 ? (G = _, D++) : (G = n, ne === 0 && ue(ze)), G !== n ? (ae(), he = l, l = a2(E)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function ar() {
    var l;
    return l = no(), l === n && (l = Y2(), l === n && (l = J2(), l === n && (l = Q2()))), l;
  }
  function ro() {
    var l;
    return l = ey(), l === n && (l = ny(), l === n && (l = ry(), l === n && (l = iy(), l === n && (l = ty(), l === n && (l = sy(), l === n && (l = uy(), l === n && (l = ay()))))))), l;
  }
  function ey() {
    var l, v, E;
    return l = D, ae(), v = e.charAt(D), Ve.test(v) ? D++ : (v = n, ne === 0 && ue(Xn)), v !== n ? (E = dn(), E === n && (E = null), he = l, l = o2(E)) : (D = l, l = n), l;
  }
  function ty() {
    var l, v, E;
    return l = D, ae(), e.charCodeAt(D) === 33 ? (v = k, D++) : (v = n, ne === 0 && ue(Wn)), v !== n ? (E = dn(), E === n && (E = null), he = l, l = c2(E)) : (D = l, l = n), l;
  }
  function ny() {
    var l, v, E, G, re, Ze, Gt;
    return l = D, e.charCodeAt(D) === 40 ? (v = L, D++) : (v = n, ne === 0 && ue(Ie)), v !== n ? (ae(), E = Lr(), E !== n ? (ae(), G = sr(), G !== n ? (ae(), re = Lr(), re !== n ? (ae(), sr(), ae(), Ze = Lr(), Ze === n && (Ze = null), ae(), e.charCodeAt(D) === 41 ? (Gt = S, D++) : (Gt = n, ne === 0 && ue(rt)), Gt !== n ? (he = l, l = l2(E, re, Ze)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function ry() {
    var l, v, E;
    return l = D, e.charCodeAt(D) === 47 ? (v = x, D++) : (v = n, ne === 0 && ue(Qt)), v !== n ? (E = ar(), E !== n ? (he = l, l = f2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function iy() {
    var l, v, E;
    return l = D, e.charCodeAt(D) === 42 ? (v = B, D++) : (v = n, ne === 0 && ue(Sn)), v !== n ? (E = ar(), E !== n ? (he = l, l = h2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function sy() {
    var l, v, E;
    return l = D, e.charCodeAt(D) === 63 ? (v = V, D++) : (v = n, ne === 0 && ue(nr)), v !== n ? (E = dn(), E === n && (E = null), he = l, l = p2(E)) : (D = l, l = n), l;
  }
  function uy() {
    var l, v, E;
    return l = D, e.charCodeAt(D) === 58 ? (v = T, D++) : (v = n, ne === 0 && ue(Ir)), v !== n ? (E = ar(), E !== n ? (he = l, l = d2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function ay() {
    var l, v, E;
    return l = D, e.substr(D, 2) === H ? (v = H, D += 2) : (v = n, ne === 0 && ue(Tr)), v !== n ? (E = ar(), E !== n ? (he = l, l = m2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Lr() {
    var l, v, E, G;
    if (l = D, v = ar(), v !== n) {
      for (E = [], G = ro(); G !== n; )
        E.push(G), G = ro();
      he = l, l = g2(v, E);
    } else
      D = l, l = n;
    return l;
  }
  function Bn() {
    var l, v, E, G;
    if (l = D, e.charCodeAt(D) === 94 ? (v = X, D++) : (v = n, ne === 0 && ue(c)), v === n && (v = null), E = [], G = Lr(), G !== n)
      for (; G !== n; )
        E.push(G), G = Lr();
    else
      E = n;
    return E !== n ? (he = l, l = y2(v, E)) : (D = l, l = n), l;
  }
  function io() {
    var l, v, E, G, re;
    if (l = D, v = [], E = D, G = sr(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n), E !== n)
      for (; E !== n; )
        v.push(E), E = D, G = sr(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n);
    else
      v = n;
    return v !== n && (he = l, v = A2(v)), l = v, l;
  }
  function oy() {
    var l, v, E, G, re;
    if (l = D, v = [], E = D, G = eo(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n), E !== n)
      for (; E !== n; )
        v.push(E), E = D, G = eo(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n);
    else
      v = n;
    return v !== n && (he = l, v = b2(v)), l = v, l;
  }
  function cy() {
    var l, v, E, G, re;
    if (l = D, v = [], E = D, G = to(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n), E !== n)
      for (; E !== n; )
        v.push(E), E = D, G = to(), G !== n ? (re = Bn(), re !== n ? E = re : (D = E, E = n)) : (D = E, E = n);
    else
      v = n;
    return v !== n && (he = l, v = M2(v)), l = v, l;
  }
  function so() {
    var l, v, E;
    return l = D, v = Bn(), v !== n ? (E = io(), E === n && (E = oy(), E === n && (E = cy())), E === n && (E = null), he = l, l = C2(v, E)) : (D = l, l = n), l;
  }
  function uo() {
    var l, v, E;
    return l = D, v = Bn(), v !== n ? (E = io(), E === n && (E = null), he = l, l = v2(v, E)) : (D = l, l = n), l;
  }
  function ly() {
    var l, v, E, G;
    return l = D, ae(), v = ur(), v !== n ? (ae(), E = so(), E !== n ? (ae(), G = ur(), G !== n ? (he = l, l = P2(E)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function fy() {
    var l;
    return l = by(), l === n && (l = my(), l === n && (l = Ay(), l === n && (l = py(), l === n && (l = dy(), l === n && (l = hy(), l === n && (l = yy(), l === n && (l = gy()))))))), l;
  }
  function hy() {
    var l, v, E;
    return l = D, e.substr(D, 6) === U ? (v = U, D += 6) : (v = n, ne === 0 && ue(g)), v !== n ? (ae(), E = or(), E !== n ? (he = l, l = D2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function py() {
    var l, v, E, G, re;
    return l = D, e.substr(D, 6) === O ? (v = O, D += 6) : (v = n, ne === 0 && ue(d)), v !== n ? (ae(), E = ur(), E !== n ? (G = no(), G !== n ? (re = ur(), re !== n ? (he = l, l = F2(G)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function dy() {
    var l, v, E, G;
    return l = D, e.substr(D, 6) === z ? (v = z, D += 6) : (v = n, ne === 0 && ue(y)), v !== n ? (ae(), E = Mi(), E !== n ? (ae(), G = Mi(), G !== n ? (ae(), Mi(), he = l, l = E2(E, G)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function my() {
    var l, v, E;
    return l = D, e.substr(D, 4) === te ? (v = te, D += 4) : (v = n, ne === 0 && ue(P)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = x2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function gy() {
    var l, v, E;
    return l = D, e.substr(D, 4) === me ? (v = me, D += 4) : (v = n, ne === 0 && ue(I)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = w2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function yy() {
    var l, v, E;
    return l = D, e.substr(D, 4) === pe ? (v = pe, D += 4) : (v = n, ne === 0 && ue(R)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = S2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Ay() {
    var l, v, E;
    return l = D, e.substr(D, 4) === le ? (v = le, D += 4) : (v = n, ne === 0 && ue(Z)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = B2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function by() {
    var l, v, E, G, re;
    if (l = D, e.substr(D, 5) === ie ? (v = ie, D += 5) : (v = n, ne === 0 && ue(Y)), v !== n)
      if (ae(), E = ur(), E !== n) {
        if (G = [], re = Ci(), re !== n)
          for (; re !== n; )
            G.push(re), re = Ci();
        else
          G = n;
        G !== n ? (re = ur(), re !== n ? (he = l, l = _2(G)) : (D = l, l = n)) : (D = l, l = n);
      } else
        D = l, l = n;
    else
      D = l, l = n;
    return l;
  }
  function ws() {
    var l, v, E, G;
    if (l = D, e.substr(D, 2) === ke ? (v = ke, D += 2) : (v = n, ne === 0 && ue(fe)), v !== n) {
      for (E = [], G = e.charAt(D), En.test(G) ? D++ : (G = n, ne === 0 && ue(Te)); G !== n; )
        E.push(G), G = e.charAt(D), En.test(G) ? D++ : (G = n, ne === 0 && ue(Te));
      v = [v, E], l = v;
    } else
      D = l, l = n;
    return l;
  }
  function My() {
    var l, v, E, G, re, Ze, Gt, cr;
    if (l = D, e.substr(D, 3) === et ? (v = et, D += 3) : (v = n, ne === 0 && ue(xt)), v !== n)
      if (ae(), e.charCodeAt(D) === 91 ? (E = m, D++) : (E = n, ne === 0 && ue(Be)), E !== n)
        if (ae(), G = or(), G !== n) {
          for (re = [], Ze = D, Gt = sr(), Gt !== n ? (cr = or(), cr !== n ? (he = Ze, Ze = Ya(G, cr)) : (D = Ze, Ze = n)) : (D = Ze, Ze = n); Ze !== n; )
            re.push(Ze), Ze = D, Gt = sr(), Gt !== n ? (cr = or(), cr !== n ? (he = Ze, Ze = Ya(G, cr)) : (D = Ze, Ze = n)) : (D = Ze, Ze = n);
          Ze = ae(), e.charCodeAt(D) === 93 ? (Gt = p, D++) : (Gt = n, ne === 0 && ue(tr)), Gt !== n ? (he = l, l = k2(G, re)) : (D = l, l = n);
        } else
          D = l, l = n;
      else
        D = l, l = n;
    else
      D = l, l = n;
    return l;
  }
  function Cy() {
    var l;
    return l = My(), l === n && (l = ly()), l;
  }
  function or() {
    var l, v, E, G, re;
    if (l = D, v = Cy(), v !== n) {
      for (ae(), E = [], G = ws(); G !== n; )
        E.push(G), G = ws();
      he = l, l = V2(v);
    } else
      D = l, l = n;
    return l === n && (l = D, v = fy(), v !== n ? (ae(), e.charCodeAt(D) === 36 ? (E = oe, D++) : (E = n, ne === 0 && ue(Lt)), E !== n ? (G = ae(), re = or(), re !== n ? (he = l, l = I2(v, re)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)), l;
  }
  function vy() {
    var l, v;
    return l = D, v = or(), v !== n && (he = l, v = T2(v)), l = v, l === n && (l = ws()), l;
  }
  function Py() {
    var l;
    return l = vy(), l;
  }
  function Dy() {
    var l, v;
    return l = D, ae(), v = Fy(), v === n && (v = Ey(), v === n && (v = xy())), v !== n ? (ae(), he = l, l = N2(v)) : (D = l, l = n), l;
  }
  function Fy() {
    var l, v, E;
    return l = D, e.substr(D, 6) === W ? (v = W, D += 6) : (v = n, ne === 0 && ue(ye)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = L2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Ey() {
    var l, v, E;
    return l = D, e.substr(D, 6) === $e ? (v = $e, D += 6) : (v = n, ne === 0 && ue(lt)), v !== n ? (ae(), E = dn(), E !== n ? (he = l, l = R2(E)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function xy() {
    var l, v;
    return l = D, e.substr(D, 4) === xe ? (v = xe, D += 4) : (v = n, ne === 0 && ue(Ne)), v !== n && (he = l, v = G2()), l = v, l;
  }
  function wy() {
    var l;
    return l = Py(), l === n && (l = Dy()), l;
  }
  var Sy = function(l) {
    this.type_ = "atom", this.source_ = l, this.location_ = Ja();
  }, vi = function(l, v, E, G) {
    this.type_ = "pattern", this.arguments_ = { alignment: v, _steps: G }, E !== void 0 && (this.arguments_.seed = E), this.source_ = l;
  }, By = function(l, v, E) {
    this.type_ = l, this.arguments_ = v, this.source_ = E;
  }, _y = function(l, v) {
    this.type_ = "element", this.source_ = l, this.options_ = v, this.location_ = Ja();
  }, Ss = function(l, v) {
    this.type_ = "command", this.name_ = l, this.options_ = v;
  }, Bs = 0;
  if (Nr = s(), t.peg$library)
    return (
      /** @type {any} */
      {
        peg$result: Nr,
        peg$currPos: D,
        peg$FAILED: n,
        peg$maxFailExpected: bi,
        peg$maxFailPos: Rt
      }
    );
  if (Nr !== n && D === e.length)
    return Nr;
  throw Nr !== n && D < e.length && ue(X2()), W2(
    bi,
    Rt < e.length ? e.charAt(Rt) : null,
    Rt < e.length ? xs(Rt, Rt + 1) : xs(Rt, Rt)
  );
}
const Rv = [
  "start"
], tm = 3e-4, Gv = (e, t) => (n, r) => {
  const u = e.source_[r].options_?.ops, a = n.__steps_source;
  if (u)
    for (const o of u)
      switch (o.type_) {
        case "stretch": {
          const f = ["fast", "slow"], { type: h, amount: m } = o.arguments_;
          if (!f.includes(h))
            throw new Error(`mini: stretch: type must be one of ${f.join("|")} but got ${h}`);
          n = q(n)[h](t(m));
          break;
        }
        case "replicate": {
          const { amount: f } = o.arguments_;
          n = q(n), n = n._repeatCycles(f)._fast(f);
          break;
        }
        case "bjorklund": {
          o.arguments_.rotation ? n = n.euclidRot(t(o.arguments_.pulse), t(o.arguments_.step), t(o.arguments_.rotation)) : n = n.euclid(t(o.arguments_.pulse), t(o.arguments_.step));
          break;
        }
        case "degradeBy": {
          n = q(n)._degradeByWith(ht.early(tm * o.arguments_.seed), o.arguments_.amount ?? 0.5);
          break;
        }
        case "tail": {
          const f = t(o.arguments_.element);
          n = n.fmap((h) => (m) => Array.isArray(h) ? [...h, m] : [h, m]).appLeft(f);
          break;
        }
        case "range": {
          const f = t(o.arguments_.element);
          n = q(n);
          const h = (p, A, M = 1) => Array.from(
            { length: Math.abs(A - p) / M + 1 },
            (C, F) => p < A ? p + F * M : p - F * M
          );
          n = ((p, A) => p.squeezeBind((M) => A.bind((C) => ot(...h(M, C)))))(n, f);
          break;
        }
        default:
          console.warn(`operator "${o.type_}" not implemented`);
      }
  return n.__steps_source = n.__steps_source || a, n;
};
function Pr(e, t, n, r = 0) {
  n?.(e);
  const i = (s) => Pr(s, t, n, r);
  switch (e.type_) {
    case "pattern": {
      const s = e.source_.map((f) => i(f)).map(Gv(e, i)), u = e.arguments_.alignment, a = s.filter((f) => f.__steps_source);
      let o;
      switch (u) {
        case "stack": {
          o = Le(...s), a.length && (o._steps = zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "polymeter_slowcat": {
          o = Le(...s.map((f) => f._slow(f.__weight))), a.length && (o._steps = zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "polymeter": {
          const f = e.arguments_.stepsPerCycle ? i(e.arguments_.stepsPerCycle).fmap((m) => j(m)) : Je(j(s.length > 0 ? s[0].__weight : 1)), h = s.map((m) => m.fast(f.fmap((p) => p.div(m.__weight))));
          o = Le(...h);
          break;
        }
        case "rand": {
          o = es(ht.early(tm * e.arguments_.seed).segment(1), s), a.length && (o._steps = zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "feet": {
          o = ot(...s);
          break;
        }
        default: {
          if (e.source_.some((h) => !!h.options_?.weight)) {
            const h = e.source_.reduce(
              (m, p) => m.add(p.options_?.weight || j(1)),
              j(0)
            );
            o = Xu(
              ...e.source_.map((m, p) => [m.options_?.weight || j(1), s[p]])
            ), o.__weight = h, o._steps = h, a.length && (o._steps = o._steps.mul(zt(...a.map((m) => j(m._steps)))));
          } else
            o = qt(...s), o._steps = s.length;
          e.arguments_._steps && (o.__steps_source = !0);
        }
      }
      return a.length && (o.__steps_source = !0), o;
    }
    case "element":
      return i(e.source_);
    case "atom": {
      if (e.source_ === "~" || e.source_ === "-")
        return Se;
      if (!e.location_)
        return console.warn("no location for", e), e.source_;
      const s = isNaN(Number(e.source_)) ? e.source_ : Number(e.source_);
      if (r === -1)
        return Je(s);
      const [u, a] = ha(t, e, r);
      return Je(s).withLoc(u, a);
    }
    case "stretch":
      return i(e.source_).slow(i(e.arguments_.amount));
    default:
      return console.warn(`node type "${e.type_}" not implemented -> returning silence`), Se;
  }
}
const ha = (e, t, n = 0) => {
  const { start: r, end: i } = t.location_, s = e?.split("").slice(r.offset, i.offset).join(""), [u = 0, a = 0] = s ? s.split(t.source_).map((o) => o.split("").filter((f) => f === " ").length) : [];
  return [r.offset + u + n, i.offset - a + n];
}, hi = (e, t = 0, n = e) => {
  try {
    return em(e);
  } catch (r) {
    const i = [r.location.start.offset + t, r.location.end.offset + t], s = n.slice(0, i[0]).split(`
`).length;
    throw new Error(`[mini] parse error at line ${s}: ${r.message}`);
  }
}, nm = (e, t, n) => {
  const r = hi(e, t, n);
  let i = [];
  return Pr(
    r,
    e,
    (s) => {
      s.type_ === "atom" && i.push(s);
    },
    -1
  ), i;
}, pa = (e, t = 0, n) => nm(e, t, n).map((r) => ha(e, r, t)), da = (...e) => {
  const t = e.map((n) => {
    const r = `"${n}"`, i = hi(r);
    return Pr(i, r);
  });
  return qt(...t);
}, Zv = (e, t) => {
  const n = `"${e}"`, r = hi(n);
  return Pr(r, n, null, t);
}, Xv = (e) => {
  const t = hi(e);
  return Pr(t, e);
};
function Wv(e) {
  return typeof e == "string" ? da(e) : q(e);
}
function rm() {
  Gc(da);
}
const Ov = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StartRules: Rv,
  SyntaxError: Yn,
  getLeafLocation: ha,
  getLeafLocations: pa,
  getLeaves: nm,
  h: Xv,
  m: Zv,
  mini: da,
  mini2ast: hi,
  miniAllStrings: rm,
  minify: Wv,
  parse: em,
  patternifyAST: Pr
}, Symbol.toStringTag, { value: "Module" }));
var zv = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], im = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], jv = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", sm = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Rs = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, Gs = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", $v = {
  5: Gs,
  "5module": Gs + " export import",
  6: Gs + " const class extends export import super"
}, qv = /^in(stanceof)?$/, Hv = new RegExp("[" + sm + "]"), Kv = new RegExp("[" + sm + jv + "]");
function gu(e, t) {
  for (var n = 65536, r = 0; r < t.length; r += 2) {
    if (n += t[r], n > e)
      return !1;
    if (n += t[r + 1], n >= e)
      return !0;
  }
  return !1;
}
function vn(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && Hv.test(String.fromCharCode(e)) : t === !1 ? !1 : gu(e, im);
}
function yr(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && Kv.test(String.fromCharCode(e)) : t === !1 ? !1 : gu(e, im) || gu(e, zv);
}
var De = function(t, n) {
  n === void 0 && (n = {}), this.label = t, this.keyword = n.keyword, this.beforeExpr = !!n.beforeExpr, this.startsExpr = !!n.startsExpr, this.isLoop = !!n.isLoop, this.isAssign = !!n.isAssign, this.prefix = !!n.prefix, this.postfix = !!n.postfix, this.binop = n.binop || null, this.updateContext = null;
};
function wt(e, t) {
  return new De(e, { beforeExpr: !0, binop: t });
}
var St = { beforeExpr: !0 }, mt = { startsExpr: !0 }, ma = {};
function ve(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, ma[e] = new De(e, t);
}
var b = {
  num: new De("num", mt),
  regexp: new De("regexp", mt),
  string: new De("string", mt),
  name: new De("name", mt),
  privateId: new De("privateId", mt),
  eof: new De("eof"),
  // Punctuation token types.
  bracketL: new De("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new De("]"),
  braceL: new De("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new De("}"),
  parenL: new De("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new De(")"),
  comma: new De(",", St),
  semi: new De(";", St),
  colon: new De(":", St),
  dot: new De("."),
  question: new De("?", St),
  questionDot: new De("?."),
  arrow: new De("=>", St),
  template: new De("template"),
  invalidTemplate: new De("invalidTemplate"),
  ellipsis: new De("...", St),
  backQuote: new De("`", mt),
  dollarBraceL: new De("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new De("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new De("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new De("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new De("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: wt("||", 1),
  logicalAND: wt("&&", 2),
  bitwiseOR: wt("|", 3),
  bitwiseXOR: wt("^", 4),
  bitwiseAND: wt("&", 5),
  equality: wt("==/!=/===/!==", 6),
  relational: wt("</>/<=/>=", 7),
  bitShift: wt("<</>>/>>>", 8),
  plusMin: new De("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: wt("%", 10),
  star: wt("*", 10),
  slash: wt("/", 10),
  starstar: new De("**", { beforeExpr: !0 }),
  coalesce: wt("??", 1),
  // Keyword token types.
  _break: ve("break"),
  _case: ve("case", St),
  _catch: ve("catch"),
  _continue: ve("continue"),
  _debugger: ve("debugger"),
  _default: ve("default", St),
  _do: ve("do", { isLoop: !0, beforeExpr: !0 }),
  _else: ve("else", St),
  _finally: ve("finally"),
  _for: ve("for", { isLoop: !0 }),
  _function: ve("function", mt),
  _if: ve("if"),
  _return: ve("return", St),
  _switch: ve("switch"),
  _throw: ve("throw", St),
  _try: ve("try"),
  _var: ve("var"),
  _const: ve("const"),
  _while: ve("while", { isLoop: !0 }),
  _with: ve("with"),
  _new: ve("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: ve("this", mt),
  _super: ve("super", mt),
  _class: ve("class", mt),
  _extends: ve("extends", St),
  _export: ve("export"),
  _import: ve("import", mt),
  _null: ve("null", mt),
  _true: ve("true", mt),
  _false: ve("false", mt),
  _in: ve("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: ve("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: ve("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: ve("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: ve("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, It = /\r\n?|\n|\u2028|\u2029/, Yv = new RegExp(It.source, "g");
function Dr(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function um(e, t, n) {
  n === void 0 && (n = e.length);
  for (var r = t; r < n; r++) {
    var i = e.charCodeAt(r);
    if (Dr(i))
      return r < n - 1 && i === 13 && e.charCodeAt(r + 1) === 10 ? r + 2 : r + 1;
  }
  return -1;
}
var am = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Bt = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, om = Object.prototype, Jv = om.hasOwnProperty, Uv = om.toString, Fr = Object.hasOwn || function(e, t) {
  return Jv.call(e, t);
}, Eo = Array.isArray || function(e) {
  return Uv.call(e) === "[object Array]";
}, xo = /* @__PURE__ */ Object.create(null);
function Vn(e) {
  return xo[e] || (xo[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function Pn(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
var Qv = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, ui = function(t, n) {
  this.line = t, this.column = n;
};
ui.prototype.offset = function(t) {
  return new ui(this.line, this.column + t);
};
var is = function(t, n, r) {
  this.start = n, this.end = r, t.sourceFile !== null && (this.source = t.sourceFile);
};
function cm(e, t) {
  for (var n = 1, r = 0; ; ) {
    var i = um(e, r, t);
    if (i < 0)
      return new ui(n, t - r);
    ++n, r = i;
  }
}
var yu = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, wo = !1;
function eP(e) {
  var t = {};
  for (var n in yu)
    t[n] = e && Fr(e, n) ? e[n] : yu[n];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!wo && typeof console == "object" && console.warn && (wo = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14), Eo(t.onToken)) {
    var r = t.onToken;
    t.onToken = function(i) {
      return r.push(i);
    };
  }
  return Eo(t.onComment) && (t.onComment = tP(t, t.onComment)), t;
}
function tP(e, t) {
  return function(n, r, i, s, u, a) {
    var o = {
      type: n ? "Block" : "Line",
      value: r,
      start: i,
      end: s
    };
    e.locations && (o.loc = new is(this, u, a)), e.ranges && (o.range = [i, s]), t.push(o);
  };
}
var ai = 1, Er = 2, ga = 4, lm = 8, fm = 16, hm = 32, ya = 64, pm = 128, pi = 256, Aa = ai | Er | pi;
function ba(e, t) {
  return Er | (e ? ga : 0) | (t ? lm : 0);
}
var Xi = 0, Ma = 1, Fn = 2, dm = 3, mm = 4, gm = 5, Qe = function(t, n, r) {
  this.options = t = eP(t), this.sourceFile = t.sourceFile, this.keywords = Vn($v[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var i = "";
  t.allowReserved !== !0 && (i = Rs[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (i += " await")), this.reservedWords = Vn(i);
  var s = (i ? i + " " : "") + Rs.strict;
  this.reservedWordsStrict = Vn(s), this.reservedWordsStrictBind = Vn(s + " " + Rs.strictBind), this.input = String(n), this.containsEsc = !1, r ? (this.pos = r, this.lineStart = this.input.lastIndexOf(`
`, r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(It).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = b.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(ai), this.regexpState = null, this.privateNameStack = [];
}, on = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
Qe.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
on.inFunction.get = function() {
  return (this.currentVarScope().flags & Er) > 0;
};
on.inGenerator.get = function() {
  return (this.currentVarScope().flags & lm) > 0 && !this.currentVarScope().inClassFieldInit;
};
on.inAsync.get = function() {
  return (this.currentVarScope().flags & ga) > 0 && !this.currentVarScope().inClassFieldInit;
};
on.canAwait.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e];
    if (t.inClassFieldInit || t.flags & pi)
      return !1;
    if (t.flags & Er)
      return (t.flags & ga) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
on.allowSuper.get = function() {
  var e = this.currentThisScope(), t = e.flags, n = e.inClassFieldInit;
  return (t & ya) > 0 || n || this.options.allowSuperOutsideMethod;
};
on.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & pm) > 0;
};
on.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
on.allowNewDotTarget.get = function() {
  var e = this.currentThisScope(), t = e.flags, n = e.inClassFieldInit;
  return (t & (Er | pi)) > 0 || n;
};
on.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & pi) > 0;
};
Qe.extend = function() {
  for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];
  for (var r = this, i = 0; i < t.length; i++)
    r = t[i](r);
  return r;
};
Qe.parse = function(t, n) {
  return new this(n, t).parse();
};
Qe.parseExpressionAt = function(t, n, r) {
  var i = new this(r, t, n);
  return i.nextToken(), i.parseExpression();
};
Qe.tokenizer = function(t, n) {
  return new this(n, t);
};
Object.defineProperties(Qe.prototype, on);
var pt = Qe.prototype, nP = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pt.strictDirective = function(e) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    Bt.lastIndex = e, e += Bt.exec(this.input)[0].length;
    var t = nP.exec(this.input.slice(e));
    if (!t)
      return !1;
    if ((t[1] || t[2]) === "use strict") {
      Bt.lastIndex = e + t[0].length;
      var n = Bt.exec(this.input), r = n.index + n[0].length, i = this.input.charAt(r);
      return i === ";" || i === "}" || It.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || i === "!" && this.input.charAt(r + 1) === "=");
    }
    e += t[0].length, Bt.lastIndex = e, e += Bt.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
pt.eat = function(e) {
  return this.type === e ? (this.next(), !0) : !1;
};
pt.isContextual = function(e) {
  return this.type === b.name && this.value === e && !this.containsEsc;
};
pt.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), !0) : !1;
};
pt.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
pt.canInsertSemicolon = function() {
  return this.type === b.eof || this.type === b.braceR || It.test(this.input.slice(this.lastTokEnd, this.start));
};
pt.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
pt.semicolon = function() {
  !this.eat(b.semi) && !this.insertSemicolon() && this.unexpected();
};
pt.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
};
pt.expect = function(e) {
  this.eat(e) || this.unexpected();
};
pt.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
var ss = function() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pt.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var n = t ? e.parenthesizedAssign : e.parenthesizedBind;
    n > -1 && this.raiseRecoverable(n, t ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pt.checkExpressionErrors = function(e, t) {
  if (!e)
    return !1;
  var n = e.shorthandAssign, r = e.doubleProto;
  if (!t)
    return n >= 0 || r >= 0;
  n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
pt.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pt.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var ee = Qe.prototype;
ee.parseTopLevel = function(e) {
  var t = /* @__PURE__ */ Object.create(null);
  for (e.body || (e.body = []); this.type !== b.eof; ) {
    var n = this.parseStatement(null, !0, t);
    e.body.push(n);
  }
  if (this.inModule)
    for (var r = 0, i = Object.keys(this.undefinedExports); r < i.length; r += 1) {
      var s = i[r];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var Ca = { kind: "loop" }, rP = { kind: "switch" };
ee.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  Bt.lastIndex = this.pos;
  var t = Bt.exec(this.input), n = this.pos + t[0].length, r = this.input.charCodeAt(n);
  if (r === 91 || r === 92)
    return !0;
  if (e)
    return !1;
  if (r === 123 || r > 55295 && r < 56320)
    return !0;
  if (vn(r, !0)) {
    for (var i = n + 1; yr(r = this.input.charCodeAt(i), !0); )
      ++i;
    if (r === 92 || r > 55295 && r < 56320)
      return !0;
    var s = this.input.slice(n, i);
    if (!qv.test(s))
      return !0;
  }
  return !1;
};
ee.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  Bt.lastIndex = this.pos;
  var e = Bt.exec(this.input), t = this.pos + e[0].length, n;
  return !It.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(yr(n = this.input.charCodeAt(t + 8)) || n > 55295 && n < 56320));
};
ee.parseStatement = function(e, t, n) {
  var r = this.type, i = this.startNode(), s;
  switch (this.isLet(e) && (r = b._var, s = "let"), r) {
    case b._break:
    case b._continue:
      return this.parseBreakContinueStatement(i, r.keyword);
    case b._debugger:
      return this.parseDebuggerStatement(i);
    case b._do:
      return this.parseDoStatement(i);
    case b._for:
      return this.parseForStatement(i);
    case b._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i, !1, !e);
    case b._class:
      return e && this.unexpected(), this.parseClass(i, !0);
    case b._if:
      return this.parseIfStatement(i);
    case b._return:
      return this.parseReturnStatement(i);
    case b._switch:
      return this.parseSwitchStatement(i);
    case b._throw:
      return this.parseThrowStatement(i);
    case b._try:
      return this.parseTryStatement(i);
    case b._const:
    case b._var:
      return s = s || this.value, e && s !== "var" && this.unexpected(), this.parseVarStatement(i, s);
    case b._while:
      return this.parseWhileStatement(i);
    case b._with:
      return this.parseWithStatement(i);
    case b.braceL:
      return this.parseBlock(!0, i);
    case b.semi:
      return this.parseEmptyStatement(i);
    case b._export:
    case b._import:
      if (this.options.ecmaVersion > 10 && r === b._import) {
        Bt.lastIndex = this.pos;
        var u = Bt.exec(this.input), a = this.pos + u[0].length, o = this.input.charCodeAt(a);
        if (o === 40 || o === 46)
          return this.parseExpressionStatement(i, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === b._import ? this.parseImport(i) : this.parseExport(i, n);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !e);
      var f = this.value, h = this.parseExpression();
      return r === b.name && h.type === "Identifier" && this.eat(b.colon) ? this.parseLabeledStatement(i, f, h, e) : this.parseExpressionStatement(i, h);
  }
};
ee.parseBreakContinueStatement = function(e, t) {
  var n = t === "break";
  this.next(), this.eat(b.semi) || this.insertSemicolon() ? e.label = null : this.type !== b.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var r = 0; r < this.labels.length; ++r) {
    var i = this.labels[r];
    if ((e.label == null || i.name === e.label.name) && (i.kind != null && (n || i.kind === "loop") || e.label && n))
      break;
  }
  return r === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, n ? "BreakStatement" : "ContinueStatement");
};
ee.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
ee.parseDoStatement = function(e) {
  return this.next(), this.labels.push(Ca), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(b._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(b.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
ee.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(Ca), this.enterScope(0), this.expect(b.parenL), this.type === b.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var n = this.isLet();
  if (this.type === b._var || this.type === b._const || n) {
    var r = this.startNode(), i = n ? "let" : this.value;
    return this.next(), this.parseVar(r, !0, i), this.finishNode(r, "VariableDeclaration"), (this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && r.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === b._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, r)) : (t > -1 && this.unexpected(t), this.parseFor(e, r));
  }
  var s = this.isContextual("let"), u = !1, a = this.containsEsc, o = new ss(), f = this.start, h = t > -1 ? this.parseExprSubscripts(o, "await") : this.parseExpression(!0, o);
  return this.type === b._in || (u = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === b._in && this.unexpected(t), e.await = !0) : u && this.options.ecmaVersion >= 8 && (h.start === f && !a && h.type === "Identifier" && h.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (e.await = !1)), s && u && this.raise(h.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(h, !1, o), this.checkLValPattern(h), this.parseForIn(e, h)) : (this.checkExpressionErrors(o, !0), t > -1 && this.unexpected(t), this.parseFor(e, h));
};
ee.parseFunctionStatement = function(e, t, n) {
  return this.next(), this.parseFunction(e, Ur | (n ? 0 : Au), !1, t);
};
ee.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(b._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
ee.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(b.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
ee.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(b.braceL), this.labels.push(rP), this.enterScope(0);
  for (var t, n = !1; this.type !== b.braceR; )
    if (this.type === b._case || this.type === b._default) {
      var r = this.type === b._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), r ? t.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, t.test = null), this.expect(b.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
ee.parseThrowStatement = function(e) {
  return this.next(), It.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var iP = [];
ee.parseCatchClauseParam = function() {
  var e = this.parseBindingAtom(), t = e.type === "Identifier";
  return this.enterScope(t ? hm : 0), this.checkLValPattern(e, t ? mm : Fn), this.expect(b.parenR), e;
};
ee.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === b._catch) {
    var t = this.startNode();
    this.next(), this.eat(b.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(b._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
ee.parseVarStatement = function(e, t, n) {
  return this.next(), this.parseVar(e, !1, t, n), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
ee.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(Ca), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
ee.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
ee.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
ee.parseLabeledStatement = function(e, t, n, r) {
  for (var i = 0, s = this.labels; i < s.length; i += 1) {
    var u = s[i];
    u.name === t && this.raise(n.start, "Label '" + t + "' is already declared");
  }
  for (var a = this.type.isLoop ? "loop" : this.type === b._switch ? "switch" : null, o = this.labels.length - 1; o >= 0; o--) {
    var f = this.labels[o];
    if (f.statementStart === e.start)
      f.statementStart = this.start, f.kind = a;
    else
      break;
  }
  return this.labels.push({ name: t, kind: a, statementStart: this.start }), e.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.labels.pop(), e.label = n, this.finishNode(e, "LabeledStatement");
};
ee.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
ee.parseBlock = function(e, t, n) {
  for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(b.braceL), e && this.enterScope(0); this.type !== b.braceR; ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return n && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
ee.parseFor = function(e, t) {
  return e.init = t, this.expect(b.semi), e.test = this.type === b.semi ? null : this.parseExpression(), this.expect(b.semi), e.update = this.type === b.parenR ? null : this.parseExpression(), this.expect(b.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
ee.parseForIn = function(e, t) {
  var n = this.type === b._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!n || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
    t.start,
    (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), e.left = t, e.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(b.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
};
ee.parseVar = function(e, t, n, r) {
  for (e.declarations = [], e.kind = n; ; ) {
    var i = this.startNode();
    if (this.parseVarId(i, n), this.eat(b.eq) ? i.init = this.parseMaybeAssign(t) : !r && n === "const" && !(this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !r && i.id.type !== "Identifier" && !(t && (this.type === b._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(b.comma))
      break;
  }
  return e;
};
ee.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? Ma : Fn, !1);
};
var Ur = 1, Au = 2, ym = 4;
ee.parseFunction = function(e, t, n, r, i) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) && (this.type === b.star && t & Au && this.unexpected(), e.generator = this.eat(b.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), t & Ur && (e.id = t & ym && this.type !== b.name ? null : this.parseIdent(), e.id && !(t & Au) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? Ma : Fn : dm));
  var s = this.yieldPos, u = this.awaitPos, a = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(ba(e.async, e.generator)), t & Ur || (e.id = this.type === b.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, n, !1, i), this.yieldPos = s, this.awaitPos = u, this.awaitIdentPos = a, this.finishNode(e, t & Ur ? "FunctionDeclaration" : "FunctionExpression");
};
ee.parseFunctionParams = function(e) {
  this.expect(b.parenL), e.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
ee.parseClass = function(e, t) {
  this.next();
  var n = this.strict;
  this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
  var r = this.enterClassBody(), i = this.startNode(), s = !1;
  for (i.body = [], this.expect(b.braceL); this.type !== b.braceR; ) {
    var u = this.parseClassElement(e.superClass !== null);
    u && (i.body.push(u), u.type === "MethodDefinition" && u.kind === "constructor" ? (s && this.raiseRecoverable(u.start, "Duplicate constructor in the same class"), s = !0) : u.key && u.key.type === "PrivateIdentifier" && sP(r, u) && this.raiseRecoverable(u.key.start, "Identifier '#" + u.key.name + "' has already been declared"));
  }
  return this.strict = n, this.next(), e.body = this.finishNode(i, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
ee.parseClassElement = function(e) {
  if (this.eat(b.semi))
    return null;
  var t = this.options.ecmaVersion, n = this.startNode(), r = "", i = !1, s = !1, u = "method", a = !1;
  if (this.eatContextual("static")) {
    if (t >= 13 && this.eat(b.braceL))
      return this.parseClassStaticBlock(n), n;
    this.isClassElementNameStart() || this.type === b.star ? a = !0 : r = "static";
  }
  if (n.static = a, !r && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === b.star) && !this.canInsertSemicolon() ? s = !0 : r = "async"), !r && (t >= 9 || !s) && this.eat(b.star) && (i = !0), !r && !s && !i) {
    var o = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? u = o : r = o);
  }
  if (r ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = r, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), t < 13 || this.type === b.parenL || u !== "method" || i || s) {
    var f = !n.static && Wi(n, "constructor"), h = f && e;
    f && u !== "method" && this.raise(n.key.start, "Constructor can't have get/set modifier"), n.kind = f ? "constructor" : u, this.parseClassMethod(n, i, s, h);
  } else
    this.parseClassField(n);
  return n;
};
ee.isClassElementNameStart = function() {
  return this.type === b.name || this.type === b.privateId || this.type === b.num || this.type === b.string || this.type === b.bracketL || this.type.keyword;
};
ee.parseClassElementName = function(e) {
  this.type === b.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
};
ee.parseClassMethod = function(e, t, n, r) {
  var i = e.key;
  e.kind === "constructor" ? (t && this.raise(i.start, "Constructor can't be a generator"), n && this.raise(i.start, "Constructor can't be an async method")) : e.static && Wi(e, "prototype") && this.raise(i.start, "Classes may not have a static property named prototype");
  var s = e.value = this.parseMethod(t, n, r);
  return e.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"), e.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"), e.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
};
ee.parseClassField = function(e) {
  if (Wi(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && Wi(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(b.eq)) {
    var t = this.currentThisScope(), n = t.inClassFieldInit;
    t.inClassFieldInit = !0, e.value = this.parseMaybeAssign(), t.inClassFieldInit = n;
  } else
    e.value = null;
  return this.semicolon(), this.finishNode(e, "PropertyDefinition");
};
ee.parseClassStaticBlock = function(e) {
  e.body = [];
  var t = this.labels;
  for (this.labels = [], this.enterScope(pi | ya); this.type !== b.braceR; ) {
    var n = this.parseStatement(null);
    e.body.push(n);
  }
  return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
};
ee.parseClassId = function(e, t) {
  this.type === b.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, Fn, !1)) : (t === !0 && this.unexpected(), e.id = null);
};
ee.parseClassSuper = function(e) {
  e.superClass = this.eat(b._extends) ? this.parseExprSubscripts(null, !1) : null;
};
ee.enterClassBody = function() {
  var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(e), e.declared;
};
ee.exitClassBody = function() {
  var e = this.privateNameStack.pop(), t = e.declared, n = e.used;
  if (this.options.checkPrivateFields)
    for (var r = this.privateNameStack.length, i = r === 0 ? null : this.privateNameStack[r - 1], s = 0; s < n.length; ++s) {
      var u = n[s];
      Fr(t, u.name) || (i ? i.used.push(u) : this.raiseRecoverable(u.start, "Private field '#" + u.name + "' must be declared in an enclosing class"));
    }
};
function sP(e, t) {
  var n = t.key.name, r = e[n], i = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (i = (t.static ? "s" : "i") + t.kind), r === "iget" && i === "iset" || r === "iset" && i === "iget" || r === "sget" && i === "sset" || r === "sset" && i === "sget" ? (e[n] = "true", !1) : r ? !0 : (e[n] = i, !1);
}
function Wi(e, t) {
  var n = e.computed, r = e.key;
  return !n && (r.type === "Identifier" && r.name === t || r.type === "Literal" && r.value === t);
}
ee.parseExportAllDeclaration = function(e, t) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== b.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
};
ee.parseExport = function(e, t) {
  if (this.next(), this.eat(b.star))
    return this.parseExportAllDeclaration(e, t);
  if (this.eat(b._default))
    return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== b.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    else {
      for (var n = 0, r = e.specifiers; n < r.length; n += 1) {
        var i = r[n];
        this.checkUnreserved(i.local), this.checkLocalExport(i.local), i.local.type === "Literal" && this.raise(i.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
ee.parseExportDeclaration = function(e) {
  return this.parseStatement(null);
};
ee.parseExportDefaultDeclaration = function() {
  var e;
  if (this.type === b._function || (e = this.isAsyncFunction())) {
    var t = this.startNode();
    return this.next(), e && this.next(), this.parseFunction(t, Ur | ym, !1, e);
  } else if (this.type === b._class) {
    var n = this.startNode();
    return this.parseClass(n, "nullableID");
  } else {
    var r = this.parseMaybeAssign();
    return this.semicolon(), r;
  }
};
ee.checkExport = function(e, t, n) {
  e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Fr(e, t) && this.raiseRecoverable(n, "Duplicate export '" + t + "'"), e[t] = !0);
};
ee.checkPatternExport = function(e, t) {
  var n = t.type;
  if (n === "Identifier")
    this.checkExport(e, t, t.start);
  else if (n === "ObjectPattern")
    for (var r = 0, i = t.properties; r < i.length; r += 1) {
      var s = i[r];
      this.checkPatternExport(e, s);
    }
  else if (n === "ArrayPattern")
    for (var u = 0, a = t.elements; u < a.length; u += 1) {
      var o = a[u];
      o && this.checkPatternExport(e, o);
    }
  else n === "Property" ? this.checkPatternExport(e, t.value) : n === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : n === "RestElement" && this.checkPatternExport(e, t.argument);
};
ee.checkVariableExport = function(e, t) {
  if (e)
    for (var n = 0, r = t; n < r.length; n += 1) {
      var i = r[n];
      this.checkPatternExport(e, i.id);
    }
};
ee.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
ee.parseExportSpecifier = function(e) {
  var t = this.startNode();
  return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
    e,
    t.exported,
    t.exported.start
  ), this.finishNode(t, "ExportSpecifier");
};
ee.parseExportSpecifiers = function(e) {
  var t = [], n = !0;
  for (this.expect(b.braceL); !this.eat(b.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(b.comma), this.afterTrailingComma(b.braceR))
      break;
    t.push(this.parseExportSpecifier(e));
  }
  return t;
};
ee.parseImport = function(e) {
  return this.next(), this.type === b.string ? (e.specifiers = iP, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === b.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
ee.parseImportSpecifier = function() {
  var e = this.startNode();
  return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, Fn), this.finishNode(e, "ImportSpecifier");
};
ee.parseImportDefaultSpecifier = function() {
  var e = this.startNode();
  return e.local = this.parseIdent(), this.checkLValSimple(e.local, Fn), this.finishNode(e, "ImportDefaultSpecifier");
};
ee.parseImportNamespaceSpecifier = function() {
  var e = this.startNode();
  return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, Fn), this.finishNode(e, "ImportNamespaceSpecifier");
};
ee.parseImportSpecifiers = function() {
  var e = [], t = !0;
  if (this.type === b.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(b.comma)))
    return e;
  if (this.type === b.star)
    return e.push(this.parseImportNamespaceSpecifier()), e;
  for (this.expect(b.braceL); !this.eat(b.braceR); ) {
    if (t)
      t = !1;
    else if (this.expect(b.comma), this.afterTrailingComma(b.braceR))
      break;
    e.push(this.parseImportSpecifier());
  }
  return e;
};
ee.parseWithClause = function() {
  var e = [];
  if (!this.eat(b._with))
    return e;
  this.expect(b.braceL);
  for (var t = {}, n = !0; !this.eat(b.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(b.comma), this.afterTrailingComma(b.braceR))
      break;
    var r = this.parseImportAttribute(), i = r.key.type === "Identifier" ? r.key.name : r.key.value;
    Fr(t, i) && this.raiseRecoverable(r.key.start, "Duplicate attribute key '" + i + "'"), t[i] = !0, e.push(r);
  }
  return e;
};
ee.parseImportAttribute = function() {
  var e = this.startNode();
  return e.key = this.type === b.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(b.colon), this.type !== b.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
};
ee.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === b.string) {
    var e = this.parseLiteral(this.value);
    return Qv.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
  }
  return this.parseIdent(!0);
};
ee.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
ee.isDirectiveCandidate = function(e) {
  return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var Tt = Qe.prototype;
Tt.toAssignable = function(e, t, n) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
        for (var r = 0, i = e.properties; r < i.length; r += 1) {
          var s = i[r];
          this.toAssignable(s, t), s.type === "RestElement" && (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") && this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else n && this.checkPatternErrors(n, !0);
  return e;
};
Tt.toAssignableList = function(e, t) {
  for (var n = e.length, r = 0; r < n; r++) {
    var i = e[r];
    i && this.toAssignable(i, t);
  }
  if (n) {
    var s = e[n - 1];
    this.options.ecmaVersion === 6 && t && s && s.type === "RestElement" && s.argument.type !== "Identifier" && this.unexpected(s.argument.start);
  }
  return e;
};
Tt.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
};
Tt.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== b.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
Tt.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case b.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(b.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
      case b.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
Tt.parseBindingList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); )
    if (s ? s = !1 : this.expect(b.comma), t && this.type === b.comma)
      i.push(null);
    else {
      if (n && this.afterTrailingComma(e))
        break;
      if (this.type === b.ellipsis) {
        var u = this.parseRestBinding();
        this.parseBindingListItem(u), i.push(u), this.type === b.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else
        i.push(this.parseAssignableListItem(r));
    }
  return i;
};
Tt.parseAssignableListItem = function(e) {
  var t = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(t), t;
};
Tt.parseBindingListItem = function(e) {
  return e;
};
Tt.parseMaybeDefault = function(e, t, n) {
  if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(b.eq))
    return n;
  var r = this.startNodeAt(e, t);
  return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, "AssignmentPattern");
};
Tt.checkLValSimple = function(e, t, n) {
  t === void 0 && (t = Xi);
  var r = t !== Xi;
  switch (e.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (r ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (t === Fn && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), n && (Fr(n, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), n[e.name] = !0), t !== gm && this.declareName(e.name, t, e.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      r && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return r && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, n);
    default:
      this.raise(e.start, (r ? "Binding" : "Assigning to") + " rvalue");
  }
};
Tt.checkLValPattern = function(e, t, n) {
  switch (t === void 0 && (t = Xi), e.type) {
    case "ObjectPattern":
      for (var r = 0, i = e.properties; r < i.length; r += 1) {
        var s = i[r];
        this.checkLValInnerPattern(s, t, n);
      }
      break;
    case "ArrayPattern":
      for (var u = 0, a = e.elements; u < a.length; u += 1) {
        var o = a[u];
        o && this.checkLValInnerPattern(o, t, n);
      }
      break;
    default:
      this.checkLValSimple(e, t, n);
  }
};
Tt.checkLValInnerPattern = function(e, t, n) {
  switch (t === void 0 && (t = Xi), e.type) {
    case "Property":
      this.checkLValInnerPattern(e.value, t, n);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(e.left, t, n);
      break;
    case "RestElement":
      this.checkLValPattern(e.argument, t, n);
      break;
    default:
      this.checkLValPattern(e, t, n);
  }
};
var Wt = function(t, n, r, i, s) {
  this.token = t, this.isExpr = !!n, this.preserveSpace = !!r, this.override = i, this.generator = !!s;
}, We = {
  b_stat: new Wt("{", !1),
  b_expr: new Wt("{", !0),
  b_tmpl: new Wt("${", !1),
  p_stat: new Wt("(", !1),
  p_expr: new Wt("(", !0),
  q_tmpl: new Wt("`", !0, !0, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new Wt("function", !1),
  f_expr: new Wt("function", !0),
  f_expr_gen: new Wt("function", !0, !1, null, !0),
  f_gen: new Wt("function", !1, !1, null, !0)
}, xr = Qe.prototype;
xr.initialContext = function() {
  return [We.b_stat];
};
xr.curContext = function() {
  return this.context[this.context.length - 1];
};
xr.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === We.f_expr || t === We.f_stat ? !0 : e === b.colon && (t === We.b_stat || t === We.b_expr) ? !t.isExpr : e === b._return || e === b.name && this.exprAllowed ? It.test(this.input.slice(this.lastTokEnd, this.start)) : e === b._else || e === b.semi || e === b.eof || e === b.parenR || e === b.arrow ? !0 : e === b.braceL ? t === We.b_stat : e === b._var || e === b._const || e === b.name ? !1 : !this.exprAllowed;
};
xr.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return !1;
};
xr.updateContext = function(e) {
  var t, n = this.type;
  n.keyword && e === b.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr;
};
xr.overrideContext = function(e) {
  this.curContext() !== e && (this.context[this.context.length - 1] = e);
};
b.parenR.updateContext = b.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var e = this.context.pop();
  e === We.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
b.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? We.b_stat : We.b_expr), this.exprAllowed = !0;
};
b.dollarBraceL.updateContext = function() {
  this.context.push(We.b_tmpl), this.exprAllowed = !0;
};
b.parenL.updateContext = function(e) {
  var t = e === b._if || e === b._for || e === b._with || e === b._while;
  this.context.push(t ? We.p_stat : We.p_expr), this.exprAllowed = !0;
};
b.incDec.updateContext = function() {
};
b._function.updateContext = b._class.updateContext = function(e) {
  e.beforeExpr && e !== b._else && !(e === b.semi && this.curContext() !== We.p_stat) && !(e === b._return && It.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === b.colon || e === b.braceL) && this.curContext() === We.b_stat) ? this.context.push(We.f_expr) : this.context.push(We.f_stat), this.exprAllowed = !1;
};
b.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
b.backQuote.updateContext = function() {
  this.curContext() === We.q_tmpl ? this.context.pop() : this.context.push(We.q_tmpl), this.exprAllowed = !1;
};
b.star.updateContext = function(e) {
  if (e === b._function) {
    var t = this.context.length - 1;
    this.context[t] === We.f_expr ? this.context[t] = We.f_expr_gen : this.context[t] = We.f_gen;
  }
  this.exprAllowed = !0;
};
b.name.updateContext = function(e) {
  var t = !1;
  this.options.ecmaVersion >= 6 && e !== b.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
};
var ce = Qe.prototype;
ce.checkPropClash = function(e, t, n) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var r = e.key, i;
    switch (r.type) {
      case "Identifier":
        i = r.name;
        break;
      case "Literal":
        i = String(r.value);
        break;
      default:
        return;
    }
    var s = e.kind;
    if (this.options.ecmaVersion >= 6) {
      i === "__proto__" && s === "init" && (t.proto && (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), t.proto = !0);
      return;
    }
    i = "$" + i;
    var u = t[i];
    if (u) {
      var a;
      s === "init" ? a = this.strict && u.init || u.get || u.set : a = u.init || u[s], a && this.raiseRecoverable(r.start, "Redefinition of property");
    } else
      u = t[i] = {
        init: !1,
        get: !1,
        set: !1
      };
    u[s] = !0;
  }
};
ce.parseExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeAssign(e, t);
  if (this.type === b.comma) {
    var s = this.startNodeAt(n, r);
    for (s.expressions = [i]; this.eat(b.comma); )
      s.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(s, "SequenceExpression");
  }
  return i;
};
ce.parseMaybeAssign = function(e, t, n) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = !1;
  }
  var r = !1, i = -1, s = -1, u = -1;
  t ? (i = t.parenthesizedAssign, s = t.trailingComma, u = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new ss(), r = !0);
  var a = this.start, o = this.startLoc;
  (this.type === b.parenL || this.type === b.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
  var f = this.parseMaybeConditional(e, t);
  if (n && (f = n.call(this, f, a, o)), this.type.isAssign) {
    var h = this.startNodeAt(a, o);
    return h.operator = this.value, this.type === b.eq && (f = this.toAssignable(f, !1, t)), r || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= f.start && (t.shorthandAssign = -1), this.type === b.eq ? this.checkLValPattern(f) : this.checkLValSimple(f), h.left = f, this.next(), h.right = this.parseMaybeAssign(e), u > -1 && (t.doubleProto = u), this.finishNode(h, "AssignmentExpression");
  } else
    r && this.checkExpressionErrors(t, !0);
  return i > -1 && (t.parenthesizedAssign = i), s > -1 && (t.trailingComma = s), f;
};
ce.parseMaybeConditional = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return i;
  if (this.eat(b.question)) {
    var s = this.startNodeAt(n, r);
    return s.test = i, s.consequent = this.parseMaybeAssign(), this.expect(b.colon), s.alternate = this.parseMaybeAssign(e), this.finishNode(s, "ConditionalExpression");
  }
  return i;
};
ce.parseExprOps = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeUnary(t, !1, !1, e);
  return this.checkExpressionErrors(t) || i.start === n && i.type === "ArrowFunctionExpression" ? i : this.parseExprOp(i, n, r, -1, e);
};
ce.parseExprOp = function(e, t, n, r, i) {
  var s = this.type.binop;
  if (s != null && (!i || this.type !== b._in) && s > r) {
    var u = this.type === b.logicalOR || this.type === b.logicalAND, a = this.type === b.coalesce;
    a && (s = b.logicalAND.binop);
    var o = this.value;
    this.next();
    var f = this.start, h = this.startLoc, m = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, i), f, h, s, i), p = this.buildBinary(t, n, e, m, o, u || a);
    return (u && this.type === b.coalesce || a && (this.type === b.logicalOR || this.type === b.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, t, n, r, i);
  }
  return e;
};
ce.buildBinary = function(e, t, n, r, i, s) {
  r.type === "PrivateIdentifier" && this.raise(r.start, "Private identifier can only be left side of binary expression");
  var u = this.startNodeAt(e, t);
  return u.left = n, u.operator = i, u.right = r, this.finishNode(u, s ? "LogicalExpression" : "BinaryExpression");
};
ce.parseMaybeUnary = function(e, t, n, r) {
  var i = this.start, s = this.startLoc, u;
  if (this.isContextual("await") && this.canAwait)
    u = this.parseAwait(r), t = !0;
  else if (this.type.prefix) {
    var a = this.startNode(), o = this.type === b.incDec;
    a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0, o, r), this.checkExpressionErrors(e, !0), o ? this.checkLValSimple(a.argument) : this.strict && a.operator === "delete" && Am(a.argument) ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : a.operator === "delete" && bu(a.argument) ? this.raiseRecoverable(a.start, "Private fields can not be deleted") : t = !0, u = this.finishNode(a, o ? "UpdateExpression" : "UnaryExpression");
  } else if (!t && this.type === b.privateId)
    (r || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), u = this.parsePrivateIdent(), this.type !== b._in && this.unexpected();
  else {
    if (u = this.parseExprSubscripts(e, r), this.checkExpressionErrors(e))
      return u;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var f = this.startNodeAt(i, s);
      f.operator = this.value, f.prefix = !1, f.argument = u, this.checkLValSimple(u), this.next(), u = this.finishNode(f, "UpdateExpression");
    }
  }
  if (!n && this.eat(b.starstar))
    if (t)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(i, s, u, this.parseMaybeUnary(null, !1, !1, r), "**", !1);
  else
    return u;
};
function Am(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && Am(e.expression);
}
function bu(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && bu(e.expression) || e.type === "ParenthesizedExpression" && bu(e.expression);
}
ce.parseExprSubscripts = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprAtom(e, t);
  if (i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return i;
  var s = this.parseSubscripts(i, n, r, !1, t);
  return e && s.type === "MemberExpression" && (e.parenthesizedAssign >= s.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= s.start && (e.parenthesizedBind = -1), e.trailingComma >= s.start && (e.trailingComma = -1)), s;
};
ce.parseSubscripts = function(e, t, n, r, i) {
  for (var s = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, u = !1; ; ) {
    var a = this.parseSubscript(e, t, n, r, s, u, i);
    if (a.optional && (u = !0), a === e || a.type === "ArrowFunctionExpression") {
      if (u) {
        var o = this.startNodeAt(t, n);
        o.expression = a, a = this.finishNode(o, "ChainExpression");
      }
      return a;
    }
    e = a;
  }
};
ce.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(b.arrow);
};
ce.parseSubscriptAsyncArrow = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !0, r);
};
ce.parseSubscript = function(e, t, n, r, i, s, u) {
  var a = this.options.ecmaVersion >= 11, o = a && this.eat(b.questionDot);
  r && o && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var f = this.eat(b.bracketL);
  if (f || o && this.type !== b.parenL && this.type !== b.backQuote || this.eat(b.dot)) {
    var h = this.startNodeAt(t, n);
    h.object = e, f ? (h.property = this.parseExpression(), this.expect(b.bracketR)) : this.type === b.privateId && e.type !== "Super" ? h.property = this.parsePrivateIdent() : h.property = this.parseIdent(this.options.allowReserved !== "never"), h.computed = !!f, a && (h.optional = o), e = this.finishNode(h, "MemberExpression");
  } else if (!r && this.eat(b.parenL)) {
    var m = new ss(), p = this.yieldPos, A = this.awaitPos, M = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var C = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1, m);
    if (i && !o && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(m, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = A, this.awaitIdentPos = M, this.parseSubscriptAsyncArrow(t, n, C, u);
    this.checkExpressionErrors(m, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = A || this.awaitPos, this.awaitIdentPos = M || this.awaitIdentPos;
    var F = this.startNodeAt(t, n);
    F.callee = e, F.arguments = C, a && (F.optional = o), e = this.finishNode(F, "CallExpression");
  } else if (this.type === b.backQuote) {
    (o || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var _ = this.startNodeAt(t, n);
    _.tag = e, _.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(_, "TaggedTemplateExpression");
  }
  return e;
};
ce.parseExprAtom = function(e, t, n) {
  this.type === b.slash && this.readRegexp();
  var r, i = this.potentialArrowAt === this.start;
  switch (this.type) {
    case b._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === b.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== b.dot && this.type !== b.bracketL && this.type !== b.parenL && this.unexpected(), this.finishNode(r, "Super");
    case b._this:
      return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
    case b.name:
      var s = this.start, u = this.startLoc, a = this.containsEsc, o = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !a && o.name === "async" && !this.canInsertSemicolon() && this.eat(b._function))
        return this.overrideContext(We.f_expr), this.parseFunction(this.startNodeAt(s, u), 0, !1, !0, t);
      if (i && !this.canInsertSemicolon()) {
        if (this.eat(b.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, u), [o], !1, t);
        if (this.options.ecmaVersion >= 8 && o.name === "async" && this.type === b.name && !a && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return o = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(b.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, u), [o], !0, t);
      }
      return o;
    case b.regexp:
      var f = this.value;
      return r = this.parseLiteral(f.value), r.regex = { pattern: f.pattern, flags: f.flags }, r;
    case b.num:
    case b.string:
      return this.parseLiteral(this.value);
    case b._null:
    case b._true:
    case b._false:
      return r = this.startNode(), r.value = this.type === b._null ? null : this.type === b._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
    case b.parenL:
      var h = this.start, m = this.parseParenAndDistinguishExpression(i, t);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(m) && (e.parenthesizedAssign = h), e.parenthesizedBind < 0 && (e.parenthesizedBind = h)), m;
    case b.bracketL:
      return r = this.startNode(), this.next(), r.elements = this.parseExprList(b.bracketR, !0, !0, e), this.finishNode(r, "ArrayExpression");
    case b.braceL:
      return this.overrideContext(We.b_expr), this.parseObj(!1, e);
    case b._function:
      return r = this.startNode(), this.next(), this.parseFunction(r, 0);
    case b._class:
      return this.parseClass(this.startNode(), !1);
    case b._new:
      return this.parseNew();
    case b.backQuote:
      return this.parseTemplate();
    case b._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
ce.parseExprAtomDefault = function() {
  this.unexpected();
};
ce.parseExprImport = function(e) {
  var t = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === b.parenL && !e)
    return this.parseDynamicImport(t);
  if (this.type === b.dot) {
    var n = this.startNodeAt(t.start, t.loc && t.loc.start);
    return n.name = "import", t.meta = this.finishNode(n, "Identifier"), this.parseImportMeta(t);
  } else
    this.unexpected();
};
ce.parseDynamicImport = function(e) {
  if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
    this.eat(b.parenR) ? e.options = null : (this.expect(b.comma), this.afterTrailingComma(b.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(b.parenR) || (this.expect(b.comma), this.afterTrailingComma(b.parenR) || this.unexpected())));
  else if (!this.eat(b.parenR)) {
    var t = this.start;
    this.eat(b.comma) && this.eat(b.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
  }
  return this.finishNode(e, "ImportExpression");
};
ce.parseImportMeta = function(e) {
  this.next();
  var t = this.containsEsc;
  return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
};
ce.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
};
ce.parseParenExpression = function() {
  this.expect(b.parenL);
  var e = this.parseExpression();
  return this.expect(b.parenR), e;
};
ce.shouldParseArrow = function(e) {
  return !this.canInsertSemicolon();
};
ce.parseParenAndDistinguishExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i, s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var u = this.start, a = this.startLoc, o = [], f = !0, h = !1, m = new ss(), p = this.yieldPos, A = this.awaitPos, M;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== b.parenR; )
      if (f ? f = !1 : this.expect(b.comma), s && this.afterTrailingComma(b.parenR, !0)) {
        h = !0;
        break;
      } else if (this.type === b.ellipsis) {
        M = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === b.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        o.push(this.parseMaybeAssign(!1, m, this.parseParenItem));
    var C = this.lastTokEnd, F = this.lastTokEndLoc;
    if (this.expect(b.parenR), e && this.shouldParseArrow(o) && this.eat(b.arrow))
      return this.checkPatternErrors(m, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = A, this.parseParenArrowList(n, r, o, t);
    (!o.length || h) && this.unexpected(this.lastTokStart), M && this.unexpected(M), this.checkExpressionErrors(m, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = A || this.awaitPos, o.length > 1 ? (i = this.startNodeAt(u, a), i.expressions = o, this.finishNodeAt(i, "SequenceExpression", C, F)) : i = o[0];
  } else
    i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var _ = this.startNodeAt(n, r);
    return _.expression = i, this.finishNode(_, "ParenthesizedExpression");
  } else
    return i;
};
ce.parseParenItem = function(e) {
  return e;
};
ce.parseParenArrowList = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !1, r);
};
var uP = [];
ce.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var e = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === b.dot) {
    var t = this.startNodeAt(e.start, e.loc && e.loc.start);
    t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
    var n = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
  }
  var r = this.start, i = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), r, i, !0, !1), this.eat(b.parenL) ? e.arguments = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = uP, this.finishNode(e, "NewExpression");
};
ce.parseTemplateElement = function(e) {
  var t = e.isTagged, n = this.startNode();
  return this.type === b.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
    raw: this.value.replace(/\r\n?/g, `
`),
    cooked: null
  }) : n.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), n.tail = this.type === b.backQuote, this.finishNode(n, "TemplateElement");
};
ce.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = !1);
  var n = this.startNode();
  this.next(), n.expressions = [];
  var r = this.parseTemplateElement({ isTagged: t });
  for (n.quasis = [r]; !r.tail; )
    this.type === b.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(b.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(b.braceR), n.quasis.push(r = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(n, "TemplateLiteral");
};
ce.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === b.name || this.type === b.num || this.type === b.string || this.type === b.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === b.star) && !It.test(this.input.slice(this.lastTokEnd, this.start));
};
ce.parseObj = function(e, t) {
  var n = this.startNode(), r = !0, i = {};
  for (n.properties = [], this.next(); !this.eat(b.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(b.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(b.braceR))
      break;
    var s = this.parseProperty(e, t);
    e || this.checkPropClash(s, i, t), n.properties.push(s);
  }
  return this.finishNode(n, e ? "ObjectPattern" : "ObjectExpression");
};
ce.parseProperty = function(e, t) {
  var n = this.startNode(), r, i, s, u;
  if (this.options.ecmaVersion >= 9 && this.eat(b.ellipsis))
    return e ? (n.argument = this.parseIdent(!1), this.type === b.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(n, "RestElement")) : (n.argument = this.parseMaybeAssign(!1, t), this.type === b.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(n, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (n.method = !1, n.shorthand = !1, (e || t) && (s = this.start, u = this.startLoc), e || (r = this.eat(b.star)));
  var a = this.containsEsc;
  return this.parsePropertyName(n), !e && !a && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(n) ? (i = !0, r = this.options.ecmaVersion >= 9 && this.eat(b.star), this.parsePropertyName(n)) : i = !1, this.parsePropertyValue(n, e, r, i, s, u, t, a), this.finishNode(n, "Property");
};
ce.parseGetterSetter = function(e) {
  e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1);
  var t = e.kind === "get" ? 0 : 1;
  if (e.value.params.length !== t) {
    var n = e.value.start;
    e.kind === "get" ? this.raiseRecoverable(n, "getter should have no params") : this.raiseRecoverable(n, "setter should have exactly one param");
  } else
    e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
};
ce.parsePropertyValue = function(e, t, n, r, i, s, u, a) {
  (n || r) && this.type === b.colon && this.unexpected(), this.eat(b.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, u), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === b.parenL ? (t && this.unexpected(), e.kind = "init", e.method = !0, e.value = this.parseMethod(n, r)) : !t && !a && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== b.comma && this.type !== b.braceR && this.type !== b.eq ? ((n || r) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((n || r) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = i), e.kind = "init", t ? e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key)) : this.type === b.eq && u ? (u.shorthandAssign < 0 && (u.shorthandAssign = this.start), e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = !0) : this.unexpected();
};
ce.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(b.bracketL))
      return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(b.bracketR), e.key;
    e.computed = !1;
  }
  return e.key = this.type === b.num || this.type === b.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
ce.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
};
ce.parseMethod = function(e, t, n) {
  var r = this.startNode(), i = this.yieldPos, s = this.awaitPos, u = this.awaitIdentPos;
  return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(ba(t, r.generator) | ya | (n ? pm : 0)), this.expect(b.parenL), r.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1, !0, !1), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = u, this.finishNode(r, "FunctionExpression");
};
ce.parseArrowExpression = function(e, t, n, r) {
  var i = this.yieldPos, s = this.awaitPos, u = this.awaitIdentPos;
  return this.enterScope(ba(n, !1) | fm), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, r), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = u, this.finishNode(e, "ArrowFunctionExpression");
};
ce.parseFunctionBody = function(e, t, n, r) {
  var i = t && this.type !== b.braceL, s = this.strict, u = !1;
  if (i)
    e.body = this.parseMaybeAssign(r), e.expression = !0, this.checkParams(e, !1);
  else {
    var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!s || a) && (u = this.strictDirective(this.end), u && a && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], u && (this.strict = !0), this.checkParams(e, !s && !u && !t && !n && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, gm), e.body = this.parseBlock(!1, void 0, u && !s), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = o;
  }
  this.exitScope();
};
ce.isSimpleParamList = function(e) {
  for (var t = 0, n = e; t < n.length; t += 1) {
    var r = n[t];
    if (r.type !== "Identifier")
      return !1;
  }
  return !0;
};
ce.checkParams = function(e, t) {
  for (var n = /* @__PURE__ */ Object.create(null), r = 0, i = e.params; r < i.length; r += 1) {
    var s = i[r];
    this.checkLValInnerPattern(s, Ma, t ? null : n);
  }
};
ce.parseExprList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); ) {
    if (s)
      s = !1;
    else if (this.expect(b.comma), t && this.afterTrailingComma(e))
      break;
    var u = void 0;
    n && this.type === b.comma ? u = null : this.type === b.ellipsis ? (u = this.parseSpread(r), r && this.type === b.comma && r.trailingComma < 0 && (r.trailingComma = this.start)) : u = this.parseMaybeAssign(!1, r), i.push(u);
  }
  return i;
};
ce.checkUnreserved = function(e) {
  var t = e.start, n = e.end, r = e.name;
  if (this.inGenerator && r === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && r === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (r === "arguments" || r === "await") && this.raise(t, "Cannot use " + r + " in class static initialization block"), this.keywords.test(r) && this.raise(t, "Unexpected keyword '" + r + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, n).indexOf("\\") !== -1)) {
    var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
    i.test(r) && (!this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + r + "' is reserved"));
  }
};
ce.parseIdent = function(e) {
  var t = this.parseIdentNode();
  return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t;
};
ce.parseIdentNode = function() {
  var e = this.startNode();
  return this.type === b.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = b.name) : this.unexpected(), e;
};
ce.parsePrivateIdent = function() {
  var e = this.startNode();
  return this.type === b.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
};
ce.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === b.semi || this.canInsertSemicolon() || this.type !== b.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(b.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
ce.parseAwait = function(e) {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
};
var Oi = Qe.prototype;
Oi.raise = function(e, t) {
  var n = cm(this.input, e);
  t += " (" + n.line + ":" + n.column + ")";
  var r = new SyntaxError(t);
  throw r.pos = e, r.loc = n, r.raisedAt = this.pos, r;
};
Oi.raiseRecoverable = Oi.raise;
Oi.curPosition = function() {
  if (this.options.locations)
    return new ui(this.curLine, this.pos - this.lineStart);
};
var Gn = Qe.prototype, aP = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
Gn.enterScope = function(e) {
  this.scopeStack.push(new aP(e));
};
Gn.exitScope = function() {
  this.scopeStack.pop();
};
Gn.treatFunctionsAsVarInScope = function(e) {
  return e.flags & Er || !this.inModule && e.flags & ai;
};
Gn.declareName = function(e, t, n) {
  var r = !1;
  if (t === Fn) {
    var i = this.currentScope();
    r = i.lexical.indexOf(e) > -1 || i.functions.indexOf(e) > -1 || i.var.indexOf(e) > -1, i.lexical.push(e), this.inModule && i.flags & ai && delete this.undefinedExports[e];
  } else if (t === mm) {
    var s = this.currentScope();
    s.lexical.push(e);
  } else if (t === dm) {
    var u = this.currentScope();
    this.treatFunctionsAsVar ? r = u.lexical.indexOf(e) > -1 : r = u.lexical.indexOf(e) > -1 || u.var.indexOf(e) > -1, u.functions.push(e);
  } else
    for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var o = this.scopeStack[a];
      if (o.lexical.indexOf(e) > -1 && !(o.flags & hm && o.lexical[0] === e) || !this.treatFunctionsAsVarInScope(o) && o.functions.indexOf(e) > -1) {
        r = !0;
        break;
      }
      if (o.var.push(e), this.inModule && o.flags & ai && delete this.undefinedExports[e], o.flags & Aa)
        break;
    }
  r && this.raiseRecoverable(n, "Identifier '" + e + "' has already been declared");
};
Gn.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Gn.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Gn.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & Aa)
      return t;
  }
};
Gn.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & Aa && !(t.flags & fm))
      return t;
  }
};
var us = function(t, n, r) {
  this.type = "", this.start = n, this.end = 0, t.options.locations && (this.loc = new is(t, r)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [n, 0]);
}, di = Qe.prototype;
di.startNode = function() {
  return new us(this, this.start, this.startLoc);
};
di.startNodeAt = function(e, t) {
  return new us(this, e, t);
};
function bm(e, t, n, r) {
  return e.type = t, e.end = n, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = n), e;
}
di.finishNode = function(e, t) {
  return bm.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
di.finishNodeAt = function(e, t, n, r) {
  return bm.call(this, e, t, n, r);
};
di.copyNode = function(e) {
  var t = new us(this, e.start, this.startLoc);
  for (var n in e)
    t[n] = e[n];
  return t;
};
var oP = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", Mm = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Cm = Mm + " Extended_Pictographic", vm = Cm, Pm = vm + " EBase EComp EMod EPres ExtPict", Dm = Pm, cP = Dm, lP = {
  9: Mm,
  10: Cm,
  11: vm,
  12: Pm,
  13: Dm,
  14: cP
}, fP = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", hP = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: fP
}, So = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Fm = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Em = Fm + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", xm = Em + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", wm = xm + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Sm = wm + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", pP = Sm + " " + oP, dP = {
  9: Fm,
  10: Em,
  11: xm,
  12: wm,
  13: Sm,
  14: pP
}, Bm = {};
function mP(e) {
  var t = Bm[e] = {
    binary: Vn(lP[e] + " " + So),
    binaryOfStrings: Vn(hP[e]),
    nonBinary: {
      General_Category: Vn(So),
      Script: Vn(dP[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
for (var Zs = 0, Bo = [9, 10, 11, 12, 13, 14]; Zs < Bo.length; Zs += 1) {
  var gP = Bo[Zs];
  mP(gP);
}
var J = Qe.prototype, zi = function(t, n) {
  this.parent = t, this.base = n || this;
};
zi.prototype.separatedFrom = function(t) {
  for (var n = this; n; n = n.parent)
    for (var r = t; r; r = r.parent)
      if (n.base === r.base && n !== r)
        return !0;
  return !1;
};
zi.prototype.sibling = function() {
  return new zi(this.parent, this.base);
};
var cn = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Bm[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
};
cn.prototype.reset = function(t, n, r) {
  var i = r.indexOf("v") !== -1, s = r.indexOf("u") !== -1;
  this.start = t | 0, this.source = n + "", this.flags = r, i && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
};
cn.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
cn.prototype.at = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return -1;
  var s = r.charCodeAt(t);
  if (!(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i)
    return s;
  var u = r.charCodeAt(t + 1);
  return u >= 56320 && u <= 57343 ? (s << 10) + u - 56613888 : s;
};
cn.prototype.nextIndex = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return i;
  var s = r.charCodeAt(t), u;
  return !(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i || (u = r.charCodeAt(t + 1)) < 56320 || u > 57343 ? t + 1 : t + 2;
};
cn.prototype.current = function(t) {
  return t === void 0 && (t = !1), this.at(this.pos, t);
};
cn.prototype.lookahead = function(t) {
  return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
};
cn.prototype.advance = function(t) {
  t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
};
cn.prototype.eat = function(t, n) {
  return n === void 0 && (n = !1), this.current(n) === t ? (this.advance(n), !0) : !1;
};
cn.prototype.eatChars = function(t, n) {
  n === void 0 && (n = !1);
  for (var r = this.pos, i = 0, s = t; i < s.length; i += 1) {
    var u = s[i], a = this.at(r, n);
    if (a === -1 || a !== u)
      return !1;
    r = this.nextIndex(r, n);
  }
  return this.pos = r, !0;
};
J.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, n = e.flags, r = !1, i = !1, s = 0; s < n.length; s++) {
    var u = n.charAt(s);
    t.indexOf(u) === -1 && this.raise(e.start, "Invalid regular expression flag"), n.indexOf(u, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), u === "u" && (r = !0), u === "v" && (i = !0);
  }
  this.options.ecmaVersion >= 15 && r && i && this.raise(e.start, "Invalid regular expression flag");
};
function yP(e) {
  for (var t in e)
    return !0;
  return !1;
}
J.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && yP(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
};
J.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* ] */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, n = e.backReferenceNames; t < n.length; t += 1) {
    var r = n[t];
    e.groupNames[r] || e.raise("Invalid named capture referenced");
  }
};
J.regexp_disjunction = function(e) {
  var t = this.options.ecmaVersion >= 16;
  for (t && (e.branchID = new zi(e.branchID, null)), this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
  t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
J.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
J.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
};
J.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = !1, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return !0;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return !0;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var n = !1;
    if (this.options.ecmaVersion >= 9 && (n = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !n, !0;
  }
  return e.pos = t, !1;
};
J.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), !0) : !1;
};
J.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
J.regexp_eatBracedQuantifier = function(e, t) {
  var n = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var r = 0, i = -1;
    if (this.regexp_eatDecimalDigits(e) && (r = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return i !== -1 && i < r && !t && e.raise("numbers out of order in {} quantifier"), !0;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = n;
  }
  return !1;
};
J.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
J.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var n = this.regexp_eatModifiers(e), r = e.eat(
          45
          /* - */
        );
        if (n || r) {
          for (var i = 0; i < n.length; i++) {
            var s = n.charAt(i);
            n.indexOf(s, i + 1) > -1 && e.raise("Duplicate regular expression modifiers");
          }
          if (r) {
            var u = this.regexp_eatModifiers(e);
            !n && !u && e.current() === 58 && e.raise("Invalid regular expression modifiers");
            for (var a = 0; a < u.length; a++) {
              var o = u.charAt(a);
              (u.indexOf(o, a + 1) > -1 || n.indexOf(o) > -1) && e.raise("Duplicate regular expression modifiers");
            }
          }
        }
      }
      if (e.eat(
        58
        /* : */
      )) {
        if (this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ))
          return !0;
        e.raise("Unterminated group");
      }
    }
    e.pos = t;
  }
  return !1;
};
J.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, !0;
    e.raise("Unterminated group");
  }
  return !1;
};
J.regexp_eatModifiers = function(e) {
  for (var t = "", n = 0; (n = e.current()) !== -1 && AP(n); )
    t += Pn(n), e.advance();
  return t;
};
function AP(e) {
  return e === 105 || e === 109 || e === 115;
}
J.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
J.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
};
J.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return _m(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function _m(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
J.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, n = 0; (n = e.current()) !== -1 && !_m(n); )
    e.advance();
  return e.pos !== t;
};
J.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
};
J.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    this.regexp_eatGroupName(e) || e.raise("Invalid group");
    var t = this.options.ecmaVersion >= 16, n = e.groupNames[e.lastStringValue];
    if (n)
      if (t)
        for (var r = 0, i = n; r < i.length; r += 1) {
          var s = i[r];
          s.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
        }
      else
        e.raise("Duplicate capture group name");
    t ? (n || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
  }
};
J.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return !0;
    e.raise("Invalid capture group name");
  }
  return !1;
};
J.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += Pn(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += Pn(e.lastIntValue);
    return !0;
  }
  return !1;
};
J.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), bP(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function bP(e) {
  return vn(e, !0) || e === 36 || e === 95;
}
J.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), MP(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function MP(e) {
  return yr(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
J.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
};
J.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var n = e.lastIntValue;
    if (e.switchU)
      return n > e.maxBackReference && (e.maxBackReference = n), !0;
    if (n <= e.numCapturingParens)
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), !0;
    e.raise("Invalid named reference");
  }
  return !1;
};
J.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
J.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatZero = function(e) {
  return e.current() === 48 && !as(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
};
J.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
};
J.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return km(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
function km(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
J.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
  t === void 0 && (t = !1);
  var n = e.pos, r = t || e.switchU;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var i = e.lastIntValue;
      if (r && i >= 55296 && i <= 56319) {
        var s = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var u = e.lastIntValue;
          if (u >= 56320 && u <= 57343)
            return e.lastIntValue = (i - 55296) * 1024 + (u - 56320) + 65536, !0;
        }
        e.pos = s, e.lastIntValue = i;
      }
      return !0;
    }
    if (r && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && CP(e.lastIntValue))
      return !0;
    r && e.raise("Invalid unicode escape"), e.pos = n;
  }
  return !1;
};
function CP(e) {
  return e >= 0 && e <= 1114111;
}
J.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, !0) : !1;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
J.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return !0;
  }
  return !1;
};
var Vm = 0, Dn = 1, _t = 2;
J.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (vP(t))
    return e.lastIntValue = -1, e.advance(), Dn;
  var n = !1;
  if (e.switchU && this.options.ecmaVersion >= 9 && ((n = t === 80) || t === 112)) {
    e.lastIntValue = -1, e.advance();
    var r;
    if (e.eat(
      123
      /* { */
    ) && (r = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
      125
      /* } */
    ))
      return n && r === _t && e.raise("Invalid property name"), r;
    e.raise("Invalid property name");
  }
  return Vm;
};
function vP(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
J.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var n = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var r = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, n, r), Dn;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var i = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, i);
  }
  return Vm;
};
J.regexp_validateUnicodePropertyNameAndValue = function(e, t, n) {
  Fr(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(n) || e.raise("Invalid property value");
};
J.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  if (e.unicodeProperties.binary.test(t))
    return Dn;
  if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
    return _t;
  e.raise("Invalid property name");
};
J.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; Im(t = e.current()); )
    e.lastStringValue += Pn(t), e.advance();
  return e.lastStringValue !== "";
};
function Im(e) {
  return km(e) || e === 95;
}
J.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; PP(t = e.current()); )
    e.lastStringValue += Pn(t), e.advance();
  return e.lastStringValue !== "";
};
function PP(e) {
  return Im(e) || as(e);
}
J.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
J.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    var t = e.eat(
      94
      /* ^ */
    ), n = this.regexp_classContents(e);
    return e.eat(
      93
      /* ] */
    ) || e.raise("Unterminated character class"), t && n === _t && e.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
J.regexp_classContents = function(e) {
  return e.current() === 93 ? Dn : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Dn);
};
J.regexp_nonEmptyClassRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var n = e.lastIntValue;
      e.switchU && (t === -1 || n === -1) && e.raise("Invalid character class"), t !== -1 && n !== -1 && t > n && e.raise("Range out of order in character class");
    }
  }
};
J.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return !0;
    if (e.switchU) {
      var n = e.current();
      (n === 99 || Lm(n)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var r = e.current();
  return r !== 93 ? (e.lastIntValue = r, e.advance(), !0) : !1;
};
J.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, !0;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, !0;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return !0;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
J.regexp_classSetExpression = function(e) {
  var t = Dn, n;
  if (!this.regexp_eatClassSetRange(e)) if (n = this.regexp_eatClassSetOperand(e)) {
    n === _t && (t = _t);
    for (var r = e.pos; e.eatChars(
      [38, 38]
      /* && */
    ); ) {
      if (e.current() !== 38 && (n = this.regexp_eatClassSetOperand(e))) {
        n !== _t && (t = Dn);
        continue;
      }
      e.raise("Invalid character in character class");
    }
    if (r !== e.pos)
      return t;
    for (; e.eatChars(
      [45, 45]
      /* -- */
    ); )
      this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
    if (r !== e.pos)
      return t;
  } else
    e.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(e)) {
      if (n = this.regexp_eatClassSetOperand(e), !n)
        return t;
      n === _t && (t = _t);
    }
};
J.regexp_eatClassSetRange = function(e) {
  var t = e.pos;
  if (this.regexp_eatClassSetCharacter(e)) {
    var n = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      return n !== -1 && r !== -1 && n > r && e.raise("Range out of order in character class"), !0;
    }
    e.pos = t;
  }
  return !1;
};
J.regexp_eatClassSetOperand = function(e) {
  return this.regexp_eatClassSetCharacter(e) ? Dn : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
};
J.regexp_eatNestedClass = function(e) {
  var t = e.pos;
  if (e.eat(
    91
    /* [ */
  )) {
    var n = e.eat(
      94
      /* ^ */
    ), r = this.regexp_classContents(e);
    if (e.eat(
      93
      /* ] */
    ))
      return n && r === _t && e.raise("Negated character class may contain strings"), r;
    e.pos = t;
  }
  if (e.eat(
    92
    /* \ */
  )) {
    var i = this.regexp_eatCharacterClassEscape(e);
    if (i)
      return i;
    e.pos = t;
  }
  return null;
};
J.regexp_eatClassStringDisjunction = function(e) {
  var t = e.pos;
  if (e.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (e.eat(
      123
      /* { */
    )) {
      var n = this.regexp_classStringDisjunctionContents(e);
      if (e.eat(
        125
        /* } */
      ))
        return n;
    } else
      e.raise("Invalid escape");
    e.pos = t;
  }
  return null;
};
J.regexp_classStringDisjunctionContents = function(e) {
  for (var t = this.regexp_classString(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_classString(e) === _t && (t = _t);
  return t;
};
J.regexp_classString = function(e) {
  for (var t = 0; this.regexp_eatClassSetCharacter(e); )
    t++;
  return t === 1 ? Dn : _t;
};
J.regexp_eatClassSetCharacter = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
      98
      /* b */
    ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
  var n = e.current();
  return n < 0 || n === e.lookahead() && DP(n) || FP(n) ? !1 : (e.advance(), e.lastIntValue = n, !0);
};
function DP(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function FP(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
J.regexp_eatClassSetReservedPunctuator = function(e) {
  var t = e.current();
  return EP(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function EP(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
J.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return as(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
J.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return !0;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return !1;
};
J.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; as(n = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (n - 48), e.advance();
  return e.pos !== t;
};
function as(e) {
  return e >= 48 && e <= 57;
}
J.regexp_eatHexDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; Tm(n = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + Nm(n), e.advance();
  return e.pos !== t;
};
function Tm(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function Nm(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
J.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var n = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + n * 8 + e.lastIntValue : e.lastIntValue = t * 8 + n;
    } else
      e.lastIntValue = t;
    return !0;
  }
  return !1;
};
J.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return Lm(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
};
function Lm(e) {
  return e >= 48 && e <= 55;
}
J.regexp_eatFixedHexDigits = function(e, t) {
  var n = e.pos;
  e.lastIntValue = 0;
  for (var r = 0; r < t; ++r) {
    var i = e.current();
    if (!Tm(i))
      return e.pos = n, !1;
    e.lastIntValue = 16 * e.lastIntValue + Nm(i), e.advance();
  }
  return !0;
};
var va = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new is(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
}, Me = Qe.prototype;
Me.next = function(e) {
  !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new va(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Me.getToken = function() {
  return this.next(), new va(this);
};
typeof Symbol < "u" && (Me[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === b.eof,
        value: t
      };
    }
  };
});
Me.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(b.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Me.readToken = function(e) {
  return vn(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
Me.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 56320)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
};
Me.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, n = this.input.indexOf("*/", this.pos += 2);
  if (n === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations)
    for (var r = void 0, i = t; (r = um(this.input, i, this.pos)) > -1; )
      ++this.curLine, i = this.lineStart = r;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(t + 2, n),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
Me.skipLineComment = function(e) {
  for (var t = this.pos, n = this.options.onComment && this.curPosition(), r = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !Dr(r); )
    r = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    n,
    this.curPosition()
  );
};
Me.skipSpace = function() {
  e: for (; this.pos < this.input.length; ) {
    var e = this.input.charCodeAt(this.pos);
    switch (e) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if (e > 8 && e < 14 || e >= 5760 && am.test(String.fromCharCode(e)))
          ++this.pos;
        else
          break e;
    }
  }
};
Me.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var n = this.type;
  this.type = e, this.value = t, this.updateContext(n);
};
Me.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(!0);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(b.ellipsis)) : (++this.pos, this.finishToken(b.dot));
};
Me.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(b.assign, 2) : this.finishOp(b.slash, 1);
};
Me.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1, r = e === 42 ? b.star : b.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++n, r = b.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(b.assign, n + 1) : this.finishOp(r, n);
};
Me.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t === e) {
    if (this.options.ecmaVersion >= 12) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n === 61)
        return this.finishOp(b.assign, 3);
    }
    return this.finishOp(e === 124 ? b.logicalOR : b.logicalAND, 2);
  }
  return t === 61 ? this.finishOp(b.assign, 2) : this.finishOp(e === 124 ? b.bitwiseOR : b.bitwiseAND, 1);
};
Me.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(b.assign, 2) : this.finishOp(b.bitwiseXOR, 1);
};
Me.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || It.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(b.incDec, 2) : t === 61 ? this.finishOp(b.assign, 2) : this.finishOp(b.plusMin, 1);
};
Me.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1;
  return t === e ? (n = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(b.assign, n + 1) : this.finishOp(b.bitShift, n)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (n = 2), this.finishOp(b.relational, n));
};
Me.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(b.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(b.arrow)) : this.finishOp(e === 61 ? b.eq : b.prefix, 1);
};
Me.readToken_question = function() {
  var e = this.options.ecmaVersion;
  if (e >= 11) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === 46) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n < 48 || n > 57)
        return this.finishOp(b.questionDot, 2);
    }
    if (t === 63) {
      if (e >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(b.assign, 3);
      }
      return this.finishOp(b.coalesce, 2);
    }
  }
  return this.finishOp(b.question, 1);
};
Me.readToken_numberSign = function() {
  var e = this.options.ecmaVersion, t = 35;
  if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), vn(t, !0) || t === 92))
    return this.finishToken(b.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + Pn(t) + "'");
};
Me.getTokenFromCode = function(e) {
  switch (e) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      return ++this.pos, this.finishToken(b.parenL);
    case 41:
      return ++this.pos, this.finishToken(b.parenR);
    case 59:
      return ++this.pos, this.finishToken(b.semi);
    case 44:
      return ++this.pos, this.finishToken(b.comma);
    case 91:
      return ++this.pos, this.finishToken(b.bracketL);
    case 93:
      return ++this.pos, this.finishToken(b.bracketR);
    case 123:
      return ++this.pos, this.finishToken(b.braceL);
    case 125:
      return ++this.pos, this.finishToken(b.braceR);
    case 58:
      return ++this.pos, this.finishToken(b.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(b.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(e);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(b.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + Pn(e) + "'");
};
Me.finishOp = function(e, t) {
  var n = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, n);
};
Me.readRegexp = function() {
  for (var e, t, n = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
    var r = this.input.charAt(this.pos);
    if (It.test(r) && this.raise(n, "Unterminated regular expression"), e)
      e = !1;
    else {
      if (r === "[")
        t = !0;
      else if (r === "]" && t)
        t = !1;
      else if (r === "/" && !t)
        break;
      e = r === "\\";
    }
    ++this.pos;
  }
  var i = this.input.slice(n, this.pos);
  ++this.pos;
  var s = this.pos, u = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var a = this.regexpState || (this.regexpState = new cn(this));
  a.reset(n, i, u), this.validateRegExpFlags(a), this.validateRegExpPattern(a);
  var o = null;
  try {
    o = new RegExp(i, u);
  } catch {
  }
  return this.finishToken(b.regexp, { pattern: i, flags: u, value: o });
};
Me.readInt = function(e, t, n) {
  for (var r = this.options.ecmaVersion >= 12 && t === void 0, i = n && this.input.charCodeAt(this.pos) === 48, s = this.pos, u = 0, a = 0, o = 0, f = t ?? 1 / 0; o < f; ++o, ++this.pos) {
    var h = this.input.charCodeAt(this.pos), m = void 0;
    if (r && h === 95) {
      i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), a === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), o === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), a = h;
      continue;
    }
    if (h >= 97 ? m = h - 97 + 10 : h >= 65 ? m = h - 65 + 10 : h >= 48 && h <= 57 ? m = h - 48 : m = 1 / 0, m >= e)
      break;
    a = h, u = u * e + m;
  }
  return r && a === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === s || t != null && this.pos - s !== t ? null : u;
};
function xP(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function Rm(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
Me.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var n = this.readInt(e);
  return n == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (n = Rm(this.input.slice(t, this.pos)), ++this.pos) : vn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(b.num, n);
};
Me.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
  var n = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  n && this.strict && this.raise(t, "Invalid number");
  var r = this.input.charCodeAt(this.pos);
  if (!n && !e && this.options.ecmaVersion >= 11 && r === 110) {
    var i = Rm(this.input.slice(t, this.pos));
    return ++this.pos, vn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(b.num, i);
  }
  n && /[89]/.test(this.input.slice(t, this.pos)) && (n = !1), r === 46 && !n && (++this.pos, this.readInt(10), r = this.input.charCodeAt(this.pos)), (r === 69 || r === 101) && !n && (r = this.input.charCodeAt(++this.pos), (r === 43 || r === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), vn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = xP(this.input.slice(t, this.pos), n);
  return this.finishToken(b.num, s);
};
Me.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var n = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(n, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
Me.readString = function(e) {
  for (var t = "", n = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var r = this.input.charCodeAt(this.pos);
    if (r === e)
      break;
    r === 92 ? (t += this.input.slice(n, this.pos), t += this.readEscapedChar(!1), n = this.pos) : r === 8232 || r === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Dr(r) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(n, this.pos++), this.finishToken(b.string, t);
};
var Gm = {};
Me.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === Gm)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = !1;
};
Me.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw Gm;
  this.raise(e, t);
};
Me.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var n = this.input.charCodeAt(this.pos);
    if (n === 96 || n === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === b.template || this.type === b.invalidTemplate) ? n === 36 ? (this.pos += 2, this.finishToken(b.dollarBraceL)) : (++this.pos, this.finishToken(b.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(b.template, e));
    if (n === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
    else if (Dr(n)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, n) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(n);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
Me.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      // fall through
      case "`":
        return this.finishToken(b.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        this.input[this.pos + 1] === `
` && ++this.pos;
      // fall through
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine, this.lineStart = this.pos + 1;
        break;
    }
  this.raise(this.start, "Unterminated template");
};
Me.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return Pn(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    // '\r\n'
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), e) {
        var n = this.pos - 1;
        this.invalidStringToken(
          n,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8);
        return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(i);
      }
      return Dr(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
  }
};
Me.readHexChar = function(e) {
  var t = this.pos, n = this.readInt(16, e);
  return n === null && this.invalidStringToken(t, "Bad character escape sequence"), n;
};
Me.readWord1 = function() {
  this.containsEsc = !1;
  for (var e = "", t = !0, n = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var i = this.fullCharCodeAtPos();
    if (yr(i, r))
      this.pos += i <= 65535 ? 1 : 2;
    else if (i === 92) {
      this.containsEsc = !0, e += this.input.slice(n, this.pos);
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var u = this.readCodePoint();
      (t ? vn : yr)(u, r) || this.invalidStringToken(s, "Invalid Unicode escape"), e += Pn(u), n = this.pos;
    } else
      break;
    t = !1;
  }
  return e + this.input.slice(n, this.pos);
};
Me.readWord = function() {
  var e = this.readWord1(), t = b.name;
  return this.keywords.test(e) && (t = ma[e]), this.finishToken(t, e);
};
var wP = "8.14.0";
Qe.acorn = {
  Parser: Qe,
  version: wP,
  defaultOptions: yu,
  Position: ui,
  SourceLocation: is,
  getLineInfo: cm,
  Node: us,
  TokenType: De,
  tokTypes: b,
  keywordTypes: ma,
  TokContext: Wt,
  tokContexts: We,
  isIdentifierChar: yr,
  isIdentifierStart: vn,
  Token: va,
  isNewLine: Dr,
  lineBreak: It,
  lineBreakG: Yv,
  nonASCIIwhitespace: am
};
function SP(e, t) {
  return Qe.parse(e, t);
}
var BP = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function _P(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var Xs = {}, Ws = {}, _o;
function kP() {
  return _o || (_o = 1, function(e) {
    (function t(n) {
      var r, i, s, u, a, o;
      function f(x) {
        var B = {}, V, T;
        for (V in x)
          x.hasOwnProperty(V) && (T = x[V], typeof T == "object" && T !== null ? B[V] = f(T) : B[V] = T);
        return B;
      }
      function h(x, B) {
        var V, T, H, X;
        for (T = x.length, H = 0; T; )
          V = T >>> 1, X = H + V, B(x[X]) ? T = V : (H = X + 1, T -= V + 1);
        return H;
      }
      r = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, s = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, u = {}, a = {}, o = {}, i = {
        Break: u,
        Skip: a,
        Remove: o
      };
      function m(x, B) {
        this.parent = x, this.key = B;
      }
      m.prototype.replace = function(B) {
        this.parent[this.key] = B;
      }, m.prototype.remove = function() {
        return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
      };
      function p(x, B, V, T) {
        this.node = x, this.path = B, this.wrap = V, this.ref = T;
      }
      function A() {
      }
      A.prototype.path = function() {
        var B, V, T, H, X, U;
        function O(z, te) {
          if (Array.isArray(te))
            for (T = 0, H = te.length; T < H; ++T)
              z.push(te[T]);
          else
            z.push(te);
        }
        if (!this.__current.path)
          return null;
        for (X = [], B = 2, V = this.__leavelist.length; B < V; ++B)
          U = this.__leavelist[B], O(X, U.path);
        return O(X, this.__current.path), X;
      }, A.prototype.type = function() {
        var x = this.current();
        return x.type || this.__current.wrap;
      }, A.prototype.parents = function() {
        var B, V, T;
        for (T = [], B = 1, V = this.__leavelist.length; B < V; ++B)
          T.push(this.__leavelist[B].node);
        return T;
      }, A.prototype.current = function() {
        return this.__current.node;
      }, A.prototype.__execute = function(B, V) {
        var T, H;
        return H = void 0, T = this.__current, this.__current = V, this.__state = null, B && (H = B.call(this, V.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = T, H;
      }, A.prototype.notify = function(B) {
        this.__state = B;
      }, A.prototype.skip = function() {
        this.notify(a);
      }, A.prototype.break = function() {
        this.notify(u);
      }, A.prototype.remove = function() {
        this.notify(o);
      }, A.prototype.__initialize = function(x, B) {
        this.visitor = B, this.root = x, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, B.fallback === "iteration" ? this.__fallback = Object.keys : typeof B.fallback == "function" && (this.__fallback = B.fallback), this.__keys = s, B.keys && (this.__keys = Object.assign(Object.create(this.__keys), B.keys));
      };
      function M(x) {
        return x == null ? !1 : typeof x == "object" && typeof x.type == "string";
      }
      function C(x, B) {
        return (x === r.ObjectExpression || x === r.ObjectPattern) && B === "properties";
      }
      function F(x, B) {
        for (var V = x.length - 1; V >= 0; --V)
          if (x[V].node === B)
            return !0;
        return !1;
      }
      A.prototype.traverse = function(B, V) {
        var T, H, X, U, O, z, te, me, pe, le, ie, ke;
        for (this.__initialize(B, V), ke = {}, T = this.__worklist, H = this.__leavelist, T.push(new p(B, null, null, null)), H.push(new p(null, null, null, null)); T.length; ) {
          if (X = T.pop(), X === ke) {
            if (X = H.pop(), z = this.__execute(V.leave, X), this.__state === u || z === u)
              return;
            continue;
          }
          if (X.node) {
            if (z = this.__execute(V.enter, X), this.__state === u || z === u)
              return;
            if (T.push(ke), H.push(X), this.__state === a || z === a)
              continue;
            if (U = X.node, O = U.type || X.wrap, le = this.__keys[O], !le)
              if (this.__fallback)
                le = this.__fallback(U);
              else
                throw new Error("Unknown node type " + O + ".");
            for (me = le.length; (me -= 1) >= 0; )
              if (te = le[me], ie = U[te], !!ie) {
                if (Array.isArray(ie)) {
                  for (pe = ie.length; (pe -= 1) >= 0; )
                    if (ie[pe] && !F(H, ie[pe])) {
                      if (C(O, le[me]))
                        X = new p(ie[pe], [te, pe], "Property", null);
                      else if (M(ie[pe]))
                        X = new p(ie[pe], [te, pe], null, null);
                      else
                        continue;
                      T.push(X);
                    }
                } else if (M(ie)) {
                  if (F(H, ie))
                    continue;
                  T.push(new p(ie, te, null, null));
                }
              }
          }
        }
      }, A.prototype.replace = function(B, V) {
        var T, H, X, U, O, z, te, me, pe, le, ie, ke, et;
        function oe(W) {
          var $e, xe, tt, ge;
          if (W.ref.remove()) {
            for (xe = W.ref.key, ge = W.ref.parent, $e = T.length; $e--; )
              if (tt = T[$e], tt.ref && tt.ref.parent === ge) {
                if (tt.ref.key < xe)
                  break;
                --tt.ref.key;
              }
          }
        }
        for (this.__initialize(B, V), ie = {}, T = this.__worklist, H = this.__leavelist, ke = {
          root: B
        }, z = new p(B, null, null, new m(ke, "root")), T.push(z), H.push(z); T.length; ) {
          if (z = T.pop(), z === ie) {
            if (z = H.pop(), O = this.__execute(V.leave, z), O !== void 0 && O !== u && O !== a && O !== o && z.ref.replace(O), (this.__state === o || O === o) && oe(z), this.__state === u || O === u)
              return ke.root;
            continue;
          }
          if (O = this.__execute(V.enter, z), O !== void 0 && O !== u && O !== a && O !== o && (z.ref.replace(O), z.node = O), (this.__state === o || O === o) && (oe(z), z.node = null), this.__state === u || O === u)
            return ke.root;
          if (X = z.node, !!X && (T.push(ie), H.push(z), !(this.__state === a || O === a))) {
            if (U = X.type || z.wrap, pe = this.__keys[U], !pe)
              if (this.__fallback)
                pe = this.__fallback(X);
              else
                throw new Error("Unknown node type " + U + ".");
            for (te = pe.length; (te -= 1) >= 0; )
              if (et = pe[te], le = X[et], !!le)
                if (Array.isArray(le)) {
                  for (me = le.length; (me -= 1) >= 0; )
                    if (le[me]) {
                      if (C(U, pe[te]))
                        z = new p(le[me], [et, me], "Property", new m(le, me));
                      else if (M(le[me]))
                        z = new p(le[me], [et, me], null, new m(le, me));
                      else
                        continue;
                      T.push(z);
                    }
                } else M(le) && T.push(new p(le, et, null, new m(X, et)));
          }
        }
        return ke.root;
      };
      function _(x, B) {
        var V = new A();
        return V.traverse(x, B);
      }
      function k(x, B) {
        var V = new A();
        return V.replace(x, B);
      }
      function L(x, B) {
        var V;
        return V = h(B, function(H) {
          return H.range[0] > x.range[0];
        }), x.extendedRange = [x.range[0], x.range[1]], V !== B.length && (x.extendedRange[1] = B[V].range[0]), V -= 1, V >= 0 && (x.extendedRange[0] = B[V].range[1]), x;
      }
      function S(x, B, V) {
        var T = [], H, X, U, O;
        if (!x.range)
          throw new Error("attachComments needs range information");
        if (!V.length) {
          if (B.length) {
            for (U = 0, X = B.length; U < X; U += 1)
              H = f(B[U]), H.extendedRange = [0, x.range[0]], T.push(H);
            x.leadingComments = T;
          }
          return x;
        }
        for (U = 0, X = B.length; U < X; U += 1)
          T.push(L(f(B[U]), V));
        return O = 0, _(x, {
          enter: function(z) {
            for (var te; O < T.length && (te = T[O], !(te.extendedRange[1] > z.range[0])); )
              te.extendedRange[1] === z.range[0] ? (z.leadingComments || (z.leadingComments = []), z.leadingComments.push(te), T.splice(O, 1)) : O += 1;
            if (O === T.length)
              return i.Break;
            if (T[O].extendedRange[0] > z.range[1])
              return i.Skip;
          }
        }), O = 0, _(x, {
          leave: function(z) {
            for (var te; O < T.length && (te = T[O], !(z.range[1] < te.extendedRange[0])); )
              z.range[1] === te.extendedRange[0] ? (z.trailingComments || (z.trailingComments = []), z.trailingComments.push(te), T.splice(O, 1)) : O += 1;
            if (O === T.length)
              return i.Break;
            if (T[O].extendedRange[0] > z.range[1])
              return i.Skip;
          }
        }), x;
      }
      return n.Syntax = r, n.traverse = _, n.replace = k, n.attachComments = S, n.VisitorKeys = s, n.VisitorOption = i, n.Controller = A, n.cloneEnvironment = function() {
        return t({});
      }, n;
    })(e);
  }(Ws)), Ws;
}
var Xr = {}, Os = { exports: {} }, ko;
function VP() {
  return ko || (ko = 1, function() {
    function e(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return !0;
      }
      return !1;
    }
    function t(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return !0;
      }
      return !1;
    }
    function n(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return !0;
      }
      return !1;
    }
    function r(u) {
      return n(u) || u != null && u.type === "FunctionDeclaration";
    }
    function i(u) {
      switch (u.type) {
        case "IfStatement":
          return u.alternate != null ? u.alternate : u.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return u.body;
      }
      return null;
    }
    function s(u) {
      var a;
      if (u.type !== "IfStatement" || u.alternate == null)
        return !1;
      a = u.consequent;
      do {
        if (a.type === "IfStatement" && a.alternate == null)
          return !0;
        a = i(a);
      } while (a);
      return !1;
    }
    Os.exports = {
      isExpression: e,
      isStatement: n,
      isIterationStatement: t,
      isSourceElement: r,
      isProblematicIfStatement: s,
      trailingStatement: i
    };
  }()), Os.exports;
}
var zs = { exports: {} }, Vo;
function Xm() {
  return Vo || (Vo = 1, function() {
    var e, t, n, r, i, s;
    t = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, e = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function u(F) {
      return 48 <= F && F <= 57;
    }
    function a(F) {
      return 48 <= F && F <= 57 || // 0..9
      97 <= F && F <= 102 || // a..f
      65 <= F && F <= 70;
    }
    function o(F) {
      return F >= 48 && F <= 55;
    }
    n = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function f(F) {
      return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && n.indexOf(F) >= 0;
    }
    function h(F) {
      return F === 10 || F === 13 || F === 8232 || F === 8233;
    }
    function m(F) {
      if (F <= 65535)
        return String.fromCharCode(F);
      var _ = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), k = String.fromCharCode((F - 65536) % 1024 + 56320);
      return _ + k;
    }
    for (r = new Array(128), s = 0; s < 128; ++s)
      r[s] = s >= 97 && s <= 122 || // a..z
      s >= 65 && s <= 90 || // A..Z
      s === 36 || s === 95;
    for (i = new Array(128), s = 0; s < 128; ++s)
      i[s] = s >= 97 && s <= 122 || // a..z
      s >= 65 && s <= 90 || // A..Z
      s >= 48 && s <= 57 || // 0..9
      s === 36 || s === 95;
    function p(F) {
      return F < 128 ? r[F] : t.NonAsciiIdentifierStart.test(m(F));
    }
    function A(F) {
      return F < 128 ? i[F] : t.NonAsciiIdentifierPart.test(m(F));
    }
    function M(F) {
      return F < 128 ? r[F] : e.NonAsciiIdentifierStart.test(m(F));
    }
    function C(F) {
      return F < 128 ? i[F] : e.NonAsciiIdentifierPart.test(m(F));
    }
    zs.exports = {
      isDecimalDigit: u,
      isHexDigit: a,
      isOctalDigit: o,
      isWhiteSpace: f,
      isLineTerminator: h,
      isIdentifierStartES5: p,
      isIdentifierPartES5: A,
      isIdentifierStartES6: M,
      isIdentifierPartES6: C
    };
  }()), zs.exports;
}
var js = { exports: {} }, Io;
function IP() {
  return Io || (Io = 1, function() {
    var e = Xm();
    function t(p) {
      switch (p) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return !0;
        default:
          return !1;
      }
    }
    function n(p, A) {
      return !A && p === "yield" ? !1 : r(p, A);
    }
    function r(p, A) {
      if (A && t(p))
        return !0;
      switch (p.length) {
        case 2:
          return p === "if" || p === "in" || p === "do";
        case 3:
          return p === "var" || p === "for" || p === "new" || p === "try";
        case 4:
          return p === "this" || p === "else" || p === "case" || p === "void" || p === "with" || p === "enum";
        case 5:
          return p === "while" || p === "break" || p === "catch" || p === "throw" || p === "const" || p === "yield" || p === "class" || p === "super";
        case 6:
          return p === "return" || p === "typeof" || p === "delete" || p === "switch" || p === "export" || p === "import";
        case 7:
          return p === "default" || p === "finally" || p === "extends";
        case 8:
          return p === "function" || p === "continue" || p === "debugger";
        case 10:
          return p === "instanceof";
        default:
          return !1;
      }
    }
    function i(p, A) {
      return p === "null" || p === "true" || p === "false" || n(p, A);
    }
    function s(p, A) {
      return p === "null" || p === "true" || p === "false" || r(p, A);
    }
    function u(p) {
      return p === "eval" || p === "arguments";
    }
    function a(p) {
      var A, M, C;
      if (p.length === 0 || (C = p.charCodeAt(0), !e.isIdentifierStartES5(C)))
        return !1;
      for (A = 1, M = p.length; A < M; ++A)
        if (C = p.charCodeAt(A), !e.isIdentifierPartES5(C))
          return !1;
      return !0;
    }
    function o(p, A) {
      return (p - 55296) * 1024 + (A - 56320) + 65536;
    }
    function f(p) {
      var A, M, C, F, _;
      if (p.length === 0)
        return !1;
      for (_ = e.isIdentifierStartES6, A = 0, M = p.length; A < M; ++A) {
        if (C = p.charCodeAt(A), 55296 <= C && C <= 56319) {
          if (++A, A >= M || (F = p.charCodeAt(A), !(56320 <= F && F <= 57343)))
            return !1;
          C = o(C, F);
        }
        if (!_(C))
          return !1;
        _ = e.isIdentifierPartES6;
      }
      return !0;
    }
    function h(p, A) {
      return a(p) && !i(p, A);
    }
    function m(p, A) {
      return f(p) && !s(p, A);
    }
    js.exports = {
      isKeywordES5: n,
      isKeywordES6: r,
      isReservedWordES5: i,
      isReservedWordES6: s,
      isRestrictedWord: u,
      isIdentifierNameES5: a,
      isIdentifierNameES6: f,
      isIdentifierES5: h,
      isIdentifierES6: m
    };
  }()), js.exports;
}
var To;
function TP() {
  return To || (To = 1, function() {
    Xr.ast = VP(), Xr.code = Xm(), Xr.keyword = IP();
  }()), Xr;
}
var Wr = {}, $s = {}, Ei = {}, xi = {}, No;
function NP() {
  if (No) return xi;
  No = 1;
  var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return xi.encode = function(t) {
    if (0 <= t && t < e.length)
      return e[t];
    throw new TypeError("Must be between 0 and 63: " + t);
  }, xi.decode = function(t) {
    var n = 65, r = 90, i = 97, s = 122, u = 48, a = 57, o = 43, f = 47, h = 26, m = 52;
    return n <= t && t <= r ? t - n : i <= t && t <= s ? t - i + h : u <= t && t <= a ? t - u + m : t == o ? 62 : t == f ? 63 : -1;
  }, xi;
}
var Lo;
function Wm() {
  if (Lo) return Ei;
  Lo = 1;
  var e = NP(), t = 5, n = 1 << t, r = n - 1, i = n;
  function s(a) {
    return a < 0 ? (-a << 1) + 1 : (a << 1) + 0;
  }
  function u(a) {
    var o = (a & 1) === 1, f = a >> 1;
    return o ? -f : f;
  }
  return Ei.encode = function(o) {
    var f = "", h, m = s(o);
    do
      h = m & r, m >>>= t, m > 0 && (h |= i), f += e.encode(h);
    while (m > 0);
    return f;
  }, Ei.decode = function(o, f, h) {
    var m = o.length, p = 0, A = 0, M, C;
    do {
      if (f >= m)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (C = e.decode(o.charCodeAt(f++)), C === -1)
        throw new Error("Invalid base64 digit: " + o.charAt(f - 1));
      M = !!(C & i), C &= r, p = p + (C << A), A += t;
    } while (M);
    h.value = u(p), h.rest = f;
  }, Ei;
}
var qs = {}, Ro;
function mi() {
  return Ro || (Ro = 1, function(e) {
    function t(S, x, B) {
      if (x in S)
        return S[x];
      if (arguments.length === 3)
        return B;
      throw new Error('"' + x + '" is a required argument.');
    }
    e.getArg = t;
    var n = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r = /^data:.+\,.+$/;
    function i(S) {
      var x = S.match(n);
      return x ? {
        scheme: x[1],
        auth: x[2],
        host: x[3],
        port: x[4],
        path: x[5]
      } : null;
    }
    e.urlParse = i;
    function s(S) {
      var x = "";
      return S.scheme && (x += S.scheme + ":"), x += "//", S.auth && (x += S.auth + "@"), S.host && (x += S.host), S.port && (x += ":" + S.port), S.path && (x += S.path), x;
    }
    e.urlGenerate = s;
    function u(S) {
      var x = S, B = i(S);
      if (B) {
        if (!B.path)
          return S;
        x = B.path;
      }
      for (var V = e.isAbsolute(x), T = x.split(/\/+/), H, X = 0, U = T.length - 1; U >= 0; U--)
        H = T[U], H === "." ? T.splice(U, 1) : H === ".." ? X++ : X > 0 && (H === "" ? (T.splice(U + 1, X), X = 0) : (T.splice(U, 2), X--));
      return x = T.join("/"), x === "" && (x = V ? "/" : "."), B ? (B.path = x, s(B)) : x;
    }
    e.normalize = u;
    function a(S, x) {
      S === "" && (S = "."), x === "" && (x = ".");
      var B = i(x), V = i(S);
      if (V && (S = V.path || "/"), B && !B.scheme)
        return V && (B.scheme = V.scheme), s(B);
      if (B || x.match(r))
        return x;
      if (V && !V.host && !V.path)
        return V.host = x, s(V);
      var T = x.charAt(0) === "/" ? x : u(S.replace(/\/+$/, "") + "/" + x);
      return V ? (V.path = T, s(V)) : T;
    }
    e.join = a, e.isAbsolute = function(S) {
      return S.charAt(0) === "/" || n.test(S);
    };
    function o(S, x) {
      S === "" && (S = "."), S = S.replace(/\/$/, "");
      for (var B = 0; x.indexOf(S + "/") !== 0; ) {
        var V = S.lastIndexOf("/");
        if (V < 0 || (S = S.slice(0, V), S.match(/^([^\/]+:\/)?\/*$/)))
          return x;
        ++B;
      }
      return Array(B + 1).join("../") + x.substr(S.length + 1);
    }
    e.relative = o;
    var f = function() {
      var S = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in S);
    }();
    function h(S) {
      return S;
    }
    function m(S) {
      return A(S) ? "$" + S : S;
    }
    e.toSetString = f ? h : m;
    function p(S) {
      return A(S) ? S.slice(1) : S;
    }
    e.fromSetString = f ? h : p;
    function A(S) {
      if (!S)
        return !1;
      var x = S.length;
      if (x < 9 || S.charCodeAt(x - 1) !== 95 || S.charCodeAt(x - 2) !== 95 || S.charCodeAt(x - 3) !== 111 || S.charCodeAt(x - 4) !== 116 || S.charCodeAt(x - 5) !== 111 || S.charCodeAt(x - 6) !== 114 || S.charCodeAt(x - 7) !== 112 || S.charCodeAt(x - 8) !== 95 || S.charCodeAt(x - 9) !== 95)
        return !1;
      for (var B = x - 10; B >= 0; B--)
        if (S.charCodeAt(B) !== 36)
          return !1;
      return !0;
    }
    function M(S, x, B) {
      var V = F(S.source, x.source);
      return V !== 0 || (V = S.originalLine - x.originalLine, V !== 0) || (V = S.originalColumn - x.originalColumn, V !== 0 || B) || (V = S.generatedColumn - x.generatedColumn, V !== 0) || (V = S.generatedLine - x.generatedLine, V !== 0) ? V : F(S.name, x.name);
    }
    e.compareByOriginalPositions = M;
    function C(S, x, B) {
      var V = S.generatedLine - x.generatedLine;
      return V !== 0 || (V = S.generatedColumn - x.generatedColumn, V !== 0 || B) || (V = F(S.source, x.source), V !== 0) || (V = S.originalLine - x.originalLine, V !== 0) || (V = S.originalColumn - x.originalColumn, V !== 0) ? V : F(S.name, x.name);
    }
    e.compareByGeneratedPositionsDeflated = C;
    function F(S, x) {
      return S === x ? 0 : S === null ? 1 : x === null ? -1 : S > x ? 1 : -1;
    }
    function _(S, x) {
      var B = S.generatedLine - x.generatedLine;
      return B !== 0 || (B = S.generatedColumn - x.generatedColumn, B !== 0) || (B = F(S.source, x.source), B !== 0) || (B = S.originalLine - x.originalLine, B !== 0) || (B = S.originalColumn - x.originalColumn, B !== 0) ? B : F(S.name, x.name);
    }
    e.compareByGeneratedPositionsInflated = _;
    function k(S) {
      return JSON.parse(S.replace(/^\)]}'[^\n]*\n/, ""));
    }
    e.parseSourceMapInput = k;
    function L(S, x, B) {
      if (x = x || "", S && (S[S.length - 1] !== "/" && x[0] !== "/" && (S += "/"), x = S + x), B) {
        var V = i(B);
        if (!V)
          throw new Error("sourceMapURL could not be parsed");
        if (V.path) {
          var T = V.path.lastIndexOf("/");
          T >= 0 && (V.path = V.path.substring(0, T + 1));
        }
        x = a(s(V), x);
      }
      return u(x);
    }
    e.computeSourceURL = L;
  }(qs)), qs;
}
var Hs = {}, Go;
function Om() {
  if (Go) return Hs;
  Go = 1;
  var e = mi(), t = Object.prototype.hasOwnProperty, n = typeof Map < "u";
  function r() {
    this._array = [], this._set = n ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return r.fromArray = function(s, u) {
    for (var a = new r(), o = 0, f = s.length; o < f; o++)
      a.add(s[o], u);
    return a;
  }, r.prototype.size = function() {
    return n ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, r.prototype.add = function(s, u) {
    var a = n ? s : e.toSetString(s), o = n ? this.has(s) : t.call(this._set, a), f = this._array.length;
    (!o || u) && this._array.push(s), o || (n ? this._set.set(s, f) : this._set[a] = f);
  }, r.prototype.has = function(s) {
    if (n)
      return this._set.has(s);
    var u = e.toSetString(s);
    return t.call(this._set, u);
  }, r.prototype.indexOf = function(s) {
    if (n) {
      var u = this._set.get(s);
      if (u >= 0)
        return u;
    } else {
      var a = e.toSetString(s);
      if (t.call(this._set, a))
        return this._set[a];
    }
    throw new Error('"' + s + '" is not in the set.');
  }, r.prototype.at = function(s) {
    if (s >= 0 && s < this._array.length)
      return this._array[s];
    throw new Error("No element indexed by " + s);
  }, r.prototype.toArray = function() {
    return this._array.slice();
  }, Hs.ArraySet = r, Hs;
}
var Ks = {}, Zo;
function LP() {
  if (Zo) return Ks;
  Zo = 1;
  var e = mi();
  function t(r, i) {
    var s = r.generatedLine, u = i.generatedLine, a = r.generatedColumn, o = i.generatedColumn;
    return u > s || u == s && o >= a || e.compareByGeneratedPositionsInflated(r, i) <= 0;
  }
  function n() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return n.prototype.unsortedForEach = function(i, s) {
    this._array.forEach(i, s);
  }, n.prototype.add = function(i) {
    t(this._last, i) ? (this._last = i, this._array.push(i)) : (this._sorted = !1, this._array.push(i));
  }, n.prototype.toArray = function() {
    return this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, Ks.MappingList = n, Ks;
}
var Xo;
function zm() {
  if (Xo) return $s;
  Xo = 1;
  var e = Wm(), t = mi(), n = Om().ArraySet, r = LP().MappingList;
  function i(s) {
    s || (s = {}), this._file = t.getArg(s, "file", null), this._sourceRoot = t.getArg(s, "sourceRoot", null), this._skipValidation = t.getArg(s, "skipValidation", !1), this._sources = new n(), this._names = new n(), this._mappings = new r(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(u) {
    var a = u.sourceRoot, o = new i({
      file: u.file,
      sourceRoot: a
    });
    return u.eachMapping(function(f) {
      var h = {
        generated: {
          line: f.generatedLine,
          column: f.generatedColumn
        }
      };
      f.source != null && (h.source = f.source, a != null && (h.source = t.relative(a, h.source)), h.original = {
        line: f.originalLine,
        column: f.originalColumn
      }, f.name != null && (h.name = f.name)), o.addMapping(h);
    }), u.sources.forEach(function(f) {
      var h = f;
      a !== null && (h = t.relative(a, f)), o._sources.has(h) || o._sources.add(h);
      var m = u.sourceContentFor(f);
      m != null && o.setSourceContent(f, m);
    }), o;
  }, i.prototype.addMapping = function(u) {
    var a = t.getArg(u, "generated"), o = t.getArg(u, "original", null), f = t.getArg(u, "source", null), h = t.getArg(u, "name", null);
    this._skipValidation || this._validateMapping(a, o, f, h), f != null && (f = String(f), this._sources.has(f) || this._sources.add(f)), h != null && (h = String(h), this._names.has(h) || this._names.add(h)), this._mappings.add({
      generatedLine: a.line,
      generatedColumn: a.column,
      originalLine: o != null && o.line,
      originalColumn: o != null && o.column,
      source: f,
      name: h
    });
  }, i.prototype.setSourceContent = function(u, a) {
    var o = u;
    this._sourceRoot != null && (o = t.relative(this._sourceRoot, o)), a != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[t.toSetString(o)] = a) : this._sourcesContents && (delete this._sourcesContents[t.toSetString(o)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(u, a, o) {
    var f = a;
    if (a == null) {
      if (u.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      f = u.file;
    }
    var h = this._sourceRoot;
    h != null && (f = t.relative(h, f));
    var m = new n(), p = new n();
    this._mappings.unsortedForEach(function(A) {
      if (A.source === f && A.originalLine != null) {
        var M = u.originalPositionFor({
          line: A.originalLine,
          column: A.originalColumn
        });
        M.source != null && (A.source = M.source, o != null && (A.source = t.join(o, A.source)), h != null && (A.source = t.relative(h, A.source)), A.originalLine = M.line, A.originalColumn = M.column, M.name != null && (A.name = M.name));
      }
      var C = A.source;
      C != null && !m.has(C) && m.add(C);
      var F = A.name;
      F != null && !p.has(F) && p.add(F);
    }, this), this._sources = m, this._names = p, u.sources.forEach(function(A) {
      var M = u.sourceContentFor(A);
      M != null && (o != null && (A = t.join(o, A)), h != null && (A = t.relative(h, A)), this.setSourceContent(A, M));
    }, this);
  }, i.prototype._validateMapping = function(u, a, o, f) {
    if (a && typeof a.line != "number" && typeof a.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(u && "line" in u && "column" in u && u.line > 0 && u.column >= 0 && !a && !o && !f)) {
      if (u && "line" in u && "column" in u && a && "line" in a && "column" in a && u.line > 0 && u.column >= 0 && a.line > 0 && a.column >= 0 && o)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: u,
        source: o,
        original: a,
        name: f
      }));
    }
  }, i.prototype._serializeMappings = function() {
    for (var u = 0, a = 1, o = 0, f = 0, h = 0, m = 0, p = "", A, M, C, F, _ = this._mappings.toArray(), k = 0, L = _.length; k < L; k++) {
      if (M = _[k], A = "", M.generatedLine !== a)
        for (u = 0; M.generatedLine !== a; )
          A += ";", a++;
      else if (k > 0) {
        if (!t.compareByGeneratedPositionsInflated(M, _[k - 1]))
          continue;
        A += ",";
      }
      A += e.encode(M.generatedColumn - u), u = M.generatedColumn, M.source != null && (F = this._sources.indexOf(M.source), A += e.encode(F - m), m = F, A += e.encode(M.originalLine - 1 - f), f = M.originalLine - 1, A += e.encode(M.originalColumn - o), o = M.originalColumn, M.name != null && (C = this._names.indexOf(M.name), A += e.encode(C - h), h = C)), p += A;
    }
    return p;
  }, i.prototype._generateSourcesContent = function(u, a) {
    return u.map(function(o) {
      if (!this._sourcesContents)
        return null;
      a != null && (o = t.relative(a, o));
      var f = t.toSetString(o);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, f) ? this._sourcesContents[f] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var u = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (u.file = this._file), this._sourceRoot != null && (u.sourceRoot = this._sourceRoot), this._sourcesContents && (u.sourcesContent = this._generateSourcesContent(u.sources, u.sourceRoot)), u;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, $s.SourceMapGenerator = i, $s;
}
var Or = {}, Ys = {}, Wo;
function RP() {
  return Wo || (Wo = 1, function(e) {
    e.GREATEST_LOWER_BOUND = 1, e.LEAST_UPPER_BOUND = 2;
    function t(n, r, i, s, u, a) {
      var o = Math.floor((r - n) / 2) + n, f = u(i, s[o], !0);
      return f === 0 ? o : f > 0 ? r - o > 1 ? t(o, r, i, s, u, a) : a == e.LEAST_UPPER_BOUND ? r < s.length ? r : -1 : o : o - n > 1 ? t(n, o, i, s, u, a) : a == e.LEAST_UPPER_BOUND ? o : n < 0 ? -1 : n;
    }
    e.search = function(r, i, s, u) {
      if (i.length === 0)
        return -1;
      var a = t(
        -1,
        i.length,
        r,
        i,
        s,
        u || e.GREATEST_LOWER_BOUND
      );
      if (a < 0)
        return -1;
      for (; a - 1 >= 0 && s(i[a], i[a - 1], !0) === 0; )
        --a;
      return a;
    };
  }(Ys)), Ys;
}
var Js = {}, Oo;
function GP() {
  if (Oo) return Js;
  Oo = 1;
  function e(r, i, s) {
    var u = r[i];
    r[i] = r[s], r[s] = u;
  }
  function t(r, i) {
    return Math.round(r + Math.random() * (i - r));
  }
  function n(r, i, s, u) {
    if (s < u) {
      var a = t(s, u), o = s - 1;
      e(r, a, u);
      for (var f = r[u], h = s; h < u; h++)
        i(r[h], f) <= 0 && (o += 1, e(r, o, h));
      e(r, o + 1, h);
      var m = o + 1;
      n(r, i, s, m - 1), n(r, i, m + 1, u);
    }
  }
  return Js.quickSort = function(r, i) {
    n(r, i, 0, r.length - 1);
  }, Js;
}
var zo;
function ZP() {
  if (zo) return Or;
  zo = 1;
  var e = mi(), t = RP(), n = Om().ArraySet, r = Wm(), i = GP().quickSort;
  function s(f, h) {
    var m = f;
    return typeof f == "string" && (m = e.parseSourceMapInput(f)), m.sections != null ? new o(m, h) : new u(m, h);
  }
  s.fromSourceMap = function(f, h) {
    return u.fromSourceMap(f, h);
  }, s.prototype._version = 3, s.prototype.__generatedMappings = null, Object.defineProperty(s.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), s.prototype.__originalMappings = null, Object.defineProperty(s.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), s.prototype._charIsMappingSeparator = function(h, m) {
    var p = h.charAt(m);
    return p === ";" || p === ",";
  }, s.prototype._parseMappings = function(h, m) {
    throw new Error("Subclasses must implement _parseMappings");
  }, s.GENERATED_ORDER = 1, s.ORIGINAL_ORDER = 2, s.GREATEST_LOWER_BOUND = 1, s.LEAST_UPPER_BOUND = 2, s.prototype.eachMapping = function(h, m, p) {
    var A = m || null, M = p || s.GENERATED_ORDER, C;
    switch (M) {
      case s.GENERATED_ORDER:
        C = this._generatedMappings;
        break;
      case s.ORIGINAL_ORDER:
        C = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var F = this.sourceRoot;
    C.map(function(_) {
      var k = _.source === null ? null : this._sources.at(_.source);
      return k = e.computeSourceURL(F, k, this._sourceMapURL), {
        source: k,
        generatedLine: _.generatedLine,
        generatedColumn: _.generatedColumn,
        originalLine: _.originalLine,
        originalColumn: _.originalColumn,
        name: _.name === null ? null : this._names.at(_.name)
      };
    }, this).forEach(h, A);
  }, s.prototype.allGeneratedPositionsFor = function(h) {
    var m = e.getArg(h, "line"), p = {
      source: e.getArg(h, "source"),
      originalLine: m,
      originalColumn: e.getArg(h, "column", 0)
    };
    if (p.source = this._findSourceIndex(p.source), p.source < 0)
      return [];
    var A = [], M = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      e.compareByOriginalPositions,
      t.LEAST_UPPER_BOUND
    );
    if (M >= 0) {
      var C = this._originalMappings[M];
      if (h.column === void 0)
        for (var F = C.originalLine; C && C.originalLine === F; )
          A.push({
            line: e.getArg(C, "generatedLine", null),
            column: e.getArg(C, "generatedColumn", null),
            lastColumn: e.getArg(C, "lastGeneratedColumn", null)
          }), C = this._originalMappings[++M];
      else
        for (var _ = C.originalColumn; C && C.originalLine === m && C.originalColumn == _; )
          A.push({
            line: e.getArg(C, "generatedLine", null),
            column: e.getArg(C, "generatedColumn", null),
            lastColumn: e.getArg(C, "lastGeneratedColumn", null)
          }), C = this._originalMappings[++M];
    }
    return A;
  }, Or.SourceMapConsumer = s;
  function u(f, h) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var p = e.getArg(m, "version"), A = e.getArg(m, "sources"), M = e.getArg(m, "names", []), C = e.getArg(m, "sourceRoot", null), F = e.getArg(m, "sourcesContent", null), _ = e.getArg(m, "mappings"), k = e.getArg(m, "file", null);
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    C && (C = e.normalize(C)), A = A.map(String).map(e.normalize).map(function(L) {
      return C && e.isAbsolute(C) && e.isAbsolute(L) ? e.relative(C, L) : L;
    }), this._names = n.fromArray(M.map(String), !0), this._sources = n.fromArray(A, !0), this._absoluteSources = this._sources.toArray().map(function(L) {
      return e.computeSourceURL(C, L, h);
    }), this.sourceRoot = C, this.sourcesContent = F, this._mappings = _, this._sourceMapURL = h, this.file = k;
  }
  u.prototype = Object.create(s.prototype), u.prototype.consumer = s, u.prototype._findSourceIndex = function(f) {
    var h = f;
    if (this.sourceRoot != null && (h = e.relative(this.sourceRoot, h)), this._sources.has(h))
      return this._sources.indexOf(h);
    var m;
    for (m = 0; m < this._absoluteSources.length; ++m)
      if (this._absoluteSources[m] == f)
        return m;
    return -1;
  }, u.fromSourceMap = function(h, m) {
    var p = Object.create(u.prototype), A = p._names = n.fromArray(h._names.toArray(), !0), M = p._sources = n.fromArray(h._sources.toArray(), !0);
    p.sourceRoot = h._sourceRoot, p.sourcesContent = h._generateSourcesContent(
      p._sources.toArray(),
      p.sourceRoot
    ), p.file = h._file, p._sourceMapURL = m, p._absoluteSources = p._sources.toArray().map(function(B) {
      return e.computeSourceURL(p.sourceRoot, B, m);
    });
    for (var C = h._mappings.toArray().slice(), F = p.__generatedMappings = [], _ = p.__originalMappings = [], k = 0, L = C.length; k < L; k++) {
      var S = C[k], x = new a();
      x.generatedLine = S.generatedLine, x.generatedColumn = S.generatedColumn, S.source && (x.source = M.indexOf(S.source), x.originalLine = S.originalLine, x.originalColumn = S.originalColumn, S.name && (x.name = A.indexOf(S.name)), _.push(x)), F.push(x);
    }
    return i(p.__originalMappings, e.compareByOriginalPositions), p;
  }, u.prototype._version = 3, Object.defineProperty(u.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function a() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  u.prototype._parseMappings = function(h, m) {
    for (var p = 1, A = 0, M = 0, C = 0, F = 0, _ = 0, k = h.length, L = 0, S = {}, x = {}, B = [], V = [], T, H, X, U, O; L < k; )
      if (h.charAt(L) === ";")
        p++, L++, A = 0;
      else if (h.charAt(L) === ",")
        L++;
      else {
        for (T = new a(), T.generatedLine = p, U = L; U < k && !this._charIsMappingSeparator(h, U); U++)
          ;
        if (H = h.slice(L, U), X = S[H], X)
          L += H.length;
        else {
          for (X = []; L < U; )
            r.decode(h, L, x), O = x.value, L = x.rest, X.push(O);
          if (X.length === 2)
            throw new Error("Found a source, but no line and column");
          if (X.length === 3)
            throw new Error("Found a source and line, but no column");
          S[H] = X;
        }
        T.generatedColumn = A + X[0], A = T.generatedColumn, X.length > 1 && (T.source = F + X[1], F += X[1], T.originalLine = M + X[2], M = T.originalLine, T.originalLine += 1, T.originalColumn = C + X[3], C = T.originalColumn, X.length > 4 && (T.name = _ + X[4], _ += X[4])), V.push(T), typeof T.originalLine == "number" && B.push(T);
      }
    i(V, e.compareByGeneratedPositionsDeflated), this.__generatedMappings = V, i(B, e.compareByOriginalPositions), this.__originalMappings = B;
  }, u.prototype._findMapping = function(h, m, p, A, M, C) {
    if (h[p] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + h[p]);
    if (h[A] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + h[A]);
    return t.search(h, m, M, C);
  }, u.prototype.computeColumnSpans = function() {
    for (var h = 0; h < this._generatedMappings.length; ++h) {
      var m = this._generatedMappings[h];
      if (h + 1 < this._generatedMappings.length) {
        var p = this._generatedMappings[h + 1];
        if (m.generatedLine === p.generatedLine) {
          m.lastGeneratedColumn = p.generatedColumn - 1;
          continue;
        }
      }
      m.lastGeneratedColumn = 1 / 0;
    }
  }, u.prototype.originalPositionFor = function(h) {
    var m = {
      generatedLine: e.getArg(h, "line"),
      generatedColumn: e.getArg(h, "column")
    }, p = this._findMapping(
      m,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      e.compareByGeneratedPositionsDeflated,
      e.getArg(h, "bias", s.GREATEST_LOWER_BOUND)
    );
    if (p >= 0) {
      var A = this._generatedMappings[p];
      if (A.generatedLine === m.generatedLine) {
        var M = e.getArg(A, "source", null);
        M !== null && (M = this._sources.at(M), M = e.computeSourceURL(this.sourceRoot, M, this._sourceMapURL));
        var C = e.getArg(A, "name", null);
        return C !== null && (C = this._names.at(C)), {
          source: M,
          line: e.getArg(A, "originalLine", null),
          column: e.getArg(A, "originalColumn", null),
          name: C
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, u.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(h) {
      return h == null;
    }) : !1;
  }, u.prototype.sourceContentFor = function(h, m) {
    if (!this.sourcesContent)
      return null;
    var p = this._findSourceIndex(h);
    if (p >= 0)
      return this.sourcesContent[p];
    var A = h;
    this.sourceRoot != null && (A = e.relative(this.sourceRoot, A));
    var M;
    if (this.sourceRoot != null && (M = e.urlParse(this.sourceRoot))) {
      var C = A.replace(/^file:\/\//, "");
      if (M.scheme == "file" && this._sources.has(C))
        return this.sourcesContent[this._sources.indexOf(C)];
      if ((!M.path || M.path == "/") && this._sources.has("/" + A))
        return this.sourcesContent[this._sources.indexOf("/" + A)];
    }
    if (m)
      return null;
    throw new Error('"' + A + '" is not in the SourceMap.');
  }, u.prototype.generatedPositionFor = function(h) {
    var m = e.getArg(h, "source");
    if (m = this._findSourceIndex(m), m < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var p = {
      source: m,
      originalLine: e.getArg(h, "line"),
      originalColumn: e.getArg(h, "column")
    }, A = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      e.compareByOriginalPositions,
      e.getArg(h, "bias", s.GREATEST_LOWER_BOUND)
    );
    if (A >= 0) {
      var M = this._originalMappings[A];
      if (M.source === p.source)
        return {
          line: e.getArg(M, "generatedLine", null),
          column: e.getArg(M, "generatedColumn", null),
          lastColumn: e.getArg(M, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, Or.BasicSourceMapConsumer = u;
  function o(f, h) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var p = e.getArg(m, "version"), A = e.getArg(m, "sections");
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    this._sources = new n(), this._names = new n();
    var M = {
      line: -1,
      column: 0
    };
    this._sections = A.map(function(C) {
      if (C.url)
        throw new Error("Support for url field in sections not implemented.");
      var F = e.getArg(C, "offset"), _ = e.getArg(F, "line"), k = e.getArg(F, "column");
      if (_ < M.line || _ === M.line && k < M.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return M = F, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: _ + 1,
          generatedColumn: k + 1
        },
        consumer: new s(e.getArg(C, "map"), h)
      };
    });
  }
  return o.prototype = Object.create(s.prototype), o.prototype.constructor = s, o.prototype._version = 3, Object.defineProperty(o.prototype, "sources", {
    get: function() {
      for (var f = [], h = 0; h < this._sections.length; h++)
        for (var m = 0; m < this._sections[h].consumer.sources.length; m++)
          f.push(this._sections[h].consumer.sources[m]);
      return f;
    }
  }), o.prototype.originalPositionFor = function(h) {
    var m = {
      generatedLine: e.getArg(h, "line"),
      generatedColumn: e.getArg(h, "column")
    }, p = t.search(
      m,
      this._sections,
      function(M, C) {
        var F = M.generatedLine - C.generatedOffset.generatedLine;
        return F || M.generatedColumn - C.generatedOffset.generatedColumn;
      }
    ), A = this._sections[p];
    return A ? A.consumer.originalPositionFor({
      line: m.generatedLine - (A.generatedOffset.generatedLine - 1),
      column: m.generatedColumn - (A.generatedOffset.generatedLine === m.generatedLine ? A.generatedOffset.generatedColumn - 1 : 0),
      bias: h.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, o.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(h) {
      return h.consumer.hasContentsOfAllSources();
    });
  }, o.prototype.sourceContentFor = function(h, m) {
    for (var p = 0; p < this._sections.length; p++) {
      var A = this._sections[p], M = A.consumer.sourceContentFor(h, !0);
      if (M)
        return M;
    }
    if (m)
      return null;
    throw new Error('"' + h + '" is not in the SourceMap.');
  }, o.prototype.generatedPositionFor = function(h) {
    for (var m = 0; m < this._sections.length; m++) {
      var p = this._sections[m];
      if (p.consumer._findSourceIndex(e.getArg(h, "source")) !== -1) {
        var A = p.consumer.generatedPositionFor(h);
        if (A) {
          var M = {
            line: A.line + (p.generatedOffset.generatedLine - 1),
            column: A.column + (p.generatedOffset.generatedLine === A.line ? p.generatedOffset.generatedColumn - 1 : 0)
          };
          return M;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, o.prototype._parseMappings = function(h, m) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var p = 0; p < this._sections.length; p++)
      for (var A = this._sections[p], M = A.consumer._generatedMappings, C = 0; C < M.length; C++) {
        var F = M[C], _ = A.consumer._sources.at(F.source);
        _ = e.computeSourceURL(A.consumer.sourceRoot, _, this._sourceMapURL), this._sources.add(_), _ = this._sources.indexOf(_);
        var k = null;
        F.name && (k = A.consumer._names.at(F.name), this._names.add(k), k = this._names.indexOf(k));
        var L = {
          source: _,
          generatedLine: F.generatedLine + (A.generatedOffset.generatedLine - 1),
          generatedColumn: F.generatedColumn + (A.generatedOffset.generatedLine === F.generatedLine ? A.generatedOffset.generatedColumn - 1 : 0),
          originalLine: F.originalLine,
          originalColumn: F.originalColumn,
          name: k
        };
        this.__generatedMappings.push(L), typeof L.originalLine == "number" && this.__originalMappings.push(L);
      }
    i(this.__generatedMappings, e.compareByGeneratedPositionsDeflated), i(this.__originalMappings, e.compareByOriginalPositions);
  }, Or.IndexedSourceMapConsumer = o, Or;
}
var Us = {}, jo;
function XP() {
  if (jo) return Us;
  jo = 1;
  var e = zm().SourceMapGenerator, t = mi(), n = /(\r?\n)/, r = 10, i = "$$$isSourceNode$$$";
  function s(u, a, o, f, h) {
    this.children = [], this.sourceContents = {}, this.line = u ?? null, this.column = a ?? null, this.source = o ?? null, this.name = h ?? null, this[i] = !0, f != null && this.add(f);
  }
  return s.fromStringWithSourceMap = function(a, o, f) {
    var h = new s(), m = a.split(n), p = 0, A = function() {
      var k = S(), L = S() || "";
      return k + L;
      function S() {
        return p < m.length ? m[p++] : void 0;
      }
    }, M = 1, C = 0, F = null;
    return o.eachMapping(function(k) {
      if (F !== null)
        if (M < k.generatedLine)
          _(F, A()), M++, C = 0;
        else {
          var L = m[p] || "", S = L.substr(0, k.generatedColumn - C);
          m[p] = L.substr(k.generatedColumn - C), C = k.generatedColumn, _(F, S), F = k;
          return;
        }
      for (; M < k.generatedLine; )
        h.add(A()), M++;
      if (C < k.generatedColumn) {
        var L = m[p] || "";
        h.add(L.substr(0, k.generatedColumn)), m[p] = L.substr(k.generatedColumn), C = k.generatedColumn;
      }
      F = k;
    }, this), p < m.length && (F && _(F, A()), h.add(m.splice(p).join(""))), o.sources.forEach(function(k) {
      var L = o.sourceContentFor(k);
      L != null && (f != null && (k = t.join(f, k)), h.setSourceContent(k, L));
    }), h;
    function _(k, L) {
      if (k === null || k.source === void 0)
        h.add(L);
      else {
        var S = f ? t.join(f, k.source) : k.source;
        h.add(new s(
          k.originalLine,
          k.originalColumn,
          S,
          L,
          k.name
        ));
      }
    }
  }, s.prototype.add = function(a) {
    if (Array.isArray(a))
      a.forEach(function(o) {
        this.add(o);
      }, this);
    else if (a[i] || typeof a == "string")
      a && this.children.push(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, s.prototype.prepend = function(a) {
    if (Array.isArray(a))
      for (var o = a.length - 1; o >= 0; o--)
        this.prepend(a[o]);
    else if (a[i] || typeof a == "string")
      this.children.unshift(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, s.prototype.walk = function(a) {
    for (var o, f = 0, h = this.children.length; f < h; f++)
      o = this.children[f], o[i] ? o.walk(a) : o !== "" && a(o, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, s.prototype.join = function(a) {
    var o, f, h = this.children.length;
    if (h > 0) {
      for (o = [], f = 0; f < h - 1; f++)
        o.push(this.children[f]), o.push(a);
      o.push(this.children[f]), this.children = o;
    }
    return this;
  }, s.prototype.replaceRight = function(a, o) {
    var f = this.children[this.children.length - 1];
    return f[i] ? f.replaceRight(a, o) : typeof f == "string" ? this.children[this.children.length - 1] = f.replace(a, o) : this.children.push("".replace(a, o)), this;
  }, s.prototype.setSourceContent = function(a, o) {
    this.sourceContents[t.toSetString(a)] = o;
  }, s.prototype.walkSourceContents = function(a) {
    for (var o = 0, f = this.children.length; o < f; o++)
      this.children[o][i] && this.children[o].walkSourceContents(a);
    for (var h = Object.keys(this.sourceContents), o = 0, f = h.length; o < f; o++)
      a(t.fromSetString(h[o]), this.sourceContents[h[o]]);
  }, s.prototype.toString = function() {
    var a = "";
    return this.walk(function(o) {
      a += o;
    }), a;
  }, s.prototype.toStringWithSourceMap = function(a) {
    var o = {
      code: "",
      line: 1,
      column: 0
    }, f = new e(a), h = !1, m = null, p = null, A = null, M = null;
    return this.walk(function(C, F) {
      o.code += C, F.source !== null && F.line !== null && F.column !== null ? ((m !== F.source || p !== F.line || A !== F.column || M !== F.name) && f.addMapping({
        source: F.source,
        original: {
          line: F.line,
          column: F.column
        },
        generated: {
          line: o.line,
          column: o.column
        },
        name: F.name
      }), m = F.source, p = F.line, A = F.column, M = F.name, h = !0) : h && (f.addMapping({
        generated: {
          line: o.line,
          column: o.column
        }
      }), m = null, h = !1);
      for (var _ = 0, k = C.length; _ < k; _++)
        C.charCodeAt(_) === r ? (o.line++, o.column = 0, _ + 1 === k ? (m = null, h = !1) : h && f.addMapping({
          source: F.source,
          original: {
            line: F.line,
            column: F.column
          },
          generated: {
            line: o.line,
            column: o.column
          },
          name: F.name
        })) : o.column++;
    }), this.walkSourceContents(function(C, F) {
      f.setSourceContent(C, F);
    }), { code: o.code, map: f };
  }, Us.SourceNode = s, Us;
}
var $o;
function WP() {
  return $o || ($o = 1, Wr.SourceMapGenerator = zm().SourceMapGenerator, Wr.SourceMapConsumer = ZP().SourceMapConsumer, Wr.SourceNode = XP().SourceNode), Wr;
}
const OP = "escodegen", zP = "ECMAScript code generator", jP = "http://github.com/estools/escodegen", $P = "escodegen.js", qP = { esgenerate: "./bin/esgenerate.js", escodegen: "./bin/escodegen.js" }, HP = ["LICENSE.BSD", "README.md", "bin", "escodegen.js", "package.json"], KP = "2.1.0", YP = { node: ">=6.0" }, JP = [{ name: "Yusuke Suzuki", email: "utatane.tea@gmail.com", web: "http://github.com/Constellation" }], UP = { type: "git", url: "http://github.com/estools/escodegen.git" }, QP = { estraverse: "^5.2.0", esutils: "^2.0.2", esprima: "^4.0.1" }, eD = { "source-map": "~0.6.1" }, tD = { acorn: "^8.0.4", bluebird: "^3.4.7", "bower-registry-client": "^1.0.0", chai: "^4.2.0", "chai-exclude": "^2.0.2", "commonjs-everywhere": "^0.9.7", gulp: "^4.0.2", "gulp-eslint": "^6.0.0", "gulp-mocha": "^7.0.2", minimist: "^1.2.5", optionator: "^0.9.1", semver: "^7.3.4" }, nD = "BSD-2-Clause", rD = { test: "gulp travis", "unit-test": "gulp test", lint: "gulp lint", release: "node tools/release.js", "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js", build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js" }, iD = {
  name: OP,
  description: zP,
  homepage: jP,
  main: $P,
  bin: qP,
  files: HP,
  version: KP,
  engines: YP,
  maintainers: JP,
  repository: UP,
  dependencies: QP,
  optionalDependencies: eD,
  devDependencies: tD,
  license: nD,
  scripts: rD
};
var qo;
function sD() {
  return qo || (qo = 1, function(e) {
    (function() {
      var t, n, r, i, s, u, a, o, f, h, m, p, A, M, C, F, _, k, L, S, x, B, V, T, H, X;
      s = kP(), u = TP(), t = s.Syntax;
      function U(c) {
        return Ie.Expression.hasOwnProperty(c.type);
      }
      function O(c) {
        return Ie.Statement.hasOwnProperty(c.type);
      }
      n = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      }, r = {
        "??": n.Coalesce,
        "||": n.LogicalOR,
        "&&": n.LogicalAND,
        "|": n.BitwiseOR,
        "^": n.BitwiseXOR,
        "&": n.BitwiseAND,
        "==": n.Equality,
        "!=": n.Equality,
        "===": n.Equality,
        "!==": n.Equality,
        is: n.Equality,
        isnt: n.Equality,
        "<": n.Relational,
        ">": n.Relational,
        "<=": n.Relational,
        ">=": n.Relational,
        in: n.Relational,
        instanceof: n.Relational,
        "<<": n.BitwiseSHIFT,
        ">>": n.BitwiseSHIFT,
        ">>>": n.BitwiseSHIFT,
        "+": n.Additive,
        "-": n.Additive,
        "*": n.Multiplicative,
        "%": n.Multiplicative,
        "/": n.Multiplicative,
        "**": n.Exponentiation
      };
      var z = 1, te = 2, me = 4, pe = 8, le = 16, ie = 32, ke = 64, et = te | me, oe = z | te, W = z | te | me, $e = z, xe = me, tt = z | me, ge = z, qe = z | ie, Ee = 0, Ke = z | le, Ft = z | pe;
      function bt() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: !1,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: !1
            },
            newline: `
`,
            space: " ",
            json: !1,
            renumber: !1,
            hexadecimal: !1,
            quotes: "single",
            escapeless: !1,
            compact: !1,
            parentheses: !0,
            semicolons: !0,
            safeConcatenation: !1,
            preserveBlankLines: !1
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: !1,
            starlessGenerator: !1
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: !1,
          directive: !1,
          raw: !0,
          verbatim: null,
          sourceCode: null
        };
      }
      function Ve(c, g) {
        var d = "";
        for (g |= 0; g > 0; g >>>= 1, c += c)
          g & 1 && (d += c);
        return d;
      }
      function En(c) {
        return /[\r\n]/g.test(c);
      }
      function Ge(c) {
        var g = c.length;
        return g && u.code.isLineTerminator(c.charCodeAt(g - 1));
      }
      function Yt(c, g) {
        var d;
        for (d in g)
          g.hasOwnProperty(d) && (c[d] = g[d]);
        return c;
      }
      function dt(c, g) {
        var d, y;
        function P(I) {
          return typeof I == "object" && I instanceof Object && !(I instanceof RegExp);
        }
        for (d in g)
          g.hasOwnProperty(d) && (y = g[d], P(y) ? P(c[d]) ? dt(c[d], y) : c[d] = dt({}, y) : c[d] = y);
        return c;
      }
      function Et(c) {
        var g, d, y, P, I;
        if (c !== c)
          throw new Error("Numeric literal whose value is NaN");
        if (c < 0 || c === 0 && 1 / c < 0)
          throw new Error("Numeric literal whose value is negative");
        if (c === 1 / 0)
          return f ? "null" : h ? "1e400" : "1e+400";
        if (g = "" + c, !h || g.length < 3)
          return g;
        for (d = g.indexOf("."), !f && g.charCodeAt(0) === 48 && d === 1 && (d = 0, g = g.slice(1)), y = g, g = g.replace("e+", "e"), P = 0, (I = y.indexOf("e")) > 0 && (P = +y.slice(I + 1), y = y.slice(0, I)), d >= 0 && (P -= y.length - d - 1, y = +(y.slice(0, d) + y.slice(d + 1)) + ""), I = 0; y.charCodeAt(y.length + I - 1) === 48; )
          --I;
        return I !== 0 && (P -= I, y = y.slice(0, I)), P !== 0 && (y += "e" + P), (y.length < g.length || m && c > 1e12 && Math.floor(c) === c && (y = "0x" + c.toString(16)).length < g.length) && +y === c && (g = y), g;
      }
      function Nt(c, g) {
        return (c & -2) === 8232 ? (g ? "u" : "\\u") + (c === 8232 ? "2028" : "2029") : c === 10 || c === 13 ? (g ? "" : "\\") + (c === 10 ? "n" : "r") : String.fromCharCode(c);
      }
      function xn(c) {
        var g, d, y, P, I, R, Z, Y;
        if (d = c.toString(), c.source) {
          if (g = d.match(/\/([^/]*)$/), !g)
            return d;
          for (y = g[1], d = "", Z = !1, Y = !1, P = 0, I = c.source.length; P < I; ++P)
            R = c.source.charCodeAt(P), Y ? (d += Nt(R, Y), Y = !1) : (Z ? R === 93 && (Z = !1) : R === 47 ? d += "\\" : R === 91 && (Z = !0), d += Nt(R, Y), Y = R === 92);
          return "/" + d + "/" + y;
        }
        return d;
      }
      function Jt(c, g) {
        var d;
        return c === 8 ? "\\b" : c === 12 ? "\\f" : c === 9 ? "\\t" : (d = c.toString(16).toUpperCase(), f || c > 255 ? "\\u" + "0000".slice(d.length) + d : c === 0 && !u.code.isDecimalDigit(g) ? "\\0" : c === 11 ? "\\x0B" : "\\x" + "00".slice(d.length) + d);
      }
      function ln(c) {
        if (c === 92)
          return "\\\\";
        if (c === 10)
          return "\\n";
        if (c === 13)
          return "\\r";
        if (c === 8232)
          return "\\u2028";
        if (c === 8233)
          return "\\u2029";
        throw new Error("Incorrectly classified character");
      }
      function fn(c) {
        var g, d, y, P;
        for (P = p === "double" ? '"' : "'", g = 0, d = c.length; g < d; ++g)
          if (y = c.charCodeAt(g), y === 39) {
            P = '"';
            break;
          } else if (y === 34) {
            P = "'";
            break;
          } else y === 92 && ++g;
        return P + c + P;
      }
      function ct(c) {
        var g = "", d, y, P, I = 0, R = 0, Z, Y;
        for (d = 0, y = c.length; d < y; ++d) {
          if (P = c.charCodeAt(d), P === 39)
            ++I;
          else if (P === 34)
            ++R;
          else if (P === 47 && f)
            g += "\\";
          else if (u.code.isLineTerminator(P) || P === 92) {
            g += ln(P);
            continue;
          } else if (!u.code.isIdentifierPartES5(P) && (f && P < 32 || !f && !A && (P < 32 || P > 126))) {
            g += Jt(P, c.charCodeAt(d + 1));
            continue;
          }
          g += String.fromCharCode(P);
        }
        if (Z = !(p === "double" || p === "auto" && R < I), Y = Z ? "'" : '"', !(Z ? I : R))
          return Y + g + Y;
        for (c = g, g = Y, d = 0, y = c.length; d < y; ++d)
          P = c.charCodeAt(d), (P === 39 && Z || P === 34 && !Z) && (g += "\\"), g += String.fromCharCode(P);
        return g + Y;
      }
      function hn(c) {
        var g, d, y, P = "";
        for (g = 0, d = c.length; g < d; ++g)
          y = c[g], P += Array.isArray(y) ? hn(y) : y;
        return P;
      }
      function be(c, g) {
        if (!B)
          return Array.isArray(c) ? hn(c) : c;
        if (g == null) {
          if (c instanceof i)
            return c;
          g = {};
        }
        return g.loc == null ? new i(null, null, B, c, g.name || null) : new i(g.loc.start.line, g.loc.start.column, B === !0 ? g.loc.source || null : B, c, g.name || null);
      }
      function _e() {
        return C || " ";
      }
      function Q(c, g) {
        var d, y, P, I;
        return d = be(c).toString(), d.length === 0 ? [g] : (y = be(g).toString(), y.length === 0 ? [c] : (P = d.charCodeAt(d.length - 1), I = y.charCodeAt(0), (P === 43 || P === 45) && P === I || u.code.isIdentifierPartES5(P) && u.code.isIdentifierPartES5(I) || P === 47 && I === 105 ? [c, _e(), g] : u.code.isWhiteSpace(P) || u.code.isLineTerminator(P) || u.code.isWhiteSpace(I) || u.code.isLineTerminator(I) ? [c, g] : [c, C, g]));
      }
      function Oe(c) {
        return [a, c];
      }
      function Be(c) {
        var g;
        g = a, a += o, c(a), a = g;
      }
      function tr(c) {
        var g;
        for (g = c.length - 1; g >= 0 && !u.code.isLineTerminator(c.charCodeAt(g)); --g)
          ;
        return c.length - 1 - g;
      }
      function Vr(c, g) {
        var d, y, P, I, R, Z, Y, fe;
        for (d = c.split(/\r\n|[\r\n]/), Z = Number.MAX_VALUE, y = 1, P = d.length; y < P; ++y) {
          for (I = d[y], R = 0; R < I.length && u.code.isWhiteSpace(I.charCodeAt(R)); )
            ++R;
          Z > R && (Z = R);
        }
        for (typeof g < "u" ? (Y = a, d[1][Z] === "*" && (g += " "), a = g) : (Z & 1 && --Z, Y = a), y = 1, P = d.length; y < P; ++y)
          fe = be(Oe(d[y].slice(Z))), d[y] = B ? fe.join("") : fe;
        return a = Y, d.join(`
`);
      }
      function Mt(c, g) {
        if (c.type === "Line") {
          if (Ge(c.value))
            return "//" + c.value;
          var d = "//" + c.value;
          return T || (d += `
`), d;
        }
        return S.format.indent.adjustMultilineComment && /[\n\r]/.test(c.value) ? Vr("/*" + c.value + "*/", g) : "/*" + c.value + "*/";
      }
      function wn(c, g) {
        var d, y, P, I, R, Z, Y, fe, Te, xt, Lt, ye, lt, Ne;
        if (c.leadingComments && c.leadingComments.length > 0) {
          if (I = g, T) {
            for (P = c.leadingComments[0], g = [], fe = P.extendedRange, Te = P.range, Lt = V.substring(fe[0], Te[0]), Ne = (Lt.match(/\n/g) || []).length, Ne > 0 ? (g.push(Ve(`
`, Ne)), g.push(Oe(Mt(P)))) : (g.push(Lt), g.push(Mt(P))), xt = Te, d = 1, y = c.leadingComments.length; d < y; d++)
              P = c.leadingComments[d], Te = P.range, ye = V.substring(xt[1], Te[0]), Ne = (ye.match(/\n/g) || []).length, g.push(Ve(`
`, Ne)), g.push(Oe(Mt(P))), xt = Te;
            lt = V.substring(Te[1], fe[1]), Ne = (lt.match(/\n/g) || []).length, g.push(Ve(`
`, Ne));
          } else
            for (P = c.leadingComments[0], g = [], k && c.type === t.Program && c.body.length === 0 && g.push(`
`), g.push(Mt(P)), Ge(be(g).toString()) || g.push(`
`), d = 1, y = c.leadingComments.length; d < y; ++d)
              P = c.leadingComments[d], Y = [Mt(P)], Ge(be(Y).toString()) || Y.push(`
`), g.push(Oe(Y));
          g.push(Oe(I));
        }
        if (c.trailingComments)
          if (T)
            P = c.trailingComments[0], fe = P.extendedRange, Te = P.range, Lt = V.substring(fe[0], Te[0]), Ne = (Lt.match(/\n/g) || []).length, Ne > 0 ? (g.push(Ve(`
`, Ne)), g.push(Oe(Mt(P)))) : (g.push(Lt), g.push(Mt(P)));
          else
            for (R = !Ge(be(g).toString()), Z = Ve(" ", tr(be([a, g, o]).toString())), d = 0, y = c.trailingComments.length; d < y; ++d)
              P = c.trailingComments[d], R ? (d === 0 ? g = [g, o] : g = [g, Z], g.push(Mt(P, Z))) : g = [g, Oe(Mt(P))], d !== y - 1 && !Ge(be(g).toString()) && (g = [g, `
`]);
        return g;
      }
      function Ut(c, g, d) {
        var y, P = 0;
        for (y = c; y < g; y++)
          V[y] === `
` && P++;
        for (y = 1; y < P; y++)
          d.push(M);
      }
      function ze(c, g, d) {
        return g < d ? ["(", c, ")"] : c;
      }
      function Xn(c) {
        var g, d, y;
        for (y = c.split(/\r\n|\n/), g = 1, d = y.length; g < d; g++)
          y[g] = M + a + y[g];
        return y;
      }
      function Wn(c, g) {
        var d, y, P;
        return d = c[S.verbatim], typeof d == "string" ? y = ze(Xn(d), n.Sequence, g) : (y = Xn(d.content), P = d.precedence != null ? d.precedence : n.Sequence, y = ze(y, P, g)), be(y, c);
      }
      function Ie() {
      }
      Ie.prototype.maybeBlock = function(c, g) {
        var d, y, P = this;
        return y = !S.comment || !c.leadingComments, c.type === t.BlockStatement && y ? [C, this.generateStatement(c, g)] : c.type === t.EmptyStatement && y ? ";" : (Be(function() {
          d = [
            M,
            Oe(P.generateStatement(c, g))
          ];
        }), d);
      }, Ie.prototype.maybeBlockSuffix = function(c, g) {
        var d = Ge(be(g).toString());
        return c.type === t.BlockStatement && (!S.comment || !c.leadingComments) && !d ? [g, C] : d ? [g, a] : [g, M, a];
      };
      function rt(c) {
        return be(c.name, c);
      }
      function Qt(c, g) {
        return c.async ? "async" + (g ? _e() : C) : "";
      }
      function Sn(c) {
        var g = c.generator && !S.moz.starlessGenerator;
        return g ? "*" + C : "";
      }
      function nr(c) {
        var g = c.value, d = "";
        return g.async && (d += Qt(g, !c.computed)), g.generator && (d += Sn(g) ? "*" : ""), d;
      }
      Ie.prototype.generatePattern = function(c, g, d) {
        return c.type === t.Identifier ? rt(c) : this.generateExpression(c, g, d);
      }, Ie.prototype.generateFunctionParams = function(c) {
        var g, d, y, P;
        if (P = !1, c.type === t.ArrowFunctionExpression && !c.rest && (!c.defaults || c.defaults.length === 0) && c.params.length === 1 && c.params[0].type === t.Identifier)
          y = [Qt(c, !0), rt(c.params[0])];
        else {
          for (y = c.type === t.ArrowFunctionExpression ? [Qt(c, !1)] : [], y.push("("), c.defaults && (P = !0), g = 0, d = c.params.length; g < d; ++g)
            P && c.defaults[g] ? y.push(this.generateAssignment(c.params[g], c.defaults[g], "=", n.Assignment, W)) : y.push(this.generatePattern(c.params[g], n.Assignment, W)), g + 1 < d && y.push("," + C);
          c.rest && (c.params.length && y.push("," + C), y.push("..."), y.push(rt(c.rest))), y.push(")");
        }
        return y;
      }, Ie.prototype.generateFunctionBody = function(c) {
        var g, d;
        return g = this.generateFunctionParams(c), c.type === t.ArrowFunctionExpression && (g.push(C), g.push("=>")), c.expression ? (g.push(C), d = this.generateExpression(c.body, n.Assignment, W), d.toString().charAt(0) === "{" && (d = ["(", d, ")"]), g.push(d)) : g.push(this.maybeBlock(c.body, Ft)), g;
      }, Ie.prototype.generateIterationForStatement = function(c, g, d) {
        var y = ["for" + (g.await ? _e() + "await" : "") + C + "("], P = this;
        return Be(function() {
          g.left.type === t.VariableDeclaration ? Be(function() {
            y.push(g.left.kind + _e()), y.push(P.generateStatement(g.left.declarations[0], Ee));
          }) : y.push(P.generateExpression(g.left, n.Call, W)), y = Q(y, c), y = [Q(
            y,
            P.generateExpression(g.right, n.Assignment, W)
          ), ")"];
        }), y.push(this.maybeBlock(g.body, d)), y;
      }, Ie.prototype.generatePropertyKey = function(c, g) {
        var d = [];
        return g && d.push("["), d.push(this.generateExpression(c, n.Assignment, W)), g && d.push("]"), d;
      }, Ie.prototype.generateAssignment = function(c, g, d, y, P) {
        return n.Assignment < y && (P |= z), ze(
          [
            this.generateExpression(c, n.Call, P),
            C + d + C,
            this.generateExpression(g, n.Assignment, P)
          ],
          n.Assignment,
          y
        );
      }, Ie.prototype.semicolon = function(c) {
        return !_ && c & ie ? "" : ";";
      }, Ie.Statement = {
        BlockStatement: function(c, g) {
          var d, y, P = ["{", M], I = this;
          return Be(function() {
            c.body.length === 0 && T && (d = c.range, d[1] - d[0] > 2 && (y = V.substring(d[0] + 1, d[1] - 1), y[0] === `
` && (P = ["{"]), P.push(y)));
            var R, Z, Y, fe;
            for (fe = ge, g & pe && (fe |= le), R = 0, Z = c.body.length; R < Z; ++R)
              T && (R === 0 && (c.body[0].leadingComments && (d = c.body[0].leadingComments[0].extendedRange, y = V.substring(d[0], d[1]), y[0] === `
` && (P = ["{"])), c.body[0].leadingComments || Ut(c.range[0], c.body[0].range[0], P)), R > 0 && !c.body[R - 1].trailingComments && !c.body[R].leadingComments && Ut(c.body[R - 1].range[1], c.body[R].range[0], P)), R === Z - 1 && (fe |= ie), c.body[R].leadingComments && T ? Y = I.generateStatement(c.body[R], fe) : Y = Oe(I.generateStatement(c.body[R], fe)), P.push(Y), Ge(be(Y).toString()) || T && R < Z - 1 && c.body[R + 1].leadingComments || P.push(M), T && R === Z - 1 && (c.body[R].trailingComments || Ut(c.body[R].range[1], c.range[1], P));
          }), P.push(Oe("}")), P;
        },
        BreakStatement: function(c, g) {
          return c.label ? "break " + c.label.name + this.semicolon(g) : "break" + this.semicolon(g);
        },
        ContinueStatement: function(c, g) {
          return c.label ? "continue " + c.label.name + this.semicolon(g) : "continue" + this.semicolon(g);
        },
        ClassBody: function(c, g) {
          var d = ["{", M], y = this;
          return Be(function(P) {
            var I, R;
            for (I = 0, R = c.body.length; I < R; ++I)
              d.push(P), d.push(y.generateExpression(c.body[I], n.Sequence, W)), I + 1 < R && d.push(M);
          }), Ge(be(d).toString()) || d.push(M), d.push(a), d.push("}"), d;
        },
        ClassDeclaration: function(c, g) {
          var d, y;
          return d = ["class"], c.id && (d = Q(d, this.generateExpression(c.id, n.Sequence, W))), c.superClass && (y = Q("extends", this.generateExpression(c.superClass, n.Unary, W)), d = Q(d, y)), d.push(C), d.push(this.generateStatement(c.body, qe)), d;
        },
        DirectiveStatement: function(c, g) {
          return S.raw && c.raw ? c.raw + this.semicolon(g) : fn(c.directive) + this.semicolon(g);
        },
        DoWhileStatement: function(c, g) {
          var d = Q("do", this.maybeBlock(c.body, ge));
          return d = this.maybeBlockSuffix(c.body, d), Q(d, [
            "while" + C + "(",
            this.generateExpression(c.test, n.Sequence, W),
            ")" + this.semicolon(g)
          ]);
        },
        CatchClause: function(c, g) {
          var d, y = this;
          return Be(function() {
            var P;
            c.param ? (d = [
              "catch" + C + "(",
              y.generateExpression(c.param, n.Sequence, W),
              ")"
            ], c.guard && (P = y.generateExpression(c.guard, n.Sequence, W), d.splice(2, 0, " if ", P))) : d = ["catch"];
          }), d.push(this.maybeBlock(c.body, ge)), d;
        },
        DebuggerStatement: function(c, g) {
          return "debugger" + this.semicolon(g);
        },
        EmptyStatement: function(c, g) {
          return ";";
        },
        ExportDefaultDeclaration: function(c, g) {
          var d = ["export"], y;
          return y = g & ie ? qe : ge, d = Q(d, "default"), O(c.declaration) ? d = Q(d, this.generateStatement(c.declaration, y)) : d = Q(d, this.generateExpression(c.declaration, n.Assignment, W) + this.semicolon(g)), d;
        },
        ExportNamedDeclaration: function(c, g) {
          var d = ["export"], y, P = this;
          return y = g & ie ? qe : ge, c.declaration ? Q(d, this.generateStatement(c.declaration, y)) : (c.specifiers && (c.specifiers.length === 0 ? d = Q(d, "{" + C + "}") : c.specifiers[0].type === t.ExportBatchSpecifier ? d = Q(d, this.generateExpression(c.specifiers[0], n.Sequence, W)) : (d = Q(d, "{"), Be(function(I) {
            var R, Z;
            for (d.push(M), R = 0, Z = c.specifiers.length; R < Z; ++R)
              d.push(I), d.push(P.generateExpression(c.specifiers[R], n.Sequence, W)), R + 1 < Z && d.push("," + M);
          }), Ge(be(d).toString()) || d.push(M), d.push(a + "}")), c.source ? d = Q(d, [
            "from" + C,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, W),
            this.semicolon(g)
          ]) : d.push(this.semicolon(g))), d);
        },
        ExportAllDeclaration: function(c, g) {
          return [
            "export" + C,
            "*" + C,
            "from" + C,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, W),
            this.semicolon(g)
          ];
        },
        ExpressionStatement: function(c, g) {
          var d, y;
          function P(Z) {
            var Y;
            return Z.slice(0, 5) !== "class" ? !1 : (Y = Z.charCodeAt(5), Y === 123 || u.code.isWhiteSpace(Y) || u.code.isLineTerminator(Y));
          }
          function I(Z) {
            var Y;
            return Z.slice(0, 8) !== "function" ? !1 : (Y = Z.charCodeAt(8), Y === 40 || u.code.isWhiteSpace(Y) || Y === 42 || u.code.isLineTerminator(Y));
          }
          function R(Z) {
            var Y, fe, Te;
            if (Z.slice(0, 5) !== "async" || !u.code.isWhiteSpace(Z.charCodeAt(5)))
              return !1;
            for (fe = 6, Te = Z.length; fe < Te && u.code.isWhiteSpace(Z.charCodeAt(fe)); ++fe)
              ;
            return fe === Te || Z.slice(fe, fe + 8) !== "function" ? !1 : (Y = Z.charCodeAt(fe + 8), Y === 40 || u.code.isWhiteSpace(Y) || Y === 42 || u.code.isLineTerminator(Y));
          }
          return d = [this.generateExpression(c.expression, n.Sequence, W)], y = be(d).toString(), y.charCodeAt(0) === 123 || // ObjectExpression
          P(y) || I(y) || R(y) || L && g & le && c.expression.type === t.Literal && typeof c.expression.value == "string" ? d = ["(", d, ")" + this.semicolon(g)] : d.push(this.semicolon(g)), d;
        },
        ImportDeclaration: function(c, g) {
          var d, y, P = this;
          return c.specifiers.length === 0 ? [
            "import",
            C,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, W),
            this.semicolon(g)
          ] : (d = [
            "import"
          ], y = 0, c.specifiers[y].type === t.ImportDefaultSpecifier && (d = Q(d, [
            this.generateExpression(c.specifiers[y], n.Sequence, W)
          ]), ++y), c.specifiers[y] && (y !== 0 && d.push(","), c.specifiers[y].type === t.ImportNamespaceSpecifier ? d = Q(d, [
            C,
            this.generateExpression(c.specifiers[y], n.Sequence, W)
          ]) : (d.push(C + "{"), c.specifiers.length - y === 1 ? (d.push(C), d.push(this.generateExpression(c.specifiers[y], n.Sequence, W)), d.push(C + "}" + C)) : (Be(function(I) {
            var R, Z;
            for (d.push(M), R = y, Z = c.specifiers.length; R < Z; ++R)
              d.push(I), d.push(P.generateExpression(c.specifiers[R], n.Sequence, W)), R + 1 < Z && d.push("," + M);
          }), Ge(be(d).toString()) || d.push(M), d.push(a + "}" + C)))), d = Q(d, [
            "from" + C,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, W),
            this.semicolon(g)
          ]), d);
        },
        VariableDeclarator: function(c, g) {
          var d = g & z ? W : et;
          return c.init ? [
            this.generateExpression(c.id, n.Assignment, d),
            C,
            "=",
            C,
            this.generateExpression(c.init, n.Assignment, d)
          ] : this.generatePattern(c.id, n.Assignment, d);
        },
        VariableDeclaration: function(c, g) {
          var d, y, P, I, R, Z = this;
          d = [c.kind], R = g & z ? ge : Ee;
          function Y() {
            for (I = c.declarations[0], S.comment && I.leadingComments ? (d.push(`
`), d.push(Oe(Z.generateStatement(I, R)))) : (d.push(_e()), d.push(Z.generateStatement(I, R))), y = 1, P = c.declarations.length; y < P; ++y)
              I = c.declarations[y], S.comment && I.leadingComments ? (d.push("," + M), d.push(Oe(Z.generateStatement(I, R)))) : (d.push("," + C), d.push(Z.generateStatement(I, R)));
          }
          return c.declarations.length > 1 ? Be(Y) : Y(), d.push(this.semicolon(g)), d;
        },
        ThrowStatement: function(c, g) {
          return [Q(
            "throw",
            this.generateExpression(c.argument, n.Sequence, W)
          ), this.semicolon(g)];
        },
        TryStatement: function(c, g) {
          var d, y, P, I;
          if (d = ["try", this.maybeBlock(c.block, ge)], d = this.maybeBlockSuffix(c.block, d), c.handlers)
            for (y = 0, P = c.handlers.length; y < P; ++y)
              d = Q(d, this.generateStatement(c.handlers[y], ge)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(c.handlers[y].body, d));
          else {
            for (I = c.guardedHandlers || [], y = 0, P = I.length; y < P; ++y)
              d = Q(d, this.generateStatement(I[y], ge)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(I[y].body, d));
            if (c.handler)
              if (Array.isArray(c.handler))
                for (y = 0, P = c.handler.length; y < P; ++y)
                  d = Q(d, this.generateStatement(c.handler[y], ge)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(c.handler[y].body, d));
              else
                d = Q(d, this.generateStatement(c.handler, ge)), c.finalizer && (d = this.maybeBlockSuffix(c.handler.body, d));
          }
          return c.finalizer && (d = Q(d, ["finally", this.maybeBlock(c.finalizer, ge)])), d;
        },
        SwitchStatement: function(c, g) {
          var d, y, P, I, R, Z = this;
          if (Be(function() {
            d = [
              "switch" + C + "(",
              Z.generateExpression(c.discriminant, n.Sequence, W),
              ")" + C + "{" + M
            ];
          }), c.cases)
            for (R = ge, P = 0, I = c.cases.length; P < I; ++P)
              P === I - 1 && (R |= ie), y = Oe(this.generateStatement(c.cases[P], R)), d.push(y), Ge(be(y).toString()) || d.push(M);
          return d.push(Oe("}")), d;
        },
        SwitchCase: function(c, g) {
          var d, y, P, I, R, Z = this;
          return Be(function() {
            for (c.test ? d = [
              Q("case", Z.generateExpression(c.test, n.Sequence, W)),
              ":"
            ] : d = ["default:"], P = 0, I = c.consequent.length, I && c.consequent[0].type === t.BlockStatement && (y = Z.maybeBlock(c.consequent[0], ge), d.push(y), P = 1), P !== I && !Ge(be(d).toString()) && d.push(M), R = ge; P < I; ++P)
              P === I - 1 && g & ie && (R |= ie), y = Oe(Z.generateStatement(c.consequent[P], R)), d.push(y), P + 1 !== I && !Ge(be(y).toString()) && d.push(M);
          }), d;
        },
        IfStatement: function(c, g) {
          var d, y, P, I = this;
          return Be(function() {
            d = [
              "if" + C + "(",
              I.generateExpression(c.test, n.Sequence, W),
              ")"
            ];
          }), P = g & ie, y = ge, P && (y |= ie), c.alternate ? (d.push(this.maybeBlock(c.consequent, ge)), d = this.maybeBlockSuffix(c.consequent, d), c.alternate.type === t.IfStatement ? d = Q(d, ["else ", this.generateStatement(c.alternate, y)]) : d = Q(d, Q("else", this.maybeBlock(c.alternate, y)))) : d.push(this.maybeBlock(c.consequent, y)), d;
        },
        ForStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = ["for" + C + "("], c.init ? c.init.type === t.VariableDeclaration ? d.push(y.generateStatement(c.init, Ee)) : (d.push(y.generateExpression(c.init, n.Sequence, et)), d.push(";")) : d.push(";"), c.test && (d.push(C), d.push(y.generateExpression(c.test, n.Sequence, W))), d.push(";"), c.update && (d.push(C), d.push(y.generateExpression(c.update, n.Sequence, W))), d.push(")");
          }), d.push(this.maybeBlock(c.body, g & ie ? qe : ge)), d;
        },
        ForInStatement: function(c, g) {
          return this.generateIterationForStatement("in", c, g & ie ? qe : ge);
        },
        ForOfStatement: function(c, g) {
          return this.generateIterationForStatement("of", c, g & ie ? qe : ge);
        },
        LabeledStatement: function(c, g) {
          return [c.label.name + ":", this.maybeBlock(c.body, g & ie ? qe : ge)];
        },
        Program: function(c, g) {
          var d, y, P, I, R;
          for (I = c.body.length, d = [k && I > 0 ? `
` : ""], R = Ke, P = 0; P < I; ++P)
            !k && P === I - 1 && (R |= ie), T && (P === 0 && (c.body[0].leadingComments || Ut(c.range[0], c.body[P].range[0], d)), P > 0 && !c.body[P - 1].trailingComments && !c.body[P].leadingComments && Ut(c.body[P - 1].range[1], c.body[P].range[0], d)), y = Oe(this.generateStatement(c.body[P], R)), d.push(y), P + 1 < I && !Ge(be(y).toString()) && (T && c.body[P + 1].leadingComments || d.push(M)), T && P === I - 1 && (c.body[P].trailingComments || Ut(c.body[P].range[1], c.range[1], d));
          return d;
        },
        FunctionDeclaration: function(c, g) {
          return [
            Qt(c, !0),
            "function",
            Sn(c) || _e(),
            c.id ? rt(c.id) : "",
            this.generateFunctionBody(c)
          ];
        },
        ReturnStatement: function(c, g) {
          return c.argument ? [Q(
            "return",
            this.generateExpression(c.argument, n.Sequence, W)
          ), this.semicolon(g)] : ["return" + this.semicolon(g)];
        },
        WhileStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = [
              "while" + C + "(",
              y.generateExpression(c.test, n.Sequence, W),
              ")"
            ];
          }), d.push(this.maybeBlock(c.body, g & ie ? qe : ge)), d;
        },
        WithStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = [
              "with" + C + "(",
              y.generateExpression(c.object, n.Sequence, W),
              ")"
            ];
          }), d.push(this.maybeBlock(c.body, g & ie ? qe : ge)), d;
        }
      }, Yt(Ie.prototype, Ie.Statement), Ie.Expression = {
        SequenceExpression: function(c, g, d) {
          var y, P, I;
          for (n.Sequence < g && (d |= z), y = [], P = 0, I = c.expressions.length; P < I; ++P)
            y.push(this.generateExpression(c.expressions[P], n.Assignment, d)), P + 1 < I && y.push("," + C);
          return ze(y, n.Sequence, g);
        },
        AssignmentExpression: function(c, g, d) {
          return this.generateAssignment(c.left, c.right, c.operator, g, d);
        },
        ArrowFunctionExpression: function(c, g, d) {
          return ze(this.generateFunctionBody(c), n.ArrowFunction, g);
        },
        ConditionalExpression: function(c, g, d) {
          return n.Conditional < g && (d |= z), ze(
            [
              this.generateExpression(c.test, n.Coalesce, d),
              C + "?" + C,
              this.generateExpression(c.consequent, n.Assignment, d),
              C + ":" + C,
              this.generateExpression(c.alternate, n.Assignment, d)
            ],
            n.Conditional,
            g
          );
        },
        LogicalExpression: function(c, g, d) {
          return c.operator === "??" && (d |= ke), this.BinaryExpression(c, g, d);
        },
        BinaryExpression: function(c, g, d) {
          var y, P, I, R, Z, Y;
          return R = r[c.operator], P = c.operator === "**" ? n.Postfix : R, I = c.operator === "**" ? R : R + 1, R < g && (d |= z), Z = this.generateExpression(c.left, P, d), Y = Z.toString(), Y.charCodeAt(Y.length - 1) === 47 && u.code.isIdentifierPartES5(c.operator.charCodeAt(0)) ? y = [Z, _e(), c.operator] : y = Q(Z, c.operator), Z = this.generateExpression(c.right, I, d), c.operator === "/" && Z.toString().charAt(0) === "/" || c.operator.slice(-1) === "<" && Z.toString().slice(0, 3) === "!--" ? (y.push(_e()), y.push(Z)) : y = Q(y, Z), c.operator === "in" && !(d & z) ? ["(", y, ")"] : (c.operator === "||" || c.operator === "&&") && d & ke ? ["(", y, ")"] : ze(y, R, g);
        },
        CallExpression: function(c, g, d) {
          var y, P, I;
          for (y = [this.generateExpression(c.callee, n.Call, oe)], c.optional && y.push("?."), y.push("("), P = 0, I = c.arguments.length; P < I; ++P)
            y.push(this.generateExpression(c.arguments[P], n.Assignment, W)), P + 1 < I && y.push("," + C);
          return y.push(")"), d & te ? ze(y, n.Call, g) : ["(", y, ")"];
        },
        ChainExpression: function(c, g, d) {
          n.OptionalChaining < g && (d |= te);
          var y = this.generateExpression(c.expression, n.OptionalChaining, d);
          return ze(y, n.OptionalChaining, g);
        },
        NewExpression: function(c, g, d) {
          var y, P, I, R, Z;
          if (P = c.arguments.length, Z = d & me && !F && P === 0 ? tt : $e, y = Q(
            "new",
            this.generateExpression(c.callee, n.New, Z)
          ), !(d & me) || F || P > 0) {
            for (y.push("("), I = 0, R = P; I < R; ++I)
              y.push(this.generateExpression(c.arguments[I], n.Assignment, W)), I + 1 < R && y.push("," + C);
            y.push(")");
          }
          return ze(y, n.New, g);
        },
        MemberExpression: function(c, g, d) {
          var y, P;
          return y = [this.generateExpression(c.object, n.Call, d & te ? oe : $e)], c.computed ? (c.optional && y.push("?."), y.push("["), y.push(this.generateExpression(c.property, n.Sequence, d & te ? W : tt)), y.push("]")) : (!c.optional && c.object.type === t.Literal && typeof c.object.value == "number" && (P = be(y).toString(), P.indexOf(".") < 0 && !/[eExX]/.test(P) && u.code.isDecimalDigit(P.charCodeAt(P.length - 1)) && !(P.length >= 2 && P.charCodeAt(0) === 48) && y.push(" ")), y.push(c.optional ? "?." : "."), y.push(rt(c.property))), ze(y, n.Member, g);
        },
        MetaProperty: function(c, g, d) {
          var y;
          return y = [], y.push(typeof c.meta == "string" ? c.meta : rt(c.meta)), y.push("."), y.push(typeof c.property == "string" ? c.property : rt(c.property)), ze(y, n.Member, g);
        },
        UnaryExpression: function(c, g, d) {
          var y, P, I, R, Z;
          return P = this.generateExpression(c.argument, n.Unary, W), C === "" ? y = Q(c.operator, P) : (y = [c.operator], c.operator.length > 2 ? y = Q(y, P) : (R = be(y).toString(), Z = R.charCodeAt(R.length - 1), I = P.toString().charCodeAt(0), ((Z === 43 || Z === 45) && Z === I || u.code.isIdentifierPartES5(Z) && u.code.isIdentifierPartES5(I)) && y.push(_e()), y.push(P))), ze(y, n.Unary, g);
        },
        YieldExpression: function(c, g, d) {
          var y;
          return c.delegate ? y = "yield*" : y = "yield", c.argument && (y = Q(
            y,
            this.generateExpression(c.argument, n.Yield, W)
          )), ze(y, n.Yield, g);
        },
        AwaitExpression: function(c, g, d) {
          var y = Q(
            c.all ? "await*" : "await",
            this.generateExpression(c.argument, n.Await, W)
          );
          return ze(y, n.Await, g);
        },
        UpdateExpression: function(c, g, d) {
          return c.prefix ? ze(
            [
              c.operator,
              this.generateExpression(c.argument, n.Unary, W)
            ],
            n.Unary,
            g
          ) : ze(
            [
              this.generateExpression(c.argument, n.Postfix, W),
              c.operator
            ],
            n.Postfix,
            g
          );
        },
        FunctionExpression: function(c, g, d) {
          var y = [
            Qt(c, !0),
            "function"
          ];
          return c.id ? (y.push(Sn(c) || _e()), y.push(rt(c.id))) : y.push(Sn(c) || C), y.push(this.generateFunctionBody(c)), y;
        },
        ArrayPattern: function(c, g, d) {
          return this.ArrayExpression(c, g, d, !0);
        },
        ArrayExpression: function(c, g, d, y) {
          var P, I, R = this;
          return c.elements.length ? (I = y ? !1 : c.elements.length > 1, P = ["[", I ? M : ""], Be(function(Z) {
            var Y, fe;
            for (Y = 0, fe = c.elements.length; Y < fe; ++Y)
              c.elements[Y] ? (P.push(I ? Z : ""), P.push(R.generateExpression(c.elements[Y], n.Assignment, W))) : (I && P.push(Z), Y + 1 === fe && P.push(",")), Y + 1 < fe && P.push("," + (I ? M : C));
          }), I && !Ge(be(P).toString()) && P.push(M), P.push(I ? a : ""), P.push("]"), P) : "[]";
        },
        RestElement: function(c, g, d) {
          return "..." + this.generatePattern(c.argument);
        },
        ClassExpression: function(c, g, d) {
          var y, P;
          return y = ["class"], c.id && (y = Q(y, this.generateExpression(c.id, n.Sequence, W))), c.superClass && (P = Q("extends", this.generateExpression(c.superClass, n.Unary, W)), y = Q(y, P)), y.push(C), y.push(this.generateStatement(c.body, qe)), y;
        },
        MethodDefinition: function(c, g, d) {
          var y, P;
          return c.static ? y = ["static" + C] : y = [], c.kind === "get" || c.kind === "set" ? P = [
            Q(c.kind, this.generatePropertyKey(c.key, c.computed)),
            this.generateFunctionBody(c.value)
          ] : P = [
            nr(c),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ], Q(y, P);
        },
        Property: function(c, g, d) {
          return c.kind === "get" || c.kind === "set" ? [
            c.kind,
            _e(),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ] : c.shorthand ? c.value.type === "AssignmentPattern" ? this.AssignmentPattern(c.value, n.Sequence, W) : this.generatePropertyKey(c.key, c.computed) : c.method ? [
            nr(c),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ] : [
            this.generatePropertyKey(c.key, c.computed),
            ":" + C,
            this.generateExpression(c.value, n.Assignment, W)
          ];
        },
        ObjectExpression: function(c, g, d) {
          var y, P, I, R = this;
          return c.properties.length ? (y = c.properties.length > 1, Be(function() {
            I = R.generateExpression(c.properties[0], n.Sequence, W);
          }), !y && !En(be(I).toString()) ? ["{", C, I, C, "}"] : (Be(function(Z) {
            var Y, fe;
            if (P = ["{", M, Z, I], y)
              for (P.push("," + M), Y = 1, fe = c.properties.length; Y < fe; ++Y)
                P.push(Z), P.push(R.generateExpression(c.properties[Y], n.Sequence, W)), Y + 1 < fe && P.push("," + M);
          }), Ge(be(P).toString()) || P.push(M), P.push(a), P.push("}"), P)) : "{}";
        },
        AssignmentPattern: function(c, g, d) {
          return this.generateAssignment(c.left, c.right, "=", g, d);
        },
        ObjectPattern: function(c, g, d) {
          var y, P, I, R, Z, Y = this;
          if (!c.properties.length)
            return "{}";
          if (R = !1, c.properties.length === 1)
            Z = c.properties[0], Z.type === t.Property && Z.value.type !== t.Identifier && (R = !0);
          else
            for (P = 0, I = c.properties.length; P < I; ++P)
              if (Z = c.properties[P], Z.type === t.Property && !Z.shorthand) {
                R = !0;
                break;
              }
          return y = ["{", R ? M : ""], Be(function(fe) {
            var Te, xt;
            for (Te = 0, xt = c.properties.length; Te < xt; ++Te)
              y.push(R ? fe : ""), y.push(Y.generateExpression(c.properties[Te], n.Sequence, W)), Te + 1 < xt && y.push("," + (R ? M : C));
          }), R && !Ge(be(y).toString()) && y.push(M), y.push(R ? a : ""), y.push("}"), y;
        },
        ThisExpression: function(c, g, d) {
          return "this";
        },
        Super: function(c, g, d) {
          return "super";
        },
        Identifier: function(c, g, d) {
          return rt(c);
        },
        ImportDefaultSpecifier: function(c, g, d) {
          return rt(c.id || c.local);
        },
        ImportNamespaceSpecifier: function(c, g, d) {
          var y = ["*"], P = c.id || c.local;
          return P && y.push(C + "as" + _e() + rt(P)), y;
        },
        ImportSpecifier: function(c, g, d) {
          var y = c.imported, P = [y.name], I = c.local;
          return I && I.name !== y.name && P.push(_e() + "as" + _e() + rt(I)), P;
        },
        ExportSpecifier: function(c, g, d) {
          var y = c.local, P = [y.name], I = c.exported;
          return I && I.name !== y.name && P.push(_e() + "as" + _e() + rt(I)), P;
        },
        Literal: function(c, g, d) {
          var y;
          if (c.hasOwnProperty("raw") && x && S.raw)
            try {
              if (y = x(c.raw).body[0].expression, y.type === t.Literal && y.value === c.value)
                return c.raw;
            } catch {
            }
          return c.regex ? "/" + c.regex.pattern + "/" + c.regex.flags : typeof c.value == "bigint" ? c.value.toString() + "n" : c.bigint ? c.bigint + "n" : c.value === null ? "null" : typeof c.value == "string" ? ct(c.value) : typeof c.value == "number" ? Et(c.value) : typeof c.value == "boolean" ? c.value ? "true" : "false" : xn(c.value);
        },
        GeneratorExpression: function(c, g, d) {
          return this.ComprehensionExpression(c, g, d);
        },
        ComprehensionExpression: function(c, g, d) {
          var y, P, I, R, Z = this;
          return y = c.type === t.GeneratorExpression ? ["("] : ["["], S.moz.comprehensionExpressionStartsWithAssignment && (R = this.generateExpression(c.body, n.Assignment, W), y.push(R)), c.blocks && Be(function() {
            for (P = 0, I = c.blocks.length; P < I; ++P)
              R = Z.generateExpression(c.blocks[P], n.Sequence, W), P > 0 || S.moz.comprehensionExpressionStartsWithAssignment ? y = Q(y, R) : y.push(R);
          }), c.filter && (y = Q(y, "if" + C), R = this.generateExpression(c.filter, n.Sequence, W), y = Q(y, ["(", R, ")"])), S.moz.comprehensionExpressionStartsWithAssignment || (R = this.generateExpression(c.body, n.Assignment, W), y = Q(y, R)), y.push(c.type === t.GeneratorExpression ? ")" : "]"), y;
        },
        ComprehensionBlock: function(c, g, d) {
          var y;
          return c.left.type === t.VariableDeclaration ? y = [
            c.left.kind,
            _e(),
            this.generateStatement(c.left.declarations[0], Ee)
          ] : y = this.generateExpression(c.left, n.Call, W), y = Q(y, c.of ? "of" : "in"), y = Q(y, this.generateExpression(c.right, n.Sequence, W)), ["for" + C + "(", y, ")"];
        },
        SpreadElement: function(c, g, d) {
          return [
            "...",
            this.generateExpression(c.argument, n.Assignment, W)
          ];
        },
        TaggedTemplateExpression: function(c, g, d) {
          var y = oe;
          d & te || (y = $e);
          var P = [
            this.generateExpression(c.tag, n.Call, y),
            this.generateExpression(c.quasi, n.Primary, xe)
          ];
          return ze(P, n.TaggedTemplate, g);
        },
        TemplateElement: function(c, g, d) {
          return c.value.raw;
        },
        TemplateLiteral: function(c, g, d) {
          var y, P, I;
          for (y = ["`"], P = 0, I = c.quasis.length; P < I; ++P)
            y.push(this.generateExpression(c.quasis[P], n.Primary, W)), P + 1 < I && (y.push("${" + C), y.push(this.generateExpression(c.expressions[P], n.Sequence, W)), y.push(C + "}"));
          return y.push("`"), y;
        },
        ModuleSpecifier: function(c, g, d) {
          return this.Literal(c, g, d);
        },
        ImportExpression: function(c, g, d) {
          return ze([
            "import(",
            this.generateExpression(c.source, n.Assignment, W),
            ")"
          ], n.Call, g);
        }
      }, Yt(Ie.prototype, Ie.Expression), Ie.prototype.generateExpression = function(c, g, d) {
        var y, P;
        return P = c.type || t.Property, S.verbatim && c.hasOwnProperty(S.verbatim) ? Wn(c, g) : (y = this[P](c, g, d), S.comment && (y = wn(c, y)), be(y, c));
      }, Ie.prototype.generateStatement = function(c, g) {
        var d, y;
        return d = this[c.type](c, g), S.comment && (d = wn(c, d)), y = be(d).toString(), c.type === t.Program && !k && M === "" && y.charAt(y.length - 1) === `
` && (d = B ? be(d).replaceRight(/\s+$/, "") : y.replace(/\s+$/, "")), be(d, c);
      };
      function Ir(c) {
        var g;
        if (g = new Ie(), O(c))
          return g.generateStatement(c, ge);
        if (U(c))
          return g.generateExpression(c, n.Sequence, W);
        throw new Error("Unknown node type: " + c.type);
      }
      function Tr(c, g) {
        var d = bt(), y, P;
        return g != null ? (typeof g.indent == "string" && (d.format.indent.style = g.indent), typeof g.base == "number" && (d.format.indent.base = g.base), g = dt(d, g), o = g.format.indent.style, typeof g.base == "string" ? a = g.base : a = Ve(o, g.format.indent.base)) : (g = d, o = g.format.indent.style, a = Ve(o, g.format.indent.base)), f = g.format.json, h = g.format.renumber, m = f ? !1 : g.format.hexadecimal, p = f ? "double" : g.format.quotes, A = g.format.escapeless, M = g.format.newline, C = g.format.space, g.format.compact && (M = C = o = a = ""), F = g.format.parentheses, _ = g.format.semicolons, k = g.format.safeConcatenation, L = g.directive, x = f ? null : g.parse, B = g.sourceMap, V = g.sourceCode, T = g.format.preserveBlankLines && V !== null, S = g, B && (e.browser ? i = BP.sourceMap.SourceNode : i = WP().SourceNode), y = Ir(c), B ? (P = y.toStringWithSourceMap({
          file: g.file,
          sourceRoot: g.sourceMapRoot
        }), g.sourceContent && P.map.setSourceContent(
          g.sourceMap,
          g.sourceContent
        ), g.sourceMapWithCode ? P : P.map.toString()) : (P = { code: y.toString(), map: null }, g.sourceMapWithCode ? P : P.code);
      }
      H = {
        indent: {
          style: "",
          base: 0
        },
        renumber: !0,
        hexadecimal: !0,
        quotes: "auto",
        escapeless: !0,
        compact: !0,
        parentheses: !1,
        semicolons: !1
      }, X = bt().format, e.version = iD.version, e.generate = Tr, e.attachComments = s.attachComments, e.Precedence = dt({}, n), e.browser = !1, e.FORMAT_MINIFY = H, e.FORMAT_DEFAULTS = X;
    })();
  }(Xs)), Xs;
}
var uD = sD();
const aD = /* @__PURE__ */ Zm(uD);
class oD {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (t) => this.replacement = t
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(t, n, r, i) {
    t && n && (r != null ? t[n][r] = i : t[n] = i);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(t, n, r) {
    t && n && (r != null ? t[n].splice(r, 1) : delete t[n]);
  }
}
class cD extends oD {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(t, n) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (r) => this.replacement = r
    }, this.enter = t, this.leave = n;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(t, n, r, i) {
    if (t) {
      if (this.enter) {
        const u = this.should_skip, a = this.should_remove, o = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const f = this.should_skip, h = this.should_remove;
        if (this.should_skip = u, this.should_remove = a, this.replacement = o, f) return t;
        if (h) return null;
      }
      let s;
      for (s in t) {
        const u = t[s];
        if (u && typeof u == "object")
          if (Array.isArray(u)) {
            const a = (
              /** @type {Array<unknown>} */
              u
            );
            for (let o = 0; o < a.length; o += 1) {
              const f = a[o];
              Ho(f) && (this.visit(f, t, s, o) || o--);
            }
          } else Ho(u) && this.visit(u, t, s, null);
      }
      if (this.leave) {
        const u = this.replacement, a = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const o = this.should_remove;
        if (this.replacement = u, this.should_remove = a, o) return null;
      }
    }
    return t;
  }
}
function Ho(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function lD(e, { enter: t, leave: n }) {
  return new cD(t, n).visit(e, null);
}
let jm = [];
function PE(e) {
  jm.push(e);
}
let oi = /* @__PURE__ */ new Map();
function DE(e, t) {
  oi.set(e, t);
}
function fD(e, t = {}) {
  const { wrapAsync: n = !1, addReturn: r = !0, emitMiniLocations: i = !0, emitWidgets: s = !0 } = t;
  let u = SP(e, {
    ecmaVersion: 2022,
    allowAwaitOutsideFunction: !0,
    locations: !0
  }), a = [];
  const o = (p, A) => {
    const M = oi.get("minilang");
    if (M) {
      const C = `[${p}]`, F = M.getLocations(C, A.start);
      a = a.concat(F);
    } else {
      const C = pa(`"${p}"`, A.start, e);
      a = a.concat(C);
    }
  };
  let f = [];
  lD(u, {
    enter(p, A) {
      if (PD(p)) {
        const { name: M } = p.tag, C = oi.get(M), F = p.quasi.quasis[0].value.raw, _ = p.quasi.start + 1;
        if (i) {
          const k = C.getLocations(F, _);
          a = a.concat(k);
        }
        return this.skip(), this.replace(xD(M, F, _));
      }
      if (DD(p, "tidal")) {
        const M = p.quasi.quasis[0].value.raw, C = p.quasi.start + 1;
        if (i) {
          const F = FD(M, C);
          a = a.concat(F);
        }
        return this.skip(), this.replace(ED(M, C));
      }
      if (pD(p, A)) {
        const { quasis: M } = p, { raw: C } = M[0].value;
        return this.skip(), i && o(C, p), this.replace(Ko(C, p));
      }
      if (hD(p)) {
        const { value: M } = p;
        return this.skip(), i && o(M, p), this.replace(Ko(M, p));
      }
      if (dD(p))
        return s && f.push({
          from: p.arguments[0].start,
          to: p.arguments[0].end,
          value: p.arguments[0].raw,
          // don't use value!
          min: p.arguments[1]?.value ?? 0,
          max: p.arguments[2]?.value ?? 1,
          step: p.arguments[3]?.value,
          type: "slider"
        }), this.replace(gD(p));
      if (mD(p)) {
        const M = p.callee.property.name, C = f.filter((_) => _.type === M).length, F = {
          to: p.end,
          index: C,
          type: M,
          id: t.id
        };
        return s && f.push(F), this.replace(AD(p, F));
      }
      if (bD(p, A))
        return this.replace(MD(p));
      if (CD(p))
        return this.replace(vD(p));
    },
    leave(p, A, M, C) {
    }
  });
  let { body: h } = u;
  if (!h.length)
    console.warn("empty body -> fallback to silence"), h.push({
      type: "ExpressionStatement",
      expression: {
        type: "Identifier",
        name: "silence"
      }
    });
  else if (!h?.[h.length - 1]?.expression)
    throw new Error("unexpected ast format without body expression");
  if (r) {
    const { expression: p } = h[h.length - 1];
    h[h.length - 1] = {
      type: "ReturnStatement",
      argument: p
    };
  }
  let m = aD.generate(u);
  return n && (m = `(async ()=>{${m}})()`), i ? { output: m, miniLocations: a, widgets: f } : { output: m };
}
function hD(e, t, n) {
  return e.type !== "Literal" ? !1 : e.raw[0] === '"';
}
function pD(e, t) {
  return e.type === "TemplateLiteral" && t.type !== "TaggedTemplateExpression";
}
function Ko(e, t) {
  const { start: n } = t, r = oi.get("minilang");
  let i = "m";
  return r && r.name && (i = r.name), {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: i
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: n }
    ],
    optional: !1
  };
}
function dD(e) {
  return e.type === "CallExpression" && e.callee.name === "slider";
}
function mD(e) {
  return e.type === "CallExpression" && jm.includes(e.callee.property?.name);
}
function gD(e) {
  const t = "slider_" + e.arguments[0].start;
  return e.arguments.unshift({
    type: "Literal",
    value: t,
    raw: t
  }), e.callee.name = "sliderWithID", e;
}
function yD(e) {
  return `${e.id || ""}_widget_${e.type}_${e.index}`;
}
function AD(e, t) {
  const n = yD(t);
  return e.arguments.unshift({
    type: "Literal",
    value: n,
    raw: n
  }), e;
}
function bD(e, t) {
  return e.type === "CallExpression" && e.callee.name === "samples" && t.type !== "AwaitExpression";
}
function MD(e) {
  return {
    type: "AwaitExpression",
    argument: e
  };
}
function CD(e) {
  return e.type === "LabeledStatement";
}
function vD(e) {
  return {
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: e.body.expression,
        property: {
          type: "Identifier",
          name: "p"
        }
      },
      arguments: [
        {
          type: "Literal",
          value: e.label.name,
          raw: `'${e.label.name}'`
        }
      ]
    }
  };
}
function PD(e) {
  return e.type === "TaggedTemplateExpression" && oi.has(e.tag.name);
}
function DD(e, t) {
  return e.type === "TaggedTemplateExpression" && e.tag.name === t;
}
function FD(e, t) {
  return e.split("").reduce((n, r, i) => (r !== '"' || (!n.length || n[n.length - 1].length > 1 ? n.push([i + 1]) : n[n.length - 1].push(i)), n), []).map(([n, r]) => {
    const i = e.slice(n, r);
    return pa(`"${i}"`, t + n - 1);
  }).flat();
}
function ED(e, t) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "tidal"
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: t }
    ],
    optional: !1
  };
}
function xD(e, t, n) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: e
    },
    arguments: [
      { type: "Literal", value: t },
      { type: "Literal", value: n }
    ],
    optional: !1
  };
}
function Pa(e) {
  return e !== null && typeof e == "object" && "name" in e && typeof e.name == "string";
}
function Da(e) {
  return e !== null && typeof e == "object" && "step" in e && typeof e.step == "number" && "alt" in e && typeof e.alt == "number" && !isNaN(e.step) && !isNaN(e.alt);
}
var $m = [0, 2, 4, -1, 1, 3, 5], qm = $m.map(
  (e) => Math.floor(e * 7 / 12)
);
function Hm(e) {
  const { step: t, alt: n, oct: r, dir: i = 1 } = e, s = $m[t] + 7 * n;
  if (r === void 0)
    return [i * s];
  const u = r - qm[t] - 4 * n;
  return [i * s, i * u];
}
var wD = [3, 0, 4, 1, 5, 2, 6];
function Km(e) {
  const [t, n, r] = e, i = wD[SD(t)], s = Math.floor((t + 1) / 7);
  if (n === void 0)
    return { step: i, alt: s, dir: r };
  const u = n + 4 * s + qm[i];
  return { step: i, alt: s, oct: u, dir: r };
}
function SD(e) {
  const t = (e + 1) % 7;
  return t < 0 ? 7 + t : t;
}
var Yo = (e, t) => Array(Math.abs(t) + 1).join(e), Mu = Object.freeze({
  empty: !0,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
}), BD = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})", _D = "(AA|A|P|M|m|d|dd)([-+]?\\d+)", kD = new RegExp(
  "^" + BD + "|" + _D + "$"
);
function VD(e) {
  const t = kD.exec(`${e}`);
  return t === null ? ["", ""] : t[1] ? [t[1], t[2]] : [t[4], t[3]];
}
var Jo = {};
function rn(e) {
  return typeof e == "string" ? Jo[e] || (Jo[e] = ID(e)) : Da(e) ? rn(ND(e)) : Pa(e) ? rn(e.name) : Mu;
}
var Uo = [0, 2, 4, 5, 7, 9, 11], Ym = "PMMPPMM";
function ID(e) {
  const t = VD(e);
  if (t[0] === "")
    return Mu;
  const n = +t[0], r = t[1], i = (Math.abs(n) - 1) % 7, s = Ym[i];
  if (s === "M" && r === "P")
    return Mu;
  const u = s === "M" ? "majorable" : "perfectable", a = "" + n + r, o = n < 0 ? -1 : 1, f = n === 8 || n === -8 ? n : o * (i + 1), h = TD(u, r), m = Math.floor((Math.abs(n) - 1) / 7), p = o * (Uo[i] + h + 12 * m), A = (o * (Uo[i] + h) % 12 + 12) % 12, M = Hm({ step: i, alt: h, oct: m, dir: o });
  return {
    empty: !1,
    name: a,
    num: n,
    q: r,
    step: i,
    alt: h,
    dir: o,
    type: u,
    simple: f,
    semitones: p,
    chroma: A,
    coord: M,
    oct: m
  };
}
function Jm(e, t) {
  const [n, r = 0] = e, i = n * 7 + r * 12 < 0, s = t || i ? [-n, -r, -1] : [n, r, 1];
  return rn(Km(s));
}
function TD(e, t) {
  return t === "M" && e === "majorable" || t === "P" && e === "perfectable" ? 0 : t === "m" && e === "majorable" ? -1 : /^A+$/.test(t) ? t.length : /^d+$/.test(t) ? -1 * (e === "perfectable" ? t.length : t.length + 1) : 0;
}
function ND(e) {
  const { step: t, alt: n, oct: r = 0, dir: i } = e;
  if (!i)
    return "";
  const s = t + 1 + 7 * r, u = s === 0 ? t + 1 : s, a = i < 0 ? "-" : "", o = Ym[t] === "M" ? "majorable" : "perfectable";
  return a + u + LD(o, n);
}
function LD(e, t) {
  return t === 0 ? e === "majorable" ? "M" : "P" : t === -1 && e === "majorable" ? "m" : t > 0 ? Yo("A", t) : Yo("d", e === "perfectable" ? t : t + 1);
}
var Qo = (e, t) => Array(Math.abs(t) + 1).join(e), Um = Object.freeze({
  empty: !0,
  name: "",
  letter: "",
  acc: "",
  pc: "",
  step: NaN,
  alt: NaN,
  chroma: NaN,
  height: NaN,
  coord: [],
  midi: null,
  freq: null
}), ec = /* @__PURE__ */ new Map(), RD = (e) => "CDEFGAB".charAt(e), os = (e) => e < 0 ? Qo("b", -e) : Qo("#", e), Fa = (e) => e[0] === "b" ? -e.length : e.length;
function Fe(e) {
  const t = JSON.stringify(e), n = ec.get(t);
  if (n)
    return n;
  const r = typeof e == "string" ? WD(e) : Da(e) ? Fe(OD(e)) : Pa(e) ? Fe(e.name) : Um;
  return ec.set(t, r), r;
}
var GD = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function Ea(e) {
  const t = GD.exec(e);
  return t ? [t[1].toUpperCase(), t[2].replace(/x/g, "##"), t[3], t[4]] : ["", "", "", ""];
}
function ZD(e) {
  return Fe(Km(e));
}
var XD = (e, t) => (e % t + t) % t, Qs = [0, 2, 4, 5, 7, 9, 11];
function WD(e) {
  const t = Ea(e);
  if (t[0] === "" || t[3] !== "")
    return Um;
  const n = t[0], r = t[1], i = t[2], s = (n.charCodeAt(0) + 3) % 7, u = Fa(r), a = i.length ? +i : void 0, o = Hm({ step: s, alt: u, oct: a }), f = n + r + i, h = n + r, m = (Qs[s] + u + 120) % 12, p = a === void 0 ? XD(Qs[s] + u, 12) - 12 * 99 : Qs[s] + u + 12 * (a + 1), A = p >= 0 && p <= 127 ? p : null, M = a === void 0 ? null : Math.pow(2, (p - 69) / 12) * 440;
  return {
    empty: !1,
    acc: r,
    alt: u,
    chroma: m,
    coord: o,
    freq: M,
    height: p,
    letter: n,
    midi: A,
    name: f,
    oct: a,
    pc: h,
    step: s
  };
}
function OD(e) {
  const { step: t, alt: n, oct: r } = e, i = RD(t);
  if (!i)
    return "";
  const s = i + os(n);
  return r || r === 0 ? s + r : s;
}
function Ht(e, t) {
  const n = Fe(e), r = Array.isArray(t) ? t : rn(t).coord;
  if (n.empty || !r || r.length < 2)
    return "";
  const i = n.coord, s = i.length === 1 ? [i[0] + r[0]] : [i[0] + r[0], i[1] + r[1]];
  return ZD(s).name;
}
function Qm(e, t) {
  const n = e.length;
  return (r) => {
    if (!t) return "";
    const i = r < 0 ? (n - -r % n) % n : r % n, s = Math.floor(r / n), u = Ht(t, [0, s]);
    return Ht(u, e[i]);
  };
}
function cs(e, t) {
  const n = Fe(e), r = Fe(t);
  if (n.empty || r.empty)
    return "";
  const i = n.coord, s = r.coord, u = s[0] - i[0], a = i.length === 2 && s.length === 2 ? s[1] - i[1] : -Math.floor(u * 7 / 12), o = r.height === n.height && r.midi !== null && n.oct === r.oct && n.step > r.step;
  return Jm([u, a], o).name;
}
var tc = (e, t) => Array(t + 1).join(e), zD = /^(_{1,}|=|\^{1,}|)([abcdefgABCDEFG])([,']*)$/;
function eg(e) {
  const t = zD.exec(e);
  return t ? [t[1], t[2], t[3]] : ["", "", ""];
}
function ji(e) {
  const [t, n, r] = eg(e);
  if (n === "")
    return "";
  let i = 4;
  for (let u = 0; u < r.length; u++)
    i += r.charAt(u) === "," ? -1 : 1;
  const s = t[0] === "_" ? t.replace(/_/g, "b") : t[0] === "^" ? t.replace(/\^/g, "#") : "";
  return n.charCodeAt(0) > 96 ? n.toUpperCase() + s + (i + 1) : n + s + i;
}
function tg(e) {
  const t = Fe(e);
  if (t.empty || !t.oct && t.oct !== 0)
    return "";
  const { letter: n, acc: r, oct: i } = t, s = r[0] === "b" ? r.replace(/b/g, "_") : r.replace(/#/g, "^"), u = i > 4 ? n.toLowerCase() : n, a = i === 5 ? "" : i > 4 ? tc("'", i - 5) : tc(",", 4 - i);
  return s + u + a;
}
function jD(e, t) {
  return tg(Ht(ji(e), t));
}
function $D(e, t) {
  return cs(ji(e), ji(t));
}
var qD = {
  abcToScientificNotation: ji,
  scientificToAbcNotation: tg,
  tokenize: eg,
  transpose: jD,
  distance: $D
};
function HD(e, t) {
  const n = [];
  for (; t--; n[t] = t + e) ;
  return n;
}
function KD(e, t) {
  const n = [];
  for (; t--; n[t] = e - t) ;
  return n;
}
function YD(e, t) {
  return e < t ? HD(e, t - e + 1) : KD(e, e - t + 1);
}
function JD(e, t) {
  const n = t.length, r = (e % n + n) % n;
  return t.slice(r, n).concat(t.slice(0, r));
}
function UD(e) {
  return e.filter((t) => t === 0 || t);
}
function ng(e) {
  return e.map((n) => Fe(n)).filter((n) => !n.empty).sort((n, r) => n.height - r.height).map((n) => n.name);
}
function QD(e) {
  return ng(e).filter((t, n, r) => n === 0 || t !== r[n - 1]);
}
function e5(e, t = Math.random) {
  let n, r, i = e.length;
  for (; i; )
    n = Math.floor(t() * i--), r = e[i], e[i] = e[n], e[n] = r;
  return e;
}
function rg(e) {
  return e.length === 0 ? [[]] : rg(e.slice(1)).reduce((t, n) => t.concat(
    e.map((r, i) => {
      const s = n.slice();
      return s.splice(i, 0, e[0]), s;
    })
  ), []);
}
const t5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compact: UD,
  permutations: rg,
  range: YD,
  rotate: JD,
  shuffle: e5,
  sortedNoteNames: ng,
  sortedUniqNoteNames: QD
}, Symbol.toStringTag, { value: "Module" }));
function n5(e, t) {
  const n = [];
  for (; t--; n[t] = t + e) ;
  return n;
}
function r5(e, t) {
  const n = [];
  for (; t--; n[t] = e - t) ;
  return n;
}
function ls(e, t) {
  return e < t ? n5(e, t - e + 1) : r5(e, e - t + 1);
}
function wr(e, t) {
  const n = t.length, r = (e % n + n) % n;
  return t.slice(r, n).concat(t.slice(0, r));
}
function xa(e) {
  return e.filter((t) => t === 0 || t);
}
function i5(e, t = Math.random) {
  let n, r, i = e.length;
  for (; i; )
    n = Math.floor(t() * i--), r = e[i], e[i] = e[n], e[n] = r;
  return e;
}
function ig(e) {
  return e.length === 0 ? [[]] : ig(e.slice(1)).reduce((t, n) => t.concat(
    e.map((r, i) => {
      const s = n.slice();
      return s.splice(i, 0, e[0]), s;
    })
  ), []);
}
var s5 = {
  compact: xa,
  permutations: ig,
  range: ls,
  rotate: wr,
  shuffle: i5
}, In = {
  empty: !0,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
}, wa = (e) => Number(e).toString(2).padStart(12, "0"), nc = (e) => parseInt(e, 2), u5 = /^[01]{12}$/;
function Sa(e) {
  return u5.test(e);
}
var a5 = (e) => typeof e == "number" && e >= 0 && e <= 4095, o5 = (e) => e && Sa(e.chroma), rc = { [In.chroma]: In };
function ut(e) {
  const t = Sa(e) ? e : a5(e) ? wa(e) : Array.isArray(e) ? M5(e) : o5(e) ? e.chroma : In.chroma;
  return rc[t] = rc[t] || b5(t);
}
var c5 = ut, sg = (e) => ut(e).chroma, l5 = (e) => ut(e).intervals, f5 = (e) => ut(e).setNum, h5 = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function p5(e) {
  const t = [];
  for (let n = 0; n < 12; n++)
    e.charAt(n) === "1" && t.push(h5[n]);
  return t;
}
function d5(e) {
  return ut(e).intervals.map((t) => Ht("C", t));
}
function m5() {
  return ls(2048, 4095).map(wa);
}
function Ba(e, t = !0) {
  const r = ut(e).chroma.split("");
  return xa(
    r.map((i, s) => {
      const u = wr(s, r);
      return t && u[0] === "0" ? null : u.join("");
    })
  );
}
function g5(e, t) {
  return ut(e).setNum === ut(t).setNum;
}
function fs(e) {
  const t = ut(e).setNum;
  return (n) => {
    const r = ut(n).setNum;
    return t && t !== r && (r & t) === r;
  };
}
function hs(e) {
  const t = ut(e).setNum;
  return (n) => {
    const r = ut(n).setNum;
    return t && t !== r && (r | t) === r;
  };
}
function ug(e) {
  const t = ut(e);
  return (n) => {
    const r = Fe(n);
    return t && !r.empty && t.chroma.charAt(r.chroma) === "1";
  };
}
function y5(e) {
  const t = ug(e);
  return (n) => n.filter(t);
}
var ag = {
  get: ut,
  chroma: sg,
  num: f5,
  intervals: l5,
  chromas: m5,
  isSupersetOf: hs,
  isSubsetOf: fs,
  isNoteIncludedIn: ug,
  isEqual: g5,
  filter: y5,
  modes: Ba,
  notes: d5,
  // deprecated
  pcset: c5
};
function A5(e) {
  const t = e.split("");
  return t.map((n, r) => wr(r, t).join(""));
}
function b5(e) {
  const t = nc(e), n = A5(e).map(nc).filter((s) => s >= 2048).sort()[0], r = wa(n), i = p5(e);
  return {
    empty: !1,
    name: "",
    setNum: t,
    chroma: e,
    normalized: r,
    intervals: i
  };
}
function M5(e) {
  if (e.length === 0)
    return In.chroma;
  let t;
  const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let r = 0; r < e.length; r++)
    t = Fe(e[r]), t.empty && (t = rn(e[r])), t.empty || (n[t.chroma] = 1);
  return n.join("");
}
var C5 = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
], v5 = C5;
({
  ...In
});
var _a = [], Bi = {};
function og() {
  return _a.slice();
}
function P5(e, t, n) {
  const r = F5(e), i = {
    ...ut(e),
    name: n || "",
    quality: r,
    intervals: e,
    aliases: t
  };
  _a.push(i), i.name && (Bi[i.name] = i), Bi[i.setNum] = i, Bi[i.chroma] = i, i.aliases.forEach((s) => D5(i, s));
}
function D5(e, t) {
  Bi[t] = e;
}
function F5(e) {
  const t = (n) => e.indexOf(n) !== -1;
  return t("5A") ? "Augmented" : t("3M") ? "Major" : t("5d") ? "Diminished" : t("3m") ? "Minor" : "Unknown";
}
v5.forEach(
  ([e, t, n]) => P5(e.split(" "), n.split(" "), t)
);
_a.sort((e, t) => e.setNum - t.setNum);
var E5 = (e) => {
  const t = e.reduce((n, r) => {
    const i = Fe(r).chroma;
    return i !== void 0 && (n[i] = n[i] || Fe(r).name), n;
  }, {});
  return (n) => t[n];
};
function x5(e, t = {}) {
  const n = e.map((i) => Fe(i).pc).filter((i) => i);
  return Fe.length === 0 ? [] : I5(n, 1, t).filter((i) => i.weight).sort((i, s) => s.weight - i.weight).map((i) => i.name);
}
var ps = {
  // 3m 000100000000
  // 3M 000010000000
  anyThirds: 384,
  // 5P 000000010000
  perfectFifth: 16,
  // 5d 000000100000
  // 5A 000000001000
  nonPerfectFifths: 40,
  anySeventh: 3
}, ds = (e) => (t) => !!(t & e), w5 = ds(ps.anyThirds), S5 = ds(ps.perfectFifth), B5 = ds(ps.anySeventh), _5 = ds(ps.nonPerfectFifths);
function k5(e) {
  const t = parseInt(e.chroma, 2);
  return w5(t) && S5(t) && B5(t);
}
function V5(e) {
  const t = parseInt(e, 2);
  return _5(t) ? e : (t | 16).toString(2);
}
function I5(e, t, n) {
  const r = e[0], i = Fe(r).chroma, s = E5(e), u = Ba(e, !1), a = [];
  return u.forEach((o, f) => {
    const h = n.assumePerfectFifth && V5(o);
    og().filter((p) => n.assumePerfectFifth && k5(p) ? p.chroma === h : p.chroma === o).forEach((p) => {
      const A = p.aliases[0], M = s(f);
      f !== i ? a.push({
        weight: 0.5 * t,
        name: `${M}${A}/${r}`
      }) : a.push({ weight: 1 * t, name: `${M}${A}` });
    });
  }), a;
}
function gi(e) {
  return e !== null && typeof e == "object" && "name" in e && typeof e.name == "string";
}
var cg = [0, 2, 4, 5, 7, 9, 11], lg = ({ step: e, alt: t }) => (cg[e] + t + 120) % 12, ka = ({ step: e, alt: t, oct: n, dir: r = 1 }) => r * (cg[e] + t + 12 * (n === void 0 ? -100 : n)), fg = (e) => {
  const t = ka(e);
  return e.oct !== void 0 && t >= -12 && t <= 115 ? t + 12 : null;
};
function ms(e) {
  return e !== null && typeof e == "object" && "step" in e && typeof e.step == "number" && "alt" in e && typeof e.alt == "number";
}
var hg = [0, 2, 4, -1, 1, 3, 5], pg = hg.map(
  (e) => Math.floor(e * 7 / 12)
);
function gs(e) {
  const { step: t, alt: n, oct: r, dir: i = 1 } = e, s = hg[t] + 7 * n;
  if (r === void 0)
    return [i * s];
  const u = r - pg[t] - 4 * n;
  return [i * s, i * u];
}
var T5 = [3, 0, 4, 1, 5, 2, 6];
function ys(e) {
  const [t, n, r] = e, i = T5[N5(t)], s = Math.floor((t + 1) / 7);
  if (n === void 0)
    return { step: i, alt: s, dir: r };
  const u = n + 4 * s + pg[i];
  return { step: i, alt: s, oct: u, dir: r };
}
function N5(e) {
  const t = (e + 1) % 7;
  return t < 0 ? 7 + t : t;
}
var ic = (e, t) => Array(Math.abs(t) + 1).join(e), Cu = { empty: !0, name: "", acc: "" }, L5 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})", R5 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)", G5 = new RegExp(
  "^" + L5 + "|" + R5 + "$"
);
function Va(e) {
  const t = G5.exec(`${e}`);
  return t === null ? ["", ""] : t[1] ? [t[1], t[2]] : [t[4], t[3]];
}
var sc = {};
function at(e) {
  return typeof e == "string" ? sc[e] || (sc[e] = Z5(e)) : ms(e) ? at(W5(e)) : gi(e) ? at(e.name) : Cu;
}
var uc = [0, 2, 4, 5, 7, 9, 11], dg = "PMMPPMM";
function Z5(e) {
  const t = Va(e);
  if (t[0] === "")
    return Cu;
  const n = +t[0], r = t[1], i = (Math.abs(n) - 1) % 7, s = dg[i];
  if (s === "M" && r === "P")
    return Cu;
  const u = s === "M" ? "majorable" : "perfectable", a = "" + n + r, o = n < 0 ? -1 : 1, f = n === 8 || n === -8 ? n : o * (i + 1), h = X5(u, r), m = Math.floor((Math.abs(n) - 1) / 7), p = o * (uc[i] + h + 12 * m), A = (o * (uc[i] + h) % 12 + 12) % 12, M = gs({ step: i, alt: h, oct: m, dir: o });
  return {
    empty: !1,
    name: a,
    num: n,
    q: r,
    step: i,
    alt: h,
    dir: o,
    type: u,
    simple: f,
    semitones: p,
    chroma: A,
    coord: M,
    oct: m
  };
}
function yi(e, t) {
  const [n, r = 0] = e, i = n * 7 + r * 12 < 0, s = t || i ? [-n, -r, -1] : [n, r, 1];
  return at(ys(s));
}
function X5(e, t) {
  return t === "M" && e === "majorable" || t === "P" && e === "perfectable" ? 0 : t === "m" && e === "majorable" ? -1 : /^A+$/.test(t) ? t.length : /^d+$/.test(t) ? -1 * (e === "perfectable" ? t.length : t.length + 1) : 0;
}
function W5(e) {
  const { step: t, alt: n, oct: r = 0, dir: i } = e;
  if (!i)
    return "";
  const s = t + 1 + 7 * r, u = s === 0 ? t + 1 : s, a = i < 0 ? "-" : "", o = dg[t] === "M" ? "majorable" : "perfectable";
  return a + u + O5(o, n);
}
function O5(e, t) {
  return t === 0 ? e === "majorable" ? "M" : "P" : t === -1 && e === "majorable" ? "m" : t > 0 ? ic("A", t) : ic("d", e === "perfectable" ? t : t + 1);
}
var ac = (e, t) => Array(Math.abs(t) + 1).join(e), mg = { empty: !0, name: "", pc: "", acc: "" }, oc = /* @__PURE__ */ new Map(), Ia = (e) => "CDEFGAB".charAt(e), Ta = (e) => e < 0 ? ac("b", -e) : ac("#", e), Na = (e) => e[0] === "b" ? -e.length : e.length;
function sn(e) {
  const t = JSON.stringify(e), n = oc.get(t);
  if (n)
    return n;
  const r = typeof e == "string" ? $5(e) : ms(e) ? sn(q5(e)) : gi(e) ? sn(e.name) : mg;
  return oc.set(t, r), r;
}
var z5 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function As(e) {
  const t = z5.exec(e);
  return t ? [t[1].toUpperCase(), t[2].replace(/x/g, "##"), t[3], t[4]] : ["", "", "", ""];
}
function La(e) {
  return sn(ys(e));
}
var j5 = (e, t) => (e % t + t) % t, eu = [0, 2, 4, 5, 7, 9, 11];
function $5(e) {
  const t = As(e);
  if (t[0] === "" || t[3] !== "")
    return mg;
  const n = t[0], r = t[1], i = t[2], s = (n.charCodeAt(0) + 3) % 7, u = Na(r), a = i.length ? +i : void 0, o = gs({ step: s, alt: u, oct: a }), f = n + r + i, h = n + r, m = (eu[s] + u + 120) % 12, p = a === void 0 ? j5(eu[s] + u, 12) - 12 * 99 : eu[s] + u + 12 * (a + 1), A = p >= 0 && p <= 127 ? p : null, M = a === void 0 ? null : Math.pow(2, (p - 69) / 12) * 440;
  return {
    empty: !1,
    acc: r,
    alt: u,
    chroma: m,
    coord: o,
    freq: M,
    height: p,
    letter: n,
    midi: A,
    name: f,
    oct: a,
    pc: h,
    step: s
  };
}
function q5(e) {
  const { step: t, alt: n, oct: r } = e, i = Ia(t);
  if (!i)
    return "";
  const s = i + Ta(n);
  return r || r === 0 ? s + r : s;
}
function Ar(e, t) {
  const n = sn(e), r = Array.isArray(t) ? t : at(t).coord;
  if (n.empty || !r || r.length < 2)
    return "";
  const i = n.coord, s = i.length === 1 ? [i[0] + r[0]] : [i[0] + r[0], i[1] + r[1]];
  return La(s).name;
}
function bs(e, t) {
  const n = e.length;
  return (r) => {
    if (!t)
      return "";
    const i = r < 0 ? (n - -r % n) % n : r % n, s = Math.floor(r / n), u = Ar(t, [0, s]);
    return Ar(u, e[i]);
  };
}
function Ra(e, t) {
  const n = sn(e), r = sn(t);
  if (n.empty || r.empty)
    return "";
  const i = n.coord, s = r.coord, u = s[0] - i[0], a = i.length === 2 && s.length === 2 ? s[1] - i[1] : -Math.floor(u * 7 / 12), o = r.height === n.height && r.midi !== null && n.midi !== null && n.step > r.step;
  return yi([u, a], o).name;
}
var gg = (e, t) => Array(Math.abs(t) + 1).join(e);
function Sr(e, t, n) {
  return function(...r) {
    return console.warn(`${e} is deprecated. Use ${t}.`), n.apply(this, r);
  };
}
var yg = Sr("isNamed", "isNamedPitch", gi);
const Ag = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accToAlt: Na,
  altToAcc: Ta,
  chroma: lg,
  coordToInterval: yi,
  coordToNote: La,
  coordinates: gs,
  deprecate: Sr,
  distance: Ra,
  fillStr: gg,
  height: ka,
  interval: at,
  isNamed: yg,
  isNamedPitch: gi,
  isPitch: ms,
  midi: fg,
  note: sn,
  pitch: ys,
  stepToLetter: Ia,
  tokenizeInterval: Va,
  tokenizeNote: As,
  tonicIntervalsTransposer: bs,
  transpose: Ar
}, Symbol.toStringTag, { value: "Module" }));
var H5 = [
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
], K5 = H5, Y5 = {
  ...In,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
}, Br = [], jn = {};
function Ga(e) {
  return jn[e] || Y5;
}
var J5 = Sr("ChordType.chordType", "ChordType.get", Ga);
function U5() {
  return Br.map((e) => e.name).filter((e) => e);
}
function Q5() {
  return Br.map((e) => e.aliases[0]).filter((e) => e);
}
function e9() {
  return Object.keys(jn);
}
function Ms() {
  return Br.slice();
}
var t9 = Sr("ChordType.entries", "ChordType.all", Ms);
function n9() {
  Br = [], jn = {};
}
function bg(e, t, n) {
  const r = i9(e), i = {
    ...ut(e),
    name: n || "",
    quality: r,
    intervals: e,
    aliases: t
  };
  Br.push(i), i.name && (jn[i.name] = i), jn[i.setNum] = i, jn[i.chroma] = i, i.aliases.forEach((s) => r9(i, s));
}
function r9(e, t) {
  jn[t] = e;
}
function i9(e) {
  const t = (n) => e.indexOf(n) !== -1;
  return t("5A") ? "Augmented" : t("3M") ? "Major" : t("5d") ? "Diminished" : t("3m") ? "Minor" : "Unknown";
}
K5.forEach(
  ([e, t, n]) => bg(e.split(" "), n.split(" "), t)
);
Br.sort((e, t) => e.setNum - t.setNum);
var Mg = {
  names: U5,
  symbols: Q5,
  get: Ga,
  all: Ms,
  add: bg,
  removeAll: n9,
  keys: e9,
  entries: t9,
  chordType: J5
}, s9 = [
  // Basic scales
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
  // Jazz common scales
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  // Modes
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  // 5-note scales
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  // 6-note scales
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  // 7-note scales
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  // Source https://en.wikipedia.org/wiki/Ukrainian_Dorian_scale
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  // 8-note scales
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  // 9-note scales
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  // 10-note scales
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  // 12-note scales
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
], u9 = s9, a9 = {
  ...In,
  intervals: [],
  aliases: []
}, Cs = [], $n = {};
function Cg() {
  return Cs.map((e) => e.name);
}
function vs(e) {
  return $n[e] || a9;
}
var o9 = vs;
function _r() {
  return Cs.slice();
}
var c9 = _r;
function l9() {
  return Object.keys($n);
}
function f9() {
  Cs = [], $n = {};
}
function vg(e, t, n = []) {
  const r = { ...ut(e), name: t, intervals: e, aliases: n };
  return Cs.push(r), $n[r.name] = r, $n[r.setNum] = r, $n[r.chroma] = r, r.aliases.forEach((i) => h9(r, i)), r;
}
function h9(e, t) {
  $n[t] = e;
}
u9.forEach(
  ([e, t, ...n]) => vg(e.split(" "), t, n)
);
var Pg = {
  names: Cg,
  get: vs,
  all: _r,
  add: vg,
  removeAll: f9,
  keys: l9,
  // deprecated
  entries: c9,
  scaleType: o9
}, vu = {
  empty: !0,
  name: "",
  symbol: "",
  root: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function Za(e) {
  const [t, n, r, i] = As(e);
  return t === "" ? ["", e] : t === "A" && i === "ug" ? ["", "aug"] : [t + n, r + i];
}
function er(e) {
  if (e === "")
    return vu;
  if (Array.isArray(e) && e.length === 2)
    return _i(e[1], e[0]);
  {
    const [t, n] = Za(e), r = _i(n, t);
    return r.empty ? _i(e) : r;
  }
}
function _i(e, t, n) {
  const r = Ga(e), i = sn(t || ""), s = sn(n || "");
  if (r.empty || t && i.empty || n && s.empty)
    return vu;
  const u = Ra(i.pc, s.pc), a = r.intervals.indexOf(u) + 1;
  if (!s.empty && !a)
    return vu;
  const o = Array.from(r.intervals);
  for (let p = 1; p < a; p++) {
    const A = o[0][0], M = o[0][1], C = parseInt(A, 10) + 7;
    o.push(`${C}${M}`), o.shift();
  }
  const f = i.empty ? [] : o.map((p) => Ar(i, p));
  e = r.aliases.indexOf(e) !== -1 ? e : r.aliases[0];
  const h = `${i.empty ? "" : i.pc}${e}${s.empty || a <= 1 ? "" : "/" + s.pc}`, m = `${t ? i.pc + " " : ""}${r.name}${a > 1 && n ? " over " + s.pc : ""}`;
  return {
    ...r,
    name: m,
    symbol: h,
    type: r.name,
    root: s.name,
    intervals: o,
    rootDegree: a,
    tonic: i.name,
    notes: f
  };
}
var p9 = Sr("Chord.chord", "Chord.get", er);
function d9(e, t) {
  const [n, r] = Za(e);
  return n ? Ar(n, t) + r : e;
}
function m9(e) {
  const t = er(e), n = hs(t.chroma);
  return _r().filter((r) => n(r.chroma)).map((r) => r.name);
}
function g9(e) {
  const t = er(e), n = hs(t.chroma);
  return Ms().filter((r) => n(r.chroma)).map((r) => t.tonic + r.aliases[0]);
}
function y9(e) {
  const t = er(e), n = fs(t.chroma);
  return Ms().filter((r) => n(r.chroma)).map((r) => t.tonic + r.aliases[0]);
}
function A9(e) {
  const { intervals: t, tonic: n } = er(e), r = bs(t, n);
  return (i) => i ? r(i > 0 ? i - 1 : i) : "";
}
function b9(e) {
  const { intervals: t, tonic: n } = er(e);
  return bs(t, n);
}
var M9 = {
  getChord: _i,
  get: er,
  detect: x5,
  chordScales: m9,
  extended: g9,
  reduced: y9,
  tokenize: Za,
  transpose: d9,
  degrees: A9,
  steps: b9,
  chord: p9
}, C9 = [
  [
    0.125,
    "dl",
    ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
  ],
  [0.25, "l", ["long", "longa"]],
  [0.5, "d", ["double whole", "double", "breve"]],
  [1, "w", ["whole", "semibreve"]],
  [2, "h", ["half", "minim"]],
  [4, "q", ["quarter", "crotchet"]],
  [8, "e", ["eighth", "quaver"]],
  [16, "s", ["sixteenth", "semiquaver"]],
  [32, "t", ["thirty-second", "demisemiquaver"]],
  [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
  [128, "h", ["hundred twenty-eighth"]],
  [256, "th", ["two hundred fifty-sixth"]]
], v9 = C9, Ps = [];
v9.forEach(
  ([e, t, n]) => B9(e, t, n)
);
var P9 = {
  empty: !0,
  name: "",
  value: 0,
  fraction: [0, 0],
  shorthand: "",
  dots: "",
  names: []
};
function D9() {
  return Ps.reduce((e, t) => (t.names.forEach((n) => e.push(n)), e), []);
}
function F9() {
  return Ps.map((e) => e.shorthand);
}
var E9 = /^([^.]+)(\.*)$/;
function Xa(e) {
  const [t, n, r] = E9.exec(e) || [], i = Ps.find(
    (a) => a.shorthand === n || a.names.includes(n)
  );
  if (!i)
    return P9;
  const s = _9(i.fraction, r.length), u = s[0] / s[1];
  return { ...i, name: e, dots: r, value: u, fraction: s };
}
var x9 = (e) => Xa(e).value, w9 = (e) => Xa(e).fraction, S9 = { names: D9, shorthands: F9, get: Xa, value: x9, fraction: w9 };
function B9(e, t, n) {
  Ps.push({
    empty: !1,
    dots: "",
    name: "",
    value: 1 / e,
    fraction: e < 1 ? [1 / e, 1] : [1, e],
    shorthand: t,
    names: n
  });
}
function _9(e, t) {
  const n = Math.pow(2, t);
  let r = e[0] * n, i = e[1] * n;
  const s = r;
  for (let u = 0; u < t; u++)
    r += s / Math.pow(2, u + 1);
  for (; r % 2 === 0 && i % 2 === 0; )
    r /= 2, i /= 2;
  return [r, i];
}
function k9() {
  return "1P 2M 3M 4P 5P 6m 7m".split(" ");
}
var Dg = at, V9 = (e) => at(e).name, I9 = (e) => at(e).semitones, T9 = (e) => at(e).q, N9 = (e) => at(e).num;
function L9(e) {
  const t = at(e);
  return t.empty ? "" : t.simple + t.q;
}
function R9(e) {
  const t = at(e);
  if (t.empty)
    return "";
  const n = (7 - t.step) % 7, r = t.type === "perfectable" ? -t.alt : -(t.alt + 1);
  return at({ step: n, alt: r, oct: t.oct, dir: t.dir }).name;
}
var G9 = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7], Z9 = "P m M m M P d P m M m M".split(" ");
function X9(e) {
  const t = e < 0 ? -1 : 1, n = Math.abs(e), r = n % 12, i = Math.floor(n / 12);
  return t * (G9[r] + 7 * i) + Z9[r];
}
var W9 = cs, Fg = Eg((e, t) => [e[0] + t[0], e[1] + t[1]]), O9 = (e) => (t) => Fg(e, t), z9 = Eg((e, t) => [e[0] - t[0], e[1] - t[1]]);
function j9(e, t) {
  const n = Dg(e);
  if (n.empty)
    return "";
  const [r, i, s] = n.coord;
  return yi([r + t, i, s]).name;
}
var br = {
  names: k9,
  get: Dg,
  name: V9,
  num: N9,
  semitones: I9,
  quality: T9,
  fromSemitones: X9,
  distance: W9,
  invert: R9,
  simplify: L9,
  add: Fg,
  addTo: O9,
  substract: z9,
  transposeFifths: j9
};
function Eg(e) {
  return (t, n) => {
    const r = at(t).coord, i = at(n).coord;
    if (r && i) {
      const s = e(r, i);
      return yi(s).name;
    }
  };
}
function xg(e) {
  return +e >= 0 && +e <= 127;
}
function wg(e) {
  if (xg(e))
    return +e;
  const t = Fe(e);
  return t.empty ? null : t.midi;
}
function $9(e, t = 440) {
  return Math.pow(2, (e - 69) / 12) * t;
}
var q9 = Math.log(2), H9 = Math.log(440);
function Wa(e) {
  const t = 12 * (Math.log(e) - H9) / q9 + 69;
  return Math.round(t * 100) / 100;
}
var K9 = "C C# D D# E F F# G G# A A# B".split(" "), Y9 = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function Zn(e, t = {}) {
  if (isNaN(e) || e === -1 / 0 || e === 1 / 0) return "";
  e = Math.round(e);
  const r = (t.sharps === !0 ? K9 : Y9)[e % 12];
  if (t.pitchClass)
    return r;
  const i = Math.floor(e / 12) - 1;
  return r + i;
}
function Oa(e) {
  return e % 12;
}
function J9(e) {
  return e.split("").reduce((t, n, r) => (r < 12 && n === "1" && t.push(r), t), []);
}
function U9(e) {
  return e.map(Oa).sort((t, n) => t - n).filter((t, n, r) => n === 0 || t !== r[n - 1]);
}
function za(e) {
  return Array.isArray(e) ? U9(e) : J9(e);
}
function Q9(e) {
  const t = za(e);
  return (n) => {
    const r = Oa(n);
    for (let i = 0; i < 12; i++) {
      if (t.includes(r + i)) return n + i;
      if (t.includes(r - i)) return n - i;
    }
  };
}
function Sg(e, t) {
  const n = za(e), r = n.length;
  return (i) => {
    const s = i < 0 ? (r - -i % r) % r : i % r, u = Math.floor(i / r);
    return n[s] + u * 12 + t;
  };
}
function e7(e, t) {
  const n = Sg(e, t);
  return (r) => {
    if (r !== 0)
      return n(r > 0 ? r - 1 : r);
  };
}
var t7 = {
  chroma: Oa,
  freqToMidi: Wa,
  isMidi: xg,
  midiToFreq: $9,
  midiToNoteName: Zn,
  pcsetNearest: Q9,
  pcset: za,
  pcsetDegrees: e7,
  pcsetSteps: Sg,
  toMidi: wg
}, n7 = ["C", "D", "E", "F", "G", "A", "B"], Bg = (e) => e.name, _g = (e) => e.map(Fe).filter((t) => !t.empty);
function r7(e) {
  return e === void 0 ? n7.slice() : Array.isArray(e) ? _g(e).map(Bg) : [];
}
var Kt = Fe, i7 = (e) => Kt(e).name, s7 = (e) => Kt(e).pc, u7 = (e) => Kt(e).acc, a7 = (e) => Kt(e).oct, o7 = (e) => Kt(e).midi, c7 = (e) => Kt(e).freq, l7 = (e) => Kt(e).chroma;
function kg(e) {
  return Zn(e);
}
function f7(e) {
  return Zn(Wa(e));
}
function h7(e) {
  return Zn(Wa(e), { sharps: !0 });
}
function p7(e) {
  return Zn(e, { sharps: !0 });
}
var d7 = cs, jt = Ht, m7 = Ht, Vg = (e) => (t) => jt(t, e), g7 = Vg, Ig = (e) => (t) => jt(e, t), y7 = Ig;
function $i(e, t) {
  return jt(e, [t, 0]);
}
var A7 = $i;
function b7(e, t) {
  return jt(e, [0, t]);
}
var ja = (e, t) => e.height - t.height, M7 = (e, t) => t.height - e.height;
function Tg(e, t) {
  return t = t || ja, _g(e).sort(t).map(Bg);
}
function Ng(e) {
  return Tg(e, ja).filter(
    (t, n, r) => n === 0 || t !== r[n - 1]
  );
}
var C7 = (e) => {
  const t = Kt(e);
  return t.empty ? "" : Zn(t.midi || t.chroma, {
    sharps: t.alt > 0,
    pitchClass: t.midi === null
  });
};
function Lg(e, t) {
  const n = Kt(e);
  if (n.empty)
    return "";
  const r = Kt(
    t || Zn(n.midi || n.chroma, {
      sharps: n.alt < 0,
      pitchClass: !0
    })
  );
  if (r.empty || r.chroma !== n.chroma)
    return "";
  if (n.oct === void 0)
    return r.pc;
  const i = n.chroma - n.alt, s = r.chroma - r.alt, u = i > 11 || s < 0 ? -1 : i < 0 || s > 11 ? 1 : 0, a = n.oct + u;
  return r.pc + a;
}
var Tn = {
  names: r7,
  get: Kt,
  name: i7,
  pitchClass: s7,
  accidentals: u7,
  octave: a7,
  midi: o7,
  ascending: ja,
  descending: M7,
  distance: d7,
  sortedNames: Tg,
  sortedUniqNames: Ng,
  fromMidi: kg,
  fromMidiSharps: p7,
  freq: c7,
  fromFreq: f7,
  fromFreqSharps: h7,
  chroma: l7,
  transpose: jt,
  tr: m7,
  transposeBy: Vg,
  trBy: g7,
  transposeFrom: Ig,
  trFrom: y7,
  transposeFifths: $i,
  transposeOctaves: b7,
  trFifths: A7,
  simplify: C7,
  enharmonic: Lg
}, Rg = { empty: !0, name: "", chordType: "" }, cc = {};
function Nn(e) {
  return typeof e == "string" ? cc[e] || (cc[e] = w7(e)) : typeof e == "number" ? Nn(Ds[e] || "") : Da(e) ? D7(e) : Pa(e) ? Nn(e.name) : Rg;
}
var v7 = Nn;
function P7(e = !0) {
  return (e ? Ds : x7).slice();
}
function D7(e) {
  return Nn(os(e.alt) + Ds[e.step]);
}
var F7 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
function E7(e) {
  return F7.exec(e) || ["", "", "", ""];
}
var Gg = "I II III IV V VI VII", Ds = Gg.split(" "), x7 = Gg.toLowerCase().split(" ");
function w7(e) {
  const [t, n, r, i] = E7(e);
  if (!r)
    return Rg;
  const s = r.toUpperCase(), u = Ds.indexOf(s), a = Fa(n), o = 1;
  return {
    empty: !1,
    name: t,
    roman: r,
    interval: rn({ step: u, alt: a, dir: o }).name,
    acc: n,
    chordType: i,
    alt: a,
    step: u,
    major: r === s,
    oct: 0,
    dir: o
  };
}
var S7 = {
  names: P7,
  get: Nn,
  // deprecated
  romanNumeral: v7
}, st = Object.freeze([]), Zg = {
  type: "major",
  tonic: "",
  alteration: 0,
  keySignature: ""
}, ki = {
  tonic: "",
  grades: st,
  intervals: st,
  scale: st,
  triads: st,
  chords: st,
  chordsHarmonicFunction: st,
  chordScales: st,
  secondaryDominants: st,
  secondaryDominantSupertonics: st,
  substituteDominantsMinorRelative: st,
  substituteDominants: st,
  substituteDominantSupertonics: st,
  secondaryDominantsMinorRelative: st
}, B7 = {
  ...Zg,
  ...ki,
  type: "major",
  minorRelative: "",
  scale: st,
  substituteDominants: st,
  secondaryDominantSupertonics: st,
  substituteDominantsMinorRelative: st
}, _7 = {
  ...Zg,
  type: "minor",
  relativeMajor: "",
  natural: ki,
  harmonic: ki,
  melodic: ki
}, tu = (e, t, n = "") => t.map((r, i) => `${e[i]}${n}${r}`);
function Fs(e, t, n, r, i) {
  return (s) => {
    const u = e.map((A) => Nn(A).interval || ""), a = u.map((A) => jt(s, A)), o = tu(a, n), f = a.map((A) => jt(A, "5P")).map(
      (A) => (
        // A secondary dominant is a V chord which:
        // 1. is not diatonic to the key,
        // 2. it must have a diatonic root.
        a.includes(A) && !o.includes(A + "7") ? A + "7" : ""
      )
    ), h = lc(
      f,
      t
    ), m = f.map((A) => {
      if (!A) return "";
      const M = A.slice(0, -1);
      return jt(M, "5d") + "7";
    }), p = lc(
      m,
      t
    );
    return {
      tonic: s,
      grades: e,
      intervals: u,
      scale: a,
      triads: tu(a, t),
      chords: o,
      chordsHarmonicFunction: r.slice(),
      chordScales: tu(a, i, " "),
      secondaryDominants: f,
      secondaryDominantSupertonics: h,
      substituteDominants: m,
      substituteDominantSupertonics: p,
      // @deprecated use secondaryDominantsSupertonic
      secondaryDominantsMinorRelative: h,
      // @deprecated use secondaryDominantsSupertonic
      substituteDominantsMinorRelative: p
    };
  };
}
var lc = (e, t) => e.map((n, r) => {
  if (!n) return "";
  const i = n.slice(0, -1), s = jt(i, "5P");
  return t[r].endsWith("m") ? s + "m7" : s + "m7b5";
}), Xg = (e, t) => {
  const n = Fe(e), r = Fe(t);
  return n.empty || r.empty ? 0 : r.coord[0] - n.coord[0];
}, k7 = Fs(
  "I II III IV V VI VII".split(" "),
  " m m   m dim".split(" "),
  "maj7 m7 m7 maj7 7 m7 m7b5".split(" "),
  "T SD T SD D T D".split(" "),
  "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(",")
), V7 = Fs(
  "I II bIII IV V bVI bVII".split(" "),
  "m dim  m m  ".split(" "),
  "m7 m7b5 maj7 m7 m7 maj7 7".split(" "),
  "T SD T SD D SD SD".split(" "),
  "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(",")
), I7 = Fs(
  "I II bIII IV V bVI VII".split(" "),
  "m dim aug m   dim".split(" "),
  "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "),
  "T SD T SD D SD D".split(" "),
  "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(
    ","
  )
), T7 = Fs(
  "I II bIII IV V VI VII".split(" "),
  "m m aug   dim dim".split(" "),
  "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "),
  "T SD T SD D  ".split(" "),
  "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(
    ","
  )
);
function N7(e) {
  const t = Fe(e).pc;
  if (!t) return B7;
  const n = k7(t), r = Xg("C", t);
  return {
    ...n,
    type: "major",
    minorRelative: jt(t, "-3m"),
    alteration: r,
    keySignature: os(r)
  };
}
function L7(e) {
  const t = Fe(e).pc;
  if (!t) return _7;
  const n = Xg("C", t) - 3;
  return {
    type: "minor",
    tonic: t,
    relativeMajor: jt(t, "3m"),
    alteration: n,
    keySignature: os(n),
    natural: V7(t),
    harmonic: I7(t),
    melodic: T7(t)
  };
}
function R7(e) {
  return typeof e == "number" ? $i("C", e) : typeof e == "string" && /^b+|#+$/.test(e) ? $i("C", Fa(e)) : null;
}
var G7 = { majorKey: N7, majorTonicFromKeySignature: R7, minorKey: L7 }, Z7 = rn;
function X7(e) {
  const t = rn(e);
  return t.empty ? "" : t.simple + t.q;
}
function W7(e, t) {
  const n = Z7(e);
  if (n.empty) return "";
  const [r, i, s] = n.coord;
  return Jm([r + t, i, s]).name;
}
var $a = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
], fc = {
  ...In,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
}, qa = $a.map($7), Pu = {};
qa.forEach((e) => {
  Pu[e.name] = e, e.aliases.forEach((t) => {
    Pu[t] = e;
  });
});
function Jn(e) {
  return typeof e == "string" ? Pu[e.toLowerCase()] || fc : e && e.name ? Jn(e.name) : fc;
}
var O7 = Jn;
function Wg() {
  return qa.slice();
}
var z7 = Wg;
function j7() {
  return qa.map((e) => e.name);
}
function $7(e) {
  const [t, n, r, i, s, u, a] = e, o = a ? [a] : [], f = Number(n).toString(2);
  return {
    empty: !1,
    intervals: vs(i).intervals,
    modeNum: t,
    chroma: f,
    normalized: f,
    name: i,
    setNum: n,
    alt: r,
    triad: s,
    seventh: u,
    aliases: o
  };
}
function q7(e, t) {
  return Jn(e).intervals.map((n) => Ht(t, n));
}
function Og(e) {
  return (t, n) => {
    const r = Jn(t);
    if (r.empty) return [];
    const i = wr(r.modeNum, e), s = r.intervals.map((u) => Ht(n, u));
    return i.map((u, a) => s[a] + u);
  };
}
var H7 = Og($a.map((e) => e[4])), K7 = Og($a.map((e) => e[5]));
function zg(e, t) {
  const n = Jn(t), r = Jn(e);
  return n.empty || r.empty ? "" : X7(W7("1P", r.alt - n.alt));
}
function Y7(e, t, n) {
  return Ht(n, zg(e, t));
}
var J7 = {
  get: Jn,
  names: j7,
  all: Wg,
  distance: zg,
  relativeTonic: Y7,
  notes: q7,
  triads: H7,
  seventhChords: K7,
  // deprecated
  entries: z7,
  mode: O7
};
function U7(e) {
  const [t, n, r, i] = Ea(e);
  return t === "" ? nu("", e) : t === "A" && i === "ug" ? nu("", "aug") : nu(t + n, r + i);
}
function nu(e, t) {
  const n = t.split("/");
  if (n.length === 1)
    return [e, n[0], ""];
  const [r, i, s, u] = Ea(n[1]);
  return r !== "" && s === "" && u === "" ? [e, n[0], r + i] : [e, t, ""];
}
function Q7(e, t) {
  return t.map(Nn).map(
    (r) => Ht(e, rn(r)) + r.chordType
  );
}
function eF(e, t) {
  return t.map((n) => {
    const [r, i] = U7(n), s = cs(e, r);
    return Nn(rn(s)).name + i;
  });
}
var tF = { fromRomanNumerals: Q7, toRomanNumerals: eF };
function jg(e) {
  const t = xa(
    e.map((n) => typeof n == "number" ? n : wg(n))
  );
  return !e.length || t.length !== e.length ? [] : t.reduce(
    (n, r) => {
      const i = n[n.length - 1];
      return n.concat(ls(i, r).slice(1));
    },
    [t[0]]
  );
}
function nF(e, t) {
  return jg(e).map((n) => Zn(n, t));
}
var rF = { numeric: jg, chromatic: nF }, iF = {
  empty: !0,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function $g(e) {
  if (typeof e != "string")
    return ["", ""];
  const t = e.indexOf(" "), n = Fe(e.substring(0, t));
  if (n.empty) {
    const i = Fe(e);
    return i.empty ? ["", e] : [i.name, ""];
  }
  const r = e.substring(n.name.length + 1).toLowerCase();
  return [n.name, r.length ? r : ""];
}
var sF = Cg;
function un(e) {
  const t = Array.isArray(e) ? e : $g(e), n = Fe(t[0]).name, r = vs(t[1]);
  if (r.empty)
    return iF;
  const i = r.name, s = n ? r.intervals.map((a) => Ht(n, a)) : [], u = n ? n + " " + i : i;
  return { ...r, name: u, type: i, tonic: n, notes: s };
}
var uF = un;
function aF(e, t = {}) {
  const n = sg(e), r = Fe(t.tonic ?? e[0] ?? ""), i = r.chroma;
  if (i === void 0)
    return [];
  const s = n.split("");
  s[i] = "1";
  const u = wr(i, s).join(""), a = _r().find((f) => f.chroma === u), o = [];
  return a && o.push(r.name + " " + a.name), t.match === "exact" || qg(u).forEach((f) => {
    o.push(r.name + " " + f);
  }), o;
}
function oF(e) {
  const t = un(e), n = fs(t.chroma);
  return og().filter((r) => n(r.chroma)).map((r) => r.aliases[0]);
}
function qg(e) {
  const t = Sa(e) ? e : un(e).chroma, n = hs(t);
  return _r().filter((r) => n(r.chroma)).map((r) => r.name);
}
function cF(e) {
  const t = fs(un(e).chroma);
  return _r().filter((n) => t(n.chroma)).map((n) => n.name);
}
function Hg(e) {
  const t = e.map((i) => Fe(i).pc).filter((i) => i), n = t[0], r = Ng(t);
  return wr(r.indexOf(n), r);
}
function lF(e) {
  const t = un(e);
  if (t.empty)
    return [];
  const n = t.tonic ? t.notes : t.intervals;
  return Ba(t.chroma).map((r, i) => {
    const s = un(r).name;
    return s ? [n[i], s] : ["", ""];
  }).filter((r) => r[0]);
}
function fF(e) {
  const t = Array.isArray(e) ? Hg(e) : un(e).notes, n = t.map((r) => Fe(r).chroma);
  return (r) => {
    const i = Fe(typeof r == "number" ? kg(r) : r), s = i.height;
    if (s === void 0) return;
    const u = s % 12, a = n.indexOf(u);
    if (a !== -1)
      return Lg(i.name, t[a]);
  };
}
function hF(e) {
  const t = fF(e);
  return (n, r) => {
    const i = Fe(n).height, s = Fe(r).height;
    return i === void 0 || s === void 0 ? [] : ls(i, s).map(t).filter((u) => u);
  };
}
function pF(e) {
  const { intervals: t, tonic: n } = un(e), r = Qm(t, n);
  return (i) => i ? r(i > 0 ? i - 1 : i) : "";
}
function dF(e) {
  const { intervals: t, tonic: n } = un(e);
  return Qm(t, n);
}
var Mr = {
  degrees: pF,
  detect: aF,
  extended: qg,
  get: un,
  modeNames: lF,
  names: sF,
  rangeOf: hF,
  reduced: cF,
  scaleChords: oF,
  scaleNotes: Hg,
  steps: dF,
  tokenize: $g,
  // deprecated
  scale: uF
}, mF = {
  empty: !0,
  name: "",
  upper: void 0,
  lower: void 0,
  type: void 0,
  additive: []
}, gF = ["4/4", "3/4", "2/4", "2/2", "12/8", "9/8", "6/8", "3/8"];
function yF() {
  return gF.slice();
}
var AF = /^(\d*\d(?:\+\d)*)\/(\d+)$/, hc = /* @__PURE__ */ new Map();
function bF(e) {
  const t = JSON.stringify(e), n = hc.get(t);
  if (n)
    return n;
  const r = vF(Ha(e));
  return hc.set(t, r), r;
}
function Ha(e) {
  if (typeof e == "string") {
    const [s, u, a] = AF.exec(e) || [];
    return Ha([u, a]);
  }
  const [t, n] = e, r = +n;
  if (typeof t == "number")
    return [t, r];
  const i = t.split("+").map((s) => +s);
  return i.length === 1 ? [i[0], r] : [i, r];
}
var MF = { names: yF, parse: Ha, get: bF }, CF = (e) => Math.log(e) / Math.log(2) % 1 === 0;
function vF([e, t]) {
  const n = Array.isArray(e) ? e.reduce((a, o) => a + o, 0) : e, r = t;
  if (n === 0 || r === 0)
    return mF;
  const i = Array.isArray(e) ? `${e.join("+")}/${t}` : `${e}/${t}`, s = Array.isArray(e) ? e : [], u = r === 4 || r === 2 ? "simple" : r === 8 && n % 3 === 0 ? "compound" : CF(r) ? "irregular" : "irrational";
  return {
    empty: !1,
    name: i,
    type: u,
    upper: n,
    lower: r,
    additive: s
  };
}
var PF = Ag, DF = ag, FF = Mg, EF = Pg;
const xF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbcNotation: qD,
  Array: t5,
  Chord: M9,
  ChordDictionary: FF,
  ChordType: Mg,
  Collection: s5,
  Core: Ag,
  DurationValue: S9,
  Interval: br,
  Key: G7,
  Midi: t7,
  Mode: J7,
  Note: Tn,
  PcSet: DF,
  Pcset: ag,
  Progression: tF,
  Range: rF,
  RomanNumeral: S7,
  Scale: Mr,
  ScaleDictionary: EF,
  ScaleType: Pg,
  TimeSignature: MF,
  Tonal: PF,
  accToAlt: Na,
  altToAcc: Ta,
  chroma: lg,
  coordToInterval: yi,
  coordToNote: La,
  coordinates: gs,
  deprecate: Sr,
  distance: Ra,
  fillStr: gg,
  height: ka,
  interval: at,
  isNamed: yg,
  isNamedPitch: gi,
  isPitch: ms,
  midi: fg,
  note: sn,
  pitch: ys,
  stepToLetter: Ia,
  tokenizeInterval: Va,
  tokenizeNote: As,
  tonicIntervalsTransposer: bs,
  transpose: Ar
}, Symbol.toStringTag, { value: "Module" })), wF = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], SF = ["c", "db", "d", "eb", "e", "f", "gb", "g", "ab", "a", "bb", "b"], BF = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], _F = { b: -1, "#": 1 }, kF = (e) => {
  const [t, ...n] = e.split("");
  return SF.indexOf(t.toLowerCase()) + n.reduce((r, i) => r + _F[i], 0);
};
function VF(e) {
  const t = (e || "").match(/^([A-G][b#]*)([^/]*)[/]?([A-G][b#]*)?$/);
  return t ? t.slice(1) : [];
}
const Du = (e) => e % 12, Kg = (e) => {
  let t = Number(e);
  return isNaN(t) ? br.semitones(e) : t;
}, Fu = (e, t) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string")
    return Ln(e, t);
}, IF = (e, t = !1) => {
  const n = Math.floor(e / 12) - 1;
  return (t ? BF : wF)[e % 12] + n;
};
function TF(e, t, n = 1) {
  e = e.map((i) => typeof i == "string" ? Ln(i) : i);
  const r = Math.floor(t / e.length) * n * 12;
  return t = kt(t, e.length), e[t] + r;
}
function NF(e, t, n) {
  let r = 0, i = 1 / 0;
  return t.forEach((s, u) => {
    const a = Math.abs(s - e);
    (a < i || n) && (r = u, i = a);
  }), r;
}
let ru = {};
function LF(e, t, n, r) {
  let [i, s] = Mr.tokenize(t);
  const u = Fu(i), a = Du(u);
  if (!ru[s]) {
    let { intervals: p } = Mr.get(`C ${s}`);
    ru[s] = p.map(Kg);
  }
  const o = ru[s];
  if (!o)
    return null;
  let f = u;
  if (n) {
    n = Fu(n, 3);
    const p = Du(n), A = kt(p - a, 12), M = NF(A, o, r);
    e = e + M, f = n - A;
  }
  const h = Math.floor(e / o.length) * 12;
  return e = kt(e, o.length), o[e] + f + h;
}
let pc = {
  below: (e) => e.slice(-1)[0],
  duck: (e) => e.slice(-1)[0],
  above: (e) => e[0],
  root: (e) => e[0]
};
function RF({ chord: e, dictionary: t, offset: n = 0, n: r, mode: i = "below", anchor: s = "c5", octaves: u = 1 }) {
  const [a, o] = VF(e), f = kF(a);
  s = Fu(s?.note || s, 4);
  const h = Du(s), m = t[o].map(
    (B) => (typeof B == "string" ? B.split(" ") : B).map(Kg)
  );
  let p, A, M = m.map((B, V) => {
    const T = pc[i](B), H = kt(h - T - f, 12);
    return (p === void 0 || H < p) && (p = H, A = V), H;
  });
  i === "root" && (A = 0);
  const C = Math.ceil(n / m.length) * 12, F = kt(A + n, m.length), _ = m[F], k = pc[i](_), L = s - M[F] + C, S = _.map((B) => L - k + B);
  let x = S.map((B) => IF(B));
  return i === "duck" && (x = x.filter((B, V) => S[V] !== s)), r !== void 0 ? [TF(x, r, u)] : x;
}
const GF = (e) => (e <= 0 ? -1 : 1) + e * 7 + "P";
function ZF(e, t) {
  t = t.replaceAll(":", " "), e = Math.ceil(e);
  let { intervals: n, tonic: r, empty: i } = Mr.get(t);
  if (i && Un(t) || i && !r)
    throw new Error('incomplete scale. Make sure to use ":" instead of spaces, example: .scale("C:major")');
  if (i)
    throw new Error(`invalid scale "${t}"`);
  r = r || "C";
  const { pc: s, oct: u = 3 } = Tn.get(r), a = Math.floor(e / n.length), o = kt(e, n.length), f = br.add(n[o], GF(a));
  return Tn.transpose(s + u, f);
}
function dc(e, t, n) {
  let [r, i] = Mr.tokenize(e), { notes: s } = Mr.get(`${r} ${i}`);
  if (s = s.map((A) => Tn.get(A).pc), t = Number(t), isNaN(t))
    throw new Error(`scale offset "${t}" not a number`);
  const { pc: u, oct: a = 3 } = Tn.get(n), o = s.indexOf(u);
  if (o === -1)
    throw new Error(`note "${n}" is not in scale "${e}"`);
  let f = o, h = a, m = u;
  const p = Math.sign(t);
  for (; Math.abs(f - o) < Math.abs(t); ) {
    f += p;
    const A = kt(f, s.length);
    p < 0 && m[0] === "C" && (h += p), m = s[A], p > 0 && m[0] === "C" && (h += p);
  }
  return m + h;
}
const { transpose: XF, trans: WF } = N(["transpose", "trans"], function(t, n) {
  return n.withHap((r) => {
    const i = r.value.note ?? r.value;
    if (typeof i == "number") {
      let a;
      typeof t == "number" ? a = t : typeof t == "string" && (a = br.semitones(t) || 0);
      const o = i + a;
      return typeof r.value == "object" ? r.withValue(() => ({ ...r.value, note: o })) : r.withValue(() => o);
    }
    if (typeof i != "string" || !Un(i))
      return Ue(`[tonal] transpose: not a note "${i}"`, "warning"), r;
    const s = isNaN(Number(t)) ? String(t) : br.fromSemitones(t), u = Tn.simplify(Tn.transpose(i, s));
    return typeof r.value == "object" ? r.withValue(() => ({ ...r.value, note: u })) : r.withValue(() => u);
  });
}), { scaleTranspose: OF, scaleTrans: zF, strans: jF } = N(
  ["scaleTranspose", "scaleTrans", "strans"],
  function(e, t) {
    return t.withHap((n) => {
      if (!n.context.scale)
        throw new Error("can only use scaleTranspose after .scale");
      if (typeof n.value == "object")
        return n.withValue(() => ({
          ...n.value,
          note: dc(n.context.scale, Number(e), n.value.note)
        }));
      if (typeof n.value != "string")
        throw new Error("can only use scaleTranspose with notes");
      return n.withValue(() => dc(n.context.scale, Number(e), n.value));
    });
  }
), $F = N(
  "scale",
  function(e, t) {
    return Array.isArray(e) && (e = e.flat().join(" ")), t.fmap((n) => {
      const r = typeof n == "object";
      let i = r ? n.n : n;
      if (r && delete n.n, Un(i))
        return Je(i);
      let s = Number(i), u = 0;
      if (isNaN(s)) {
        if (i = String(i), !/^[-+]?\d+(#*|b*){1}$/.test(i))
          return Ue(
            `[tonal] invalid scale step "${i}", expected number or integer with optional # b suffixes`,
            "error"
          ), Se;
        const a = i.indexOf("#");
        if (a >= 0)
          s = Number(i.substring(0, a)), u = i.length - a;
        else {
          const o = i.indexOf("b");
          s = Number(i.substring(0, o)), u = o - i.length;
        }
      }
      try {
        let a;
        r && n.anchor ? a = LF(s, e, n.anchor) : a = ZF(s, e), u != 0 && (a = Tn.transpose(a, br.fromSemitones(u))), n = Je(r ? { ...n, note: a } : a);
      } catch (a) {
        Ue(`[tonal] ${a.message}`, "error"), n = Se;
      }
      return n;
    }).outerJoin().withHap((n) => n.setContext({ ...n.context, scale: e }));
  },
  !0,
  !0
  // preserve step count
);
var iu = {}, zr = {}, jr = {}, mc;
function Yg() {
  if (mc) return jr;
  mc = 1, jr.__esModule = !0, jr.getBestVoicing = void 0;
  function e(t) {
    var n = t.chord, r = t.range, i = t.finder, s = t.picker, u = t.lastVoicing, a = i(n, r);
    return a.length ? s(a, u) : [];
  }
  return jr.getBestVoicing = e, jr;
}
var $r = {};
const Jg = /* @__PURE__ */ _P(xF);
var qr = {}, gc;
function Ug() {
  if (gc) return qr;
  gc = 1, qr.__esModule = !0, qr.tokenizeChord = void 0;
  function e(t) {
    var n = (t || "").match(/^([A-G][b#]*)([^\/]*)[\/]?([A-G][b#]*)?$/);
    return n ? n.slice(1) : [];
  }
  return qr.tokenizeChord = e, qr;
}
var yc;
function qF() {
  if (yc) return $r;
  yc = 1, $r.__esModule = !0, $r.voicingsInRange = void 0;
  var e = Jg, t = Qg(), n = Ug();
  function r(i, s, u) {
    s === void 0 && (s = t.lefthand), u === void 0 && (u = ["D3", "A4"]);
    var a = (0, n.tokenizeChord)(i), o = a[0], f = a[1];
    if (!s[f])
      return [];
    var h = s[f].map(function(p) {
      return p.split(" ");
    }), m = e.Range.chromatic(u);
    return h.reduce(function(p, A) {
      var M = A.map(function(k) {
        return e.Interval.substract(k, A[0]);
      }), C = e.Note.transpose(o, A[0]), F = m.filter(function(k) {
        return e.Note.chroma(k) === e.Note.chroma(C);
      }).filter(function(k) {
        return e.Note.midi(e.Note.transpose(k, M[M.length - 1])) <= e.Note.midi(u[1]);
      }).map(function(k) {
        return e.Note.enharmonic(k, C);
      }), _ = F.map(function(k) {
        return M.map(function(L) {
          return e.Note.transpose(k, L);
        });
      });
      return p.concat(_);
    }, []);
  }
  return $r.voicingsInRange = r, $r;
}
var Ac;
function Qg() {
  return Ac || (Ac = 1, function(e) {
    var t = zr.__assign || function() {
      return t = Object.assign || function(a) {
        for (var o, f = 1, h = arguments.length; f < h; f++) {
          o = arguments[f];
          for (var m in o) Object.prototype.hasOwnProperty.call(o, m) && (a[m] = o[m]);
        }
        return a;
      }, t.apply(this, arguments);
    }, n = zr.__rest || function(a, o) {
      var f = {};
      for (var h in a) Object.prototype.hasOwnProperty.call(a, h) && o.indexOf(h) < 0 && (f[h] = a[h]);
      if (a != null && typeof Object.getOwnPropertySymbols == "function")
        for (var m = 0, h = Object.getOwnPropertySymbols(a); m < h.length; m++)
          o.indexOf(h[m]) < 0 && Object.prototype.propertyIsEnumerable.call(a, h[m]) && (f[h[m]] = a[h[m]]);
      return f;
    };
    e.__esModule = !0, e.dictionaryVoicing = e.dictionaryVoicingFinder = e.triads = e.guidetones = e.lefthand = void 0;
    var r = Yg(), i = qF();
    e.lefthand = {
      m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
      7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
      "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
      69: ["3M 5P 6A 9M"],
      m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
      "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
      "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
      o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
      "7#11": ["7m 9M 11A 13A"],
      "7#9": ["3M 7m 9A"],
      mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
      m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
    }, e.guidetones = {
      m7: ["3m 7m", "7m 10m"],
      m9: ["3m 7m", "7m 10m"],
      7: ["3M 7m", "7m 10M"],
      "^7": ["3M 7M", "7M 10M"],
      "^9": ["3M 7M", "7M 10M"],
      69: ["3M 6M"],
      6: ["3M 6M", "6M 10M"],
      m7b5: ["3m 7m", "7m 10m"],
      "7b9": ["3M 7m", "7m 10M"],
      "7b13": ["3M 7m", "7m 10M"],
      o7: ["3m 6M", "6M 10m"],
      "7#11": ["3M 7m", "7m 10M"],
      "7#9": ["3M 7m", "7m 10M"],
      mM7: ["3m 7M", "7M 10m"],
      m6: ["3m 6M", "6M 10m"]
    }, e.triads = {
      M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
      m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
      o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
      aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"]
    };
    var s = function(a) {
      return function(o, f) {
        return (0, i.voicingsInRange)(o, a, f);
      };
    };
    e.dictionaryVoicingFinder = s;
    var u = function(a) {
      var o = a.dictionary, f = a.range, h = n(a, ["dictionary", "range"]);
      return (0, r.getBestVoicing)(t(t({}, h), { range: f, finder: (0, e.dictionaryVoicingFinder)(o) }));
    };
    e.dictionaryVoicing = u;
  }(zr)), zr;
}
var Hr = {}, bc;
function HF() {
  if (bc) return Hr;
  bc = 1, Hr.__esModule = !0, Hr.minTopNoteDiff = void 0;
  var e = Jg;
  function t(n, r) {
    if (!r)
      return n[0];
    var i = function(s) {
      return Math.abs(e.Note.midi(r[r.length - 1]) - e.Note.midi(s[s.length - 1]));
    };
    return n.reduce(function(s, u) {
      return i(u) < i(s) ? u : s;
    }, n[0]);
  }
  return Hr.minTopNoteDiff = t, Hr;
}
var Mc;
function KF() {
  return Mc || (Mc = 1, function(e) {
    e.__esModule = !0;
    var t = Qg(), n = HF(), r = Yg(), i = Ug();
    e.default = {
      tokenizeChord: i.tokenizeChord,
      getBestVoicing: r.getBestVoicing,
      dictionaryVoicing: t.dictionaryVoicing,
      dictionaryVoicingFinder: t.dictionaryVoicingFinder,
      lefthand: t.lefthand,
      guidetones: t.guidetones,
      triads: t.triads,
      minTopNoteDiff: n.minTopNoteDiff
    };
  }(iu)), iu;
}
var YF = KF();
const Cc = /* @__PURE__ */ Zm(YF), pr = {
  2: ["1P 5P 8P 9M", "1P 5P 8P 9M 12P", "5P 8P 9M 12P"],
  5: ["1P 5P 8P 12P", "5P 8P 12P 15P"],
  6: ["1P 5P 6M 8P 10M", "1P 5P 8P 10M 13M", "3M 5P 8P 10M 13M", "5P 8P 10M 12P 13M"],
  7: [
    "1P 5P 7m 8P 10M",
    "1P 7m 8P 10M 12P",
    "3M 7m 8P 10M 12P",
    "3M 7m 8P 10M 14m",
    "3M 7m 10M 12P 15P",
    "7m 10M 12P 14m 15P",
    "7m 10M 12P 15P 17M"
  ],
  9: [
    "1P 5P 7m 9M 10M",
    "1P 7m 9M 10M 12P",
    "3M 7m 8P 9M 12P",
    "7m 9M 10M 14m 15P",
    "3M 7m 8P 12P 16M",
    "7m 10M 12P 15P 16M"
  ],
  11: ["1P 5P 7m 9M 11P", "5P 7m 8P 9M 11P", "7m 8P 9M 11P 12P", "7m 8P 11P 12P 16M"],
  13: ["1P 6M 7m 9M 10M", "1P 7m 9M 10M 13M", "3M 7m 8P 9M 13M", "7m 8P 9M 10M 13M", "7m 9M 10M 13M 15P"],
  69: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 8P 9M 13M", "5P 8P 9M 10M 13M"],
  add9: ["1P 5P 8P 9M 10M", "1P 5P 9M 10M 12P", "3M 8P 9M 10M 12P", "3M 8P 9M 12P 15P", "5P 8P 9M 12P 17M"],
  "+": [
    "1P 3M 6m 8P 10M",
    "1P 6m 8P 10M 13m",
    "3M 6m 8P 10M 13m",
    "3M 8P 10M 13m 15P",
    "6m 8P 10M 13m 15P",
    "6m 10M 13m 15P 17M"
  ],
  o: ["1P 5d 8P 10m 12d", "3m 8P 10m 12d 15P", "5d 8P 10m 12d 15P"],
  h: [
    "3m 5d 7m 8P 10m",
    "1P 5d 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  sus: ["1P 4P 5P 8P", "1P 4P 5P 8P 11P", "5P 8P 11P 12P", "5P 8P 11P 12P 15P"],
  "^": ["1P 5P 8P 10M", "1P 5P 8P 10M 12P", "3M 5P 8P 10M 12P", "3M 8P 10M 12P 15P", "5P 8P 10M 12P 15P"],
  "-": ["1P 3m 5P 8P 10m", "1P 5P 8P 10m 12P", "3m 5P 8P 10m 12P", "5P 8P 10m 12P 15P"],
  "^7": ["1P 5P 7M 10M 12P", "1P 10M 12P 14M", "3M 8P 10M 12P 14M", "5P 8P 10M 12P 14M", "5P 8P 10M 14M 17M"],
  "-7": [
    "1P 3m 5P 7m 10m",
    "1P 5P 7m 10m 12P",
    "3m 7m 8P 10m 12P",
    "3m 7m 8P 10m 14m",
    "5P 7m 8P 10m 14m",
    "7m 10m 12P 14m 15P",
    "5P 8P 10m 14m 17m",
    "7m 10m 12P 15P 17m"
  ],
  "7sus": ["1P 5P 7m 8P 11P", "5P 8P 11P 12P 14m", "7m 8P 11P 12P 14m", "7m 11P 12P 14m 18P"],
  h7: [
    "3m 5d 7m 8P 10m",
    "1P 5d 7m 10m 12d",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  o7: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  "^9": [
    "1P 5P 7M 9M 10M",
    "1P 7M 9M 10M 12P",
    "3M 7M 8P 9M 12P",
    "3M 7M 8P 12P 16M",
    "5P 8P 10M 14M 16M",
    "7M 8P 10M 12P 16M"
  ],
  "^13": ["1P 6M 7M 9M 10M", "1P 7M 9M 10M 13M", "3M 7M 8P 9M 13M", "3M 7M 8P 13M 16M", "7M 8P 10M 13M 16M"],
  "^7#11": ["1P 5P 7M 10M 12d", "3M 7M 8P 10M 12d", "1P 7M 10M 12d 14M", "3M 7M 8P 12d 14M", "5P 8P 10M 12d 14M"],
  "^9#11": ["1P 3M 5d 7M 9M", "1P 7M 9M 10M 12d", "3M 7M 8P 9M 12d", "3M 8P 9M 12d 14M"],
  "^7#5": ["1P 6m 7M 10M 13m", "3M 7M 8P 10M 13m", "6m 7M 8P 10M 13m"],
  "-6": [
    "1P 3m 5P 6M 8P",
    "1P 5P 6M 8P 10m",
    "3m 5P 6M 8P 10m",
    "1P 5P 8P 10m 13M",
    "3m 5P 8P 10m 13M",
    "5P 8P 10m 12P 13M",
    "5P 8P 10m 13M 15P"
  ],
  "-69": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "3m 6M 9M 10m 12P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 9M 10m 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-^7": ["1P 3m 5P 7M 10m", "1P 5P 7M 10m 12P", "3m 7M 8P 10m 12P", "5P 7M 8P 10m 14M", "5P 8P 10m 14M 17m"],
  "-^9": ["1P 3m 5P 7M 9M", "1P 7M 9M 10m 12P", "3m 7M 8P 9M 12P", "5P 8P 9M 10m 14M"],
  "-9": [
    "1P 3m 5P 7m 9M",
    "3m 5P 7m 8P 9M",
    "3m 7m 8P 9M 12P",
    "5P 8P 9M 10m 14m",
    "3m 7m 9M 12P 15P",
    "7m 10m 12P 15P 16M"
  ],
  "-add9": ["1P 2M 3m 5P 8P", "1P 3m 5P 9M", "3m 5P 8P 9M 12P", "5P 8P 9M 10m 12P"],
  "-11": [
    "1P 3m 7m 9M 11P",
    "3m 7m 8P 9M 11P",
    "1P 4P 7m 10m 12P",
    "5P 8P 11P 14m",
    "3m 7m 9M 11P 15P",
    "5P 8P 11P 14m 16M",
    "7m 10m 12P 15P 18P"
  ],
  "-7b5": [
    "3m 5d 7m 8P 10m",
    "1P 7m 10m 12d",
    "1P 5d 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  h9: ["1P 7m 9M 10m 12d", "3m 7m 8P 9M 12d", "5d 8P 9M 10m 14m", "7m 10m 12d 15P 16M"],
  "-b6": ["1P 5P 6m 8P 10m", "1P 5P 8P 10m 13m", "3m 5P 8P 10m 13m", "5P 8P 10m 13m", "5P 8P 10m 13m 15P"],
  "-#5": ["1P 6m 8P 10m 13m", "3m 6m 8P 10m 13m", "6m 8P 10m 13m 15P"],
  "7b9": ["1P 3M 7m 9m 10M", "3M 7m 8P 9m 10M", "3M 7m 8P 9m 14m", "7m 9m 10M 14m 15P"],
  "7#9": ["1P 3M 7m 10m", "3M 7m 8P 10m 14m", "7m 10m 10M 14m 15P"],
  "7#11": ["1P 3M 7m 10M 12d", "3M 7m 8P 10M 12d", "7m 10M 12d 14m 15P"],
  "7b5": ["1P 3M 7m 10M 12d", "3M 7m 8P 10M 12d", "7m 10M 12d 14m 15P"],
  "7#5": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P"],
  "9#11": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9b5": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9#5": ["1P 7m 9M 10M 13m", "3M 7m 9M 10M 13m", "3M 7m 9M 13m 14m", "7m 10M 13m 14m 16M", "7m 10M 13m 16M 17M"],
  "7b13": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P"],
  "7#9#5": ["1P 3M 7m 10m 13m", "3M 7m 10m 13m 15P", "7m 10M 13m 15P 17m"],
  "7#9b5": ["1P 3M 7m 10m 12d", "3M 7m 10m 12d 15P", "7m 10M 12d 15P 17m"],
  "7#9#11": ["1P 3M 7m 10m 12d", "3M 7m 10m 12d 15P", "7m 10M 12d 15P 17m"],
  "7b9#11": ["1P 7m 9m 10M 12d", "3M 7m 8P 9m 12d", "7m 8P 10M 12d 16m"],
  "7b9b5": ["1P 7m 9m 10M 12d", "3M 7m 8P 9m 12d", "7m 8P 10M 12d 16m"],
  "7b9#5": ["1P 7m 9m 10M 13m", "3M 7m 8P 9m 13m", "7m 9m 10M 13m 15P"],
  "7b9#9": ["1P 3M 7m 9m 10m", "3M 7m 8P 9m 10m", "7m 8P 10M 16m 17m"],
  "7b9b13": ["1P 7m 9m 10M 13m", "3M 7m 8P 9m 13m", "7m 9m 10M 13m 15P"],
  "7alt": [
    "3M 7m 8P 9m 12d",
    "1P 7m 10m 10M 13m",
    "3M 7m 8P 10m 13m",
    "3M 7m 9m 12d 15P",
    "3M 7m 10m 13m 15P",
    "7m 10M 12d 15P 17m",
    "7m 10M 13m 15P 17m"
  ],
  "13#11": ["1P 6M 7m 10M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "13b9": ["1P 3M 6M 7m 9m", "1P 6M 7m 9m 10M", "3M 7m 9m 10M 13M", "3M 7m 10M 13M 16m", "7m 10M 13M 16m 17M"],
  "13#9": ["1P 3M 6M 7m 10m", "3M 7m 8P 10m 13M", "7m 10M 13M 14m 17m"],
  "7b9sus": ["1P 5P 7m 9m 11P", "5P 7m 8P 9m 11P", "7m 8P 11P 14m 16m"],
  "7susadd3": ["1P 4P 5P 7m 10M", "5P 8P 10M 11P 14m", "7m 11P 12P 15P 17M"],
  "9sus": ["1P 5P 7m 9M 11P", "5P 7m 8P 9M 11P", "7m 8P 9M 11P 12P", "7m 8P 11P 12P 16M"],
  "13sus": ["1P 4P 6M 7m 9M", "1P 7m 9M 11P 13M", "5P 7m 9M 11P 13M", "7m 9M 11P 13M 15P"],
  "7b13sus": ["1P 5P 7m 11P 13m", "5P 7m 8P 11P 13m", "7m 11P 13m 14m 15P"]
}, Qr = {
  2: ["1P 5P 6M 8P 9M", "1P 5P 8P 9M 12P", "5P 8P 9M 12P 13M", "5P 8P 9M 12P 15P"],
  5: ["1P 5P 8P 12P", "1P 5P 8P 9M 12P", "5P 8P 12P 15P", "5P 8P 12P 15P 16M"],
  6: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 9M 10M 13M", "5P 8P 9M 10M 13M", "3M 6M 9M 12P 15P"],
  7: [
    "1P 5P 7m 8P 10M",
    "1P 7m 8P 10M 12P",
    "3M 7m 8P 10M 12P",
    "3M 7m 8P 10M 14m",
    "3M 7m 10M 12P 15P",
    "7m 10M 12P 14m 15P",
    "7m 10M 12P 15P 17M",
    "7m 10M 14m 17M 19P"
  ],
  9: [
    "1P 6M 7m 9M 10M",
    "3M 7m 9M 10M 12P",
    "1P 7m 9M 10M 13M",
    "3M 7m 9M 10M 13M",
    "3M 7m 9M 12P 15P",
    "7m 10M 12P 13M 16M",
    "7m 10M 13M 16M 17M",
    "7m 10M 13M 16M 19P"
  ],
  11: [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  13: [
    "3M 7m 9M 10M 13M",
    "3M 7m 9M 13M 15P",
    "3M 7m 10M 13M 16M",
    "7m 10M 12P 13M 16M",
    "7m 10M 13M 16M 17M",
    "7m 10M 13M 16M 19P"
  ],
  69: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 9M 10M 13M", "5P 8P 9M 10M 13M", "3M 6M 9M 12P 15P"],
  add9: [
    "1P 5P 8P 9M 10M",
    "1P 5P 9M 10M 12P",
    "3M 8P 9M 10M 12P",
    "3M 8P 9M 12P 15P",
    "5P 8P 9M 10M 15P",
    "5P 8P 9M 12P 17M"
  ],
  "+": [
    "1P 6m 8P 9M 10M",
    "1P 6m 8P 10M 13m",
    "3M 8P 9M 10M 13m",
    "3M 8P 10M 13m 15P",
    "6m 10M 13m 15P 16M",
    "6m 10M 13m 15P 17M"
  ],
  o: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  h: [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  sus: [
    "1P 4P 5P 8P 9M",
    "1P 4P 5P 8P 11P",
    "1P 5P 8P 9M 11P",
    "5P 8P 9M 11P 12P",
    "5P 8P 11P 12P 13M",
    "5P 8P 11P 13M 15P"
  ],
  "^": [
    "1P 3M 5P 6M 9M",
    "1P 5P 8P 10M 12P",
    "3M 5P 9M 10M 12P",
    "1P 5P 8P 10M 13M",
    "3M 8P 10M 13M 15P",
    "5P 9M 10M 12P 15P"
  ],
  "-": [
    "1P 3m 5P 8P 10m",
    "1P 3m 5P 9M 11P",
    "3m 5P 8P 9M 11P",
    "5P 8P 9M 10m 11P",
    "1P 5P 9M 10m 12P",
    "3m 5P 8P 10m 12P",
    "5P 8P 10m 12P 15P"
  ],
  "^7": [
    "1P 6M 7M 9M 10M",
    "3M 7M 9M 10M 12P",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "-7": [
    "1P 3m 5P 7m 9M",
    "1P 3m 5P 7m 10m",
    "1P 5P 7m 10m 11P",
    "3m 7m 8P 10m 11P",
    "1P 5P 7m 10m 12P",
    "3m 7m 9M 10m 12P",
    "3m 7m 8P 10m 14m",
    "5P 7m 9M 10m 14m",
    "7m 10m 11P 14m 15P",
    "7m 10m 12P 15P 16M",
    "5P 8P 11P 14m 17m",
    "7m 10m 12P 15P 17m"
  ],
  "7sus": [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  h7: [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  o7: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  "^9": [
    "1P 6M 7M 9M 10M",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 8P 9M 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "^13": [
    "1P 6M 7M 9M 10M",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 8P 9M 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "^7#11": [
    "1P 3M 5d 7M 9M",
    "1P 7M 9M 10M 12d",
    "3M 7M 9M 10M 12d",
    "3M 7M 9M 12d 13M",
    "3M 7M 10M 12d 14M",
    "7M 10M 12d 13M 14M",
    "7M 10M 12d 13M 16M",
    "7M 10M 12d 14M 17M"
  ],
  "^9#11": [
    "1P 3M 5d 7M 9M",
    "1P 7M 9M 10M 12d",
    "3M 7M 9M 10M 12d",
    "3M 7M 9M 12d 13M",
    "3M 7M 9M 12d 14M",
    "7M 10M 12d 14M 16M",
    "7M 10M 12d 13M 16M"
  ],
  "^7#5": ["1P 6m 7M 10M 13m", "3M 7M 9M 10M 13m", "3M 7M 10M 13m 14M", "7M 10M 13m 14M 16M", "7M 10M 13m 14M 17M"],
  "-6": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "1P 5P 6M 10m 11P",
    "3m 5P 6M 8P 11P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 10m 11P 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-69": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "3m 6M 9M 10m 12P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 9M 10m 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-^7": [
    "1P 3m 5P 7M 9M",
    "1P 5P 7M 10m 11P",
    "3m 7M 9M 10m 11P",
    "3m 7M 9M 10m 12P",
    "3m 7M 9M 12P 14M",
    "7M 10m 11P 12P 14M",
    "7M 10m 12P 14M 16M"
  ],
  "-^9": [
    "1P 3m 5P 7M 9M",
    "1P 5P 7M 10m 11P",
    "3m 7M 9M 10m 11P",
    "3m 7M 9M 10m 12P",
    "3m 7M 9M 12P 14M",
    "7M 10m 11P 12P 14M",
    "7M 10m 12P 14M 16M"
  ],
  "-9": [
    "1P 3m 5P 7m 9M",
    "1P 3m 7m 9M 11P",
    "3m 7m 9M 10m 11P",
    "3m 7m 9M 10m 12P",
    "3m 7m 9M 10m 14m",
    "3m 7m 9M 12P 15P",
    "7m 10m 11P 14m 16M",
    "7m 10m 12P 16M 18P"
  ],
  "-add9": ["1P 2M 3m 5P 8P", "1P 3m 5P 9M", "3m 5P 8P 9M 12P", "5P 8P 9M 10m 12P"],
  "-11": [
    "3m 5P 7m 9M 11P",
    "7m 9M 10m 11P",
    "1P 4P 7m 10m 12P",
    "3m 7m 9M 11P 12P",
    "7m 9M 10m 11P 12P",
    "3m 7m 9M 11P 14m",
    "4P 10m 12P 14m",
    "5P 8P 11P 14m",
    "5P 8P 11P 14m 16M",
    "7m 10m 12P 16M 18P",
    "7m 10m 11P 16M 21m"
  ],
  "-7b5": [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  h9: [
    "3m 5d 7m 9M 11P",
    "1P 7m 9M 10m 12d",
    "3m 7m 9M 12d 14m",
    "5d 8P 9M 10m 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 16M"
  ],
  "-b6": ["1P 3m 5P 6m 8P", "3m 5P 8P 11P 13m", "5P 8P 10m 11P 13m"],
  "-#5": ["1P 6m 8P 10m 13m", "3m 6m 8P 11P 13m", "6m 8P 10m 13m 15P"],
  "7b9": ["1P 3M 7m 9m 10M", "3M 7m 8P 9m 10M", "3M 7m 8P 9m 14m", "7m 9m 10M 14m 15P"],
  "7#9": ["1P 3M 7m 10m", "3M 7m 10m 10M 12P", "3M 7m 10m 12P 14m", "7m 10M 12P 14m 17m"],
  "7#11": ["1P 3M 7m 9M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "7b5": ["1P 3M 7m 9M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "7#5": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P", "7m 10M 13m 14m 17M"],
  "9#11": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9b5": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9#5": ["1P 7m 9M 10M 13m", "3M 7m 9M 10M 13m", "3M 7m 9M 13m 14m", "7m 10M 13m 14m 16M", "7m 10M 13m 16M 17M"],
  "7b13": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P", "7m 10M 13m 14m 17M"],
  "7#9#5": ["3M 7m 10m 10M 13m", "3M 7m 10m 13m 14m", "7m 10M 13m 14m 17m"],
  "7#9b5": ["3M 7m 10m 10M 12d", "3M 7m 10m 12d 14m", "7m 10M 12d 14m 17m"],
  "7#9#11": ["3M 7m 10m 10M 12d", "3M 7m 10m 12d 14m", "7m 10M 12d 14m 17m"],
  "7b9#11": ["3M 7m 9m 10M 12d", "3M 7m 9m 12d 14m", "7m 8P 10M 12d 16m", "7m 10M 12d 14m 16m"],
  "7b9b5": ["3M 7m 9m 10M 12d", "3M 7m 9m 12d 14m", "7m 8P 10M 12d 16m", "7m 10M 12d 14m 16m"],
  "7b9#5": ["1P 7m 9m 10M 13m", "3M 7m 9m 10M 13m", "3M 7m 10M 13m 16m", "7m 10M 13m 14m 16m", "7m 10M 13m 16m 17M"],
  "7b9#9": ["1P 3M 7m 9m 10m", "3M 7m 10m 13m 16m", "7m 10M 13m 16m 17m"],
  "7b9b13": ["1P 7m 9m 10M 13m", "3M 7m 9m 10M 13m", "3M 7m 10M 13m 16m", "7m 10M 13m 14m 16m", "7m 10M 13m 16m 17M"],
  "7alt": [
    "3M 7m 8P 10m 13m",
    "3M 7m 9m 12d 13m",
    "3M 7m 9m 10m 13m",
    "3M 7m 10m 13m 14m",
    "3M 7m 9m 12d 14m",
    "3M 7m 10m 13m 15P",
    "3M 7m 10m 13m 16m",
    "7m 10M 12d 14m 16m",
    "7m 10M 12d 13m 16m",
    "7m 10M 13m 15P 17m",
    "7m 10M 13m 16m 17m",
    "7m 10M 13m 16m 19d"
  ],
  "13#11": ["3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "13b9": ["3M 7m 9m 10M 13M", "3M 7m 10M 13M 16m", "7m 10M 13M 16m 17M"],
  "13#9": ["3M 7m 10m 10M 13M", "7m 10M 13M 14m 17m"],
  "7b9sus": ["1P 5P 7m 9m 11P", "5P 7m 8P 9m 11P", "7m 8P 11P 14m 16m"],
  "7susadd3": ["1P 4P 5P 7m 10M", "5P 8P 10M 11P 14m", "7m 11P 12P 15P 17M"],
  "9sus": [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  "13sus": [
    "1P 4P 6M 7m 9M",
    "1P 7m 9M 11P 13M",
    "4P 7m 9M 11P 13M",
    "7m 9M 11P 13M 15P",
    "7m 11P 13M 14m 16M",
    "7m 11P 13M 16M 18P"
  ],
  "7b13sus": ["1P 5P 7m 11P 13m", "5P 7m 8P 11P 13m", "7m 11P 13m 14m 15P"]
}, { dictionaryVoicing: JF, minTopNoteDiff: UF } = Cc.default || Cc, QF = {
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  69: ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
}, eE = {
  m7: ["3m 7m", "7m 10m"],
  m9: ["3m 7m", "7m 10m"],
  7: ["3M 7m", "7m 10M"],
  "^7": ["3M 7M", "7M 10M"],
  "^9": ["3M 7M", "7M 10M"],
  69: ["3M 6M"],
  6: ["3M 6M", "6M 10M"],
  m7b5: ["3m 7m", "7m 10m"],
  "7b9": ["3M 7m", "7m 10M"],
  "7b13": ["3M 7m", "7m 10M"],
  o7: ["3m 6M", "6M 10m"],
  "7#11": ["3M 7m", "7m 10M"],
  "7#9": ["3M 7m", "7m 10M"],
  mM7: ["3m 7M", "7M 10m"],
  m6: ["3m 6M", "6M 10m"]
}, tE = {
  "": ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"]
}, nE = {
  // triads
  "": ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"],
  // sevenths chords
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  69: ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
}, kr = {
  lefthand: { dictionary: QF, range: ["F3", "A4"], mode: "below", anchor: "a4" },
  triads: { dictionary: tE, mode: "below", anchor: "a4" },
  guidetones: { dictionary: eE, mode: "above", anchor: "a4" },
  legacy: { dictionary: nE, mode: "below", anchor: "a4" }
};
let e2 = "ireal";
const t2 = (e) => e2 = e, rE = (e, t) => n2(e, kr[e].dictionary, t), n2 = (e, t, n = ["F3", "A4"]) => {
  Object.assign(kr, { [e]: { dictionary: t, range: n } });
}, Ka = (e, t, n = {}) => {
  Object.assign(kr, { [e]: { dictionary: t, ...n } });
}, iE = (e, t, n) => {
  const { dictionary: r, range: i } = kr[t];
  return JF({
    chord: e,
    dictionary: r,
    range: i,
    picker: UF,
    lastVoicing: n
  });
};
let Vi;
const sE = N("voicings", function(e, t) {
  return t.fmap((n) => (Vi = iE(n, e, Vi), Le(...Vi))).outerJoin();
}), uE = N("rootNotes", function(e, t) {
  return t.fmap((n) => {
    const s = (n.chord || n).match(/^([a-gA-G][b#]?).*$/)[1] + e;
    return n.chord ? { note: s } : s;
  });
}), aE = N("voicing", function(e) {
  return e.fmap((t) => {
    t = typeof t == "string" ? { chord: t } : t;
    let { dictionary: n = e2, chord: r, anchor: i, offset: s, mode: u, n: a, octaves: o, ...f } = t;
    n = typeof n == "string" ? kr[n] : { dictionary: n, mode: "below", anchor: "c5" };
    try {
      let h = RF({ ...n, chord: r, anchor: i, offset: s, mode: u, n: a, octaves: o });
      return Le(...h).note().set(f);
    } catch {
      return Ue(`[voicing]: unknown chord "${r}"`), Se;
    }
  }).outerJoin();
});
function ei(e, t, n) {
  n = Array.isArray(n) ? n : [n], n.forEach((r) => {
    r[t] = r[e];
  });
}
ei("^", "", [pr, Qr]);
Object.keys(pr).forEach((e) => {
  if (e.includes("-")) {
    let t = e.replace("-", "m");
    ei(e, t, [Qr, pr]);
  }
  if (e.includes("^")) {
    let t = e.replace("^", "M");
    ei(e, t, [Qr, pr]);
  }
  if (e.includes("+")) {
    let t = e.replace("+", "aug");
    ei(e, t, [Qr, pr]);
  }
});
Ka("ireal", pr);
Ka("ireal-ext", Qr);
function oE() {
  Vi = void 0, t2("ireal");
}
const cE = "@strudel/tonal", lE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addVoicings: n2,
  packageName: cE,
  registerVoicings: Ka,
  resetVoicings: oE,
  rootNotes: uE,
  scale: $F,
  scaleTrans: zF,
  scaleTranspose: OF,
  setDefaultVoicings: t2,
  setVoicingRange: rE,
  strans: jF,
  trans: WF,
  transpose: XF,
  voicing: aE,
  voicingAlias: ei,
  voicingRegistry: kr,
  voicings: sE
}, Symbol.toStringTag, { value: "Module" }));
async function fE() {
  const e = Ti(
    Ti,
    Promise.resolve().then(() => cd),
    Promise.resolve().then(() => Ov),
    Promise.resolve().then(() => lE),
    Promise.resolve().then(() => Nv),
    { hush: pE, evaluate: dE }
  );
  await Promise.all([
    e,
    Zd()
    /* , registerSoundfonts() */
  ]);
}
let Eu, qn;
function hE(e = {}) {
  Nd(), e.miniAllStrings !== !1 && rm();
  const { prebake: t, ...n } = e;
  return qn = Hd({ ...n, transpiler: fD }), Eu = (async () => (await fE(), await t?.(), qn))(), Ni(() => qn.scheduler.now()), Eu;
}
window.initStrudel = hE;
$.prototype.play = function() {
  if (!qn)
    throw new Error(".play: no repl found. Have you called initStrudel?");
  return Eu.then(() => {
    qn.setPattern(this, !0);
  }), this;
};
function pE() {
  qn.stop();
}
async function dE(e, t = !0) {
  return qn.evaluate(e, t);
}
export {
  Tc as ClockCollator,
  ad as Cyclist,
  oa as DEFAULT_MAX_POLYPHONY,
  j as Fraction,
  je as Hap,
  $ as Pattern,
  Rv as StartRules,
  gr as State,
  Yn as SyntaxError,
  He as TimeSpan,
  ta as __chooseWith,
  Qu as _brandBy,
  Hc as _fitslice,
  ea as _irand,
  na as _keyDown,
  Kc as _match,
  kt as _mod,
  Wu as _morph,
  Jc as _polymeterListSteps,
  cu as _retime,
  lu as _slices,
  Al as accelerate,
  ph as activeLabel,
  yp as ad,
  T3 as add,
  n2 as addVoicings,
  gp as adsr,
  QC as aliasBank,
  rC as almostAlways,
  nC as almostNever,
  sC as always,
  vl as amp,
  ft as analysers,
  zn as analysersData,
  Nl as analyze,
  Rh as anchor,
  eA as and,
  BA as apply,
  Li as applyFM,
  yn as applyGainCurve,
  bp as ar,
  d3 as arp,
  p3 as arpWith,
  M3 as arrange,
  Lp as as,
  Dl as att,
  Pl as attack,
  Dc as averageArray,
  xC as backgroundImage,
  X3 as band,
  jl as bandf,
  Hl as bandq,
  Tl as bank,
  Vc as base64ToUnicode,
  g0 as bbexpr,
  A0 as bbst,
  Qb as beat,
  Yl as begin,
  zM as berlin,
  nd as berlinWith,
  wM as binary,
  Hp as binaryN,
  E3 as bind,
  Z1 as binshift,
  NA as bite,
  $u as bjork,
  z3 as blshift,
  W3 as bor,
  ql as bp,
  J0 as bpa,
  Y0 as bpattack,
  rf as bpd,
  nf as bpdecay,
  j0 as bpe,
  z0 as bpenv,
  $l as bpf,
  Kl as bpq,
  gf as bpr,
  mf as bprelease,
  lf as bps,
  cf as bpsustain,
  $A as brak,
  VM as brand,
  kM as brandBy,
  j3 as brshift,
  O3 as bxor,
  Mb as bypass,
  m0 as byteBeatExpression,
  y0 as byteBeatStartTime,
  l3 as calculateSteps,
  zc as cat,
  Fp as ccn,
  Ep as ccv,
  sA as ceil,
  M0 as ch,
  I0 as channel,
  b0 as channels,
  Jp as choose,
  Up as chooseCycles,
  TM as chooseIn,
  es as chooseInWith,
  NM as chooseOut,
  Qi as chooseWith,
  Ob as chop,
  Th as chord,
  cb as chunk,
  hb as chunkBack,
  bb as chunkBackInto,
  yb as chunkInto,
  pb as chunkback,
  Ab as chunkbackinto,
  gb as chunkinto,
  Hi as clamp,
  wC as cleanupUi,
  U1 as clip,
  i0 as coarse,
  i3 as code2hash,
  dp as color,
  mp as colour,
  L1 as comb,
  $y as compose,
  hA as compress,
  pA as compressSpan,
  u1 as compressor,
  c1 as compressorAttack,
  a1 as compressorKnee,
  o1 as compressorRatio,
  l1 as compressorRelease,
  dA as compressspan,
  Rd as connectToDestination,
  qy as constant,
  rl as contract,
  Dp as control,
  nM as controls,
  dM as cosine,
  mM as cosine2,
  _A as cpm,
  J1 as cps,
  Xp as createClock,
  wi as createFilter,
  Yi as createParam,
  zu as createParams,
  r0 as crush,
  L0 as ctf,
  xp as ctlNum,
  yh as ctranspose,
  Ae as curry,
  rp as curve,
  T0 as cut,
  N0 as cutoff,
  uu as cycleToSeconds,
  Gl as dec,
  Rl as decay,
  fE as defaultPrebake,
  qM as degrade,
  $M as degradeBy,
  jM as degradeByWith,
  mh as degree,
  Vf as delay,
  Tf as delayfb,
  If as delayfeedback,
  Zf as delaysync,
  Rf as delayt,
  Lf as delaytime,
  ip as deltaSlide,
  Of as det,
  Wf as detune,
  Nf as dfb,
  Lh as dict,
  Nh as dictionary,
  s1 as dist,
  i1 as distort,
  R3 as div,
  kf as djf,
  vv as dough,
  $d as doughTrigger,
  Ud as drawFrequencyScope,
  Rc as drawLine,
  Jd as drawTimeScope,
  d0 as drive,
  el as drop,
  $f as dry,
  gd as drywet,
  Ap as ds,
  zd as dspWorklet,
  Gf as dt,
  f0 as duck,
  p0 as duckattack,
  h0 as duckdepth,
  tp as dur,
  ep as duration,
  uM as e,
  kA as early,
  rb as echo,
  QA as echoWith,
  eb as echowith,
  hM as eish,
  Jl as end,
  T1 as enhance,
  Y3 as eq,
  J3 as eqt,
  sM as euclid,
  cM as euclidLegato,
  lM as euclidLegatoRot,
  oM as euclidRot,
  fM as euclidish,
  aM as euclidrot,
  Ti as evalScope,
  dE as evaluate,
  SA as every,
  nl as expand,
  g1 as expression,
  tl as extend,
  Kf as fadeInTime,
  Hf as fadeOutTime,
  qf as fadeTime,
  Af as fanchor,
  CA as fast,
  mb as fastChunk,
  mA as fastGap,
  ot as fastcat,
  db as fastchunk,
  gA as fastgap,
  Ll as fft,
  Fb as filter,
  Eb as filterWhen,
  wA as firstOf,
  Hb as fit,
  bn as flatten,
  iA as floor,
  xl as fm,
  Sl as fmattack,
  _l as fmdecay,
  wl as fmenv,
  Fl as fmh,
  El as fmi,
  Vl as fmrelease,
  kl as fmsustain,
  Il as fmvelocity,
  Bl as fmwave,
  yA as focus,
  AA as focusSpan,
  bA as focusspan,
  Hy as fractionalArgs,
  O1 as frameRate,
  z1 as frames,
  B1 as freeze,
  Yf as freq,
  Bu as freqToMidi,
  aA as fromBipolar,
  A1 as fshift,
  b1 as fshiftnote,
  M1 as fshiftphase,
  yf as ftype,
  nA as func,
  Ml as gain,
  gt as gainNode,
  vr as gap,
  ch as gat,
  oh as gate,
  tn as getADSRValues,
  Gd as getAnalyserById,
  rs as getAnalyzerData,
  Pe as getAudioContext,
  uv as getAudioContextCurrentTime,
  kd as getAudioDevices,
  jC as getCachedBuffer,
  md as getCompressor,
  ju as getControlName,
  Lc as getCurrentKeyboardState,
  Ye as getDefaultValue,
  Xy as getEventOffsetMs,
  Pc as getFreq,
  Ec as getFrequency,
  ha as getLeafLocation,
  pa as getLeafLocations,
  nm as getLeaves,
  ns as getLfo,
  qC as getLoadedBuffer,
  Wd as getOscillator,
  en as getParamADSR,
  u3 as getPerformanceTimeSeconds,
  ii as getPitchEnvelope,
  jy as getPlayableNoteValue,
  Ad as getSampleBuffer,
  bd as getSampleBufferSource,
  yd as getSampleInfo,
  Si as getSound,
  zy as getSoundIndex,
  hu as getTime,
  od as getTrigger,
  si as getVibratoOscillator,
  yD as getWidgetID,
  Ot as getWorklet,
  Od as getZZFX,
  wb as grow,
  q3 as gt,
  K3 as gte,
  Xv as h,
  Ah as harmonic,
  s3 as hash2code,
  X1 as hbrick,
  Ff as hcutoff,
  zl as hold,
  j1 as hours,
  xf as hp,
  K0 as hpa,
  H0 as hpattack,
  tf as hpd,
  ef as hpdecay,
  O0 as hpe,
  W0 as hpenv,
  Ef as hpf,
  Sf as hpq,
  df as hpr,
  pf as hprelease,
  of as hps,
  af as hpsustain,
  wf as hresonance,
  Db as hsl,
  Pb as hsla,
  vA as hurry,
  pE as hush,
  hr as id,
  I1 as imag,
  yC as inhabit,
  bC as inhabitmod,
  Td as initAudio,
  Nd as initAudioOnFirstClick,
  hE as initStrudel,
  Ld as initializeAudioOutput,
  x3 as innerBind,
  FA as inside,
  OA as inv,
  WA as invert,
  Kh as ir,
  IM as irand,
  Uh as irbegin,
  Yh as iresponse,
  Jh as irspeed,
  fl as isControlName,
  Un as isNote,
  Ly as isNoteWithOctave,
  Nu as isPattern,
  Ui as isaw,
  Hu as isaw2,
  sb as iter,
  ub as iterBack,
  ab as iterback,
  bM as itri,
  MM as itri2,
  UA as jux,
  YA as juxBy,
  JA as juxby,
  P1 as kcutoff,
  V3 as keep,
  I3 as keepif,
  Nc as keyAlias,
  aC as keyDown,
  v1 as krush,
  dh as label,
  xA as lastOf,
  $c as late,
  W1 as lbrick,
  Q1 as legato,
  lh as leslie,
  ap as lfo,
  LA as linger,
  _u as listRange,
  aa as loadBuffer,
  Xf as lock,
  wu as logKey,
  Ul as loop,
  $b as loopAt,
  Kb as loopAtCps,
  Ql as loopBegin,
  t0 as loopEnd,
  qb as loopat,
  Yb as loopatcps,
  e0 as loopb,
  n0 as loope,
  G0 as lp,
  q0 as lpa,
  $0 as lpattack,
  Q0 as lpd,
  U0 as lpdecay,
  X0 as lpe,
  Z0 as lpenv,
  R0 as lpf,
  _f as lpq,
  hf as lpr,
  ff as lprelease,
  uf as lps,
  sf as lpsustain,
  fh as lrate,
  hh as lsize,
  $3 as lt,
  H3 as lte,
  Zv as m,
  Vu as mapArgs,
  v3 as mask,
  Oy as midi2note,
  Hn as midiToFreq,
  Ip as midibend,
  Mp as midichan,
  Pp as midicmd,
  Cp as midimap,
  vp as midiport,
  Tp as miditouch,
  da as mini,
  hi as mini2ast,
  rm as miniAllStrings,
  Wv as minify,
  $1 as minutes,
  G3 as mod,
  Xh as mode,
  eM as morph,
  DM as mouseX,
  vM as mouseY,
  PM as mousex,
  CM as mousey,
  gh as mtranspose,
  L3 as mul,
  gl as n,
  Fc as nanFallback,
  U3 as ne,
  Q3 as net,
  iC as never,
  vf as noise,
  sa as noises,
  yl as note,
  Ln as noteToMidi,
  Dt as nothing,
  wp as nrpnn,
  Sp as nrpv,
  Ch as nudge,
  vt as numeralArgs,
  Ic as objectMap,
  vh as octave,
  Mh as octaveR,
  Zh as octaves,
  D1 as octer,
  F1 as octersub,
  E1 as octersubsub,
  jA as off,
  Gh as offset,
  eC as often,
  Ed as onTriggerSample,
  tA as or,
  Ph as orbit,
  w3 as outerBind,
  EA as outside,
  Dh as overgain,
  Fh as overshape,
  Yc as pace,
  cE as packageName,
  Bc as pairs,
  KA as palindrome,
  Eh as pan,
  ah as panchor,
  ov as panic,
  Bh as panorient,
  xh as panspan,
  wh as pansplay,
  Sh as panwidth,
  em as parse,
  Sc as parseFractional,
  ku as parseNumeral,
  N1 as partials,
  Uf as patt,
  Jf as pattack,
  Pr as patternifyAST,
  uh as pcurve,
  eh as pdec,
  Qf as pdecay,
  sh as penv,
  OM as perlin,
  td as perlinWith,
  F0 as ph,
  V0 as phasdp,
  E0 as phaser,
  S0 as phasercenter,
  _0 as phaserdepth,
  D0 as phaserrate,
  x0 as phasersweep,
  B0 as phc,
  k0 as phd,
  w0 as phs,
  rd as pick,
  cC as pickF,
  fC as pickOut,
  mC as pickReset,
  pC as pickRestart,
  AC as pickSqueeze,
  id as pickmod,
  lC as pickmodF,
  hC as pickmodOut,
  gC as pickmodReset,
  dC as pickmodRestart,
  MC as pickmodSqueeze,
  wc as pipe,
  sp as pitchJump,
  up as pitchJumpTime,
  MA as ply,
  A3 as pm,
  _3 as polyBind,
  Np as polyTouch,
  Ki as polymeter,
  g3 as polyrhythm,
  Cl as postgain,
  Z3 as pow,
  y3 as pr,
  ih as prel,
  rh as prelease,
  HA as press,
  qA as pressBy,
  Pd as processSampleMap,
  Bp as progNum,
  nh as psus,
  th as psustain,
  Je as pure,
  C0 as pw,
  v0 as pwrate,
  P0 as pwsweep,
  ht as rand,
  _M as rand2,
  LM as randcat,
  Kp as randrun,
  oA as range,
  lA as range2,
  cA as rangex,
  tC as rarely,
  _h as rate,
  fA as ratio,
  $h as rdim,
  V1 as real,
  Jb as ref,
  N as register,
  w as registerControl,
  DE as registerLanguage,
  HC as registerSamplesPrefix,
  An as registerSound,
  Zd as registerSynthSounds,
  Ka as registerVoicings,
  PE as registerWidgetType,
  Cv as registerZZFXSounds,
  q as reify,
  Ol as rel,
  Wl as release,
  Cr as removeUndefineds,
  ob as repeatCycles,
  op as repeatTime,
  EC as repl,
  Vd as resetDefaultValues,
  nv as resetDefaults,
  mv as resetGlobalEffects,
  sv as resetLoadedSounds,
  oE as resetVoicings,
  Bf as resonance,
  qc as rev,
  Md as reverseBuffer,
  Hh as rfade,
  vb as rib,
  Cb as ribbon,
  x1 as ring,
  S1 as ringdf,
  w1 as ringf,
  zh as rlp,
  Wh as room,
  jh as roomdim,
  qh as roomfade,
  Oh as roomlp,
  Qh as roomsize,
  uE as rootNotes,
  xc as rotate,
  rA as round,
  n1 as rsize,
  qp as run,
  hl as s,
  Tb as s_add,
  _b as s_alt,
  Bb as s_cat,
  Gb as s_contract,
  Lb as s_expand,
  Rb as s_extend,
  kb as s_polymeter,
  Nb as s_sub,
  Vb as s_taper,
  Ib as s_taperlist,
  Zb as s_tour,
  Xb as s_zip,
  Fd as samples,
  li as saw,
  qu as saw2,
  $F as scale,
  zF as scaleTrans,
  OF as scaleTranspose,
  G1 as scram,
  BM as scramble,
  Rp as scrub,
  q1 as seconds,
  GA as seg,
  RA as segment,
  Vh as semitone,
  jc as seq,
  C3 as seqPLoop,
  qt as sequence,
  Zc as sequenceP,
  k3 as set,
  tv as setDefault,
  Id as setDefaultAudioContext,
  la as setDefaultValue,
  rv as setDefaultValues,
  t2 as setDefaultVoicings,
  JC as setGainCurve,
  fd as setLogger,
  wd as setMaxPolyphony,
  Bd as setMultiChannelOrbits,
  Gc as setStringParser,
  Ni as setTime,
  iv as setVersionDefaults,
  rE as setVoicingRange,
  r1 as shape,
  sl as shrink,
  il as shrinklist,
  SM as shuffle,
  Vt as signal,
  Se as silence,
  Wp as sine,
  Ku as sine2,
  e1 as size,
  cl as slice,
  kh as slide,
  PA as slow,
  fb as slowChunk,
  Rn as slowcat,
  Ru as slowcatPrime,
  lb as slowchunk,
  R1 as smear,
  t3 as sol2note,
  QM as someCycles,
  UM as someCyclesBy,
  JM as sometimes,
  YM as sometimesBy,
  H1 as songPtr,
  pl as sound,
  nn as soundMap,
  dl as source,
  DA as sparsity,
  PC as speak,
  Ou as speed,
  jb as splice,
  Iu as splitAt,
  jf as spread,
  Op as square,
  gM as square2,
  CC as squeeze,
  S3 as squeezeBind,
  p1 as squiz,
  ml as src,
  Le as stack,
  b3 as stackBy,
  Oc as stackCentre,
  Xc as stackLeft,
  Wc as stackRight,
  pM as steady,
  B3 as stepBind,
  Uc as stepalt,
  At as stepcat,
  Wb as steps,
  bh as stepsPerOctave,
  jF as strans,
  f1 as stretch,
  zb as striate,
  Tu as stringifyValues,
  P3 as struct,
  sd as strudelScope,
  ib as stut,
  tb as stutWith,
  nb as stutwith,
  N3 as sub,
  fa as superdough,
  gv as superdoughTrigger,
  D3 as superimpose,
  Xl as sus,
  Zl as sustain,
  y1 as sustainpedal,
  XA as swing,
  ZA as swingBy,
  _p as sysex,
  Vp as sysexdata,
  kp as sysexid,
  t1 as sz,
  Qc as take,
  Yu as time,
  Xu as timeCat,
  Sb as timecat,
  uA as toBipolar,
  vc as tokenizeNote,
  ul as tour,
  WF as trans,
  fD as transpiler,
  XF as transpose,
  s0 as tremolo,
  a0 as tremolodepth,
  c0 as tremolophase,
  l0 as tremoloshape,
  o0 as tremoloskew,
  u0 as tremolosync,
  yM as tri,
  AM as tri2,
  C1 as triode,
  k1 as tsdelay,
  K1 as uid,
  KM as undegrade,
  HM as undegradeBy,
  kc as unicodeToBase64,
  n3 as uniq,
  r3 as uniqsort,
  _c as uniqsortr,
  zf as unison,
  h1 as unit,
  Cf as v,
  Y1 as val,
  Zy as valueToMidi,
  bl as velocity,
  bf as vib,
  Pf as vibmod,
  Mf as vibrato,
  Df as vmod,
  Ih as voice,
  aE as voicing,
  ei as voicingAlias,
  kr as voicingRegistry,
  sE as voicings,
  d1 as vowel,
  Xd as waveformN,
  m1 as waveloss,
  GM as wchoose,
  ed as wchooseCycles,
  Yr as webAudioTimeout,
  qd as webaudioOutput,
  Hd as webaudioRepl,
  zA as when,
  uC as whenKey,
  F3 as withValue,
  xb as within,
  ZM as wrandcat,
  ll as xfade,
  _1 as xsdelay,
  fp as zcrush,
  hp as zdelay,
  al as zip,
  qi as zipWith,
  lp as zmod,
  cp as znoise,
  VA as zoom,
  IA as zoomArc,
  TA as zoomarc,
  np as zrand,
  pp as zzfx
};
