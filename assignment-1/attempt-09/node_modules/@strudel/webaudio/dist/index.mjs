import * as P from "@strudel/core";
import { Pattern as m, clamp as q } from "@strudel/core";
import { setLogger as R, doughTrigger as k, superdough as I, getAudioContext as M, analysers as v, getAnalyzerData as b } from "superdough";
export * from "superdough";
import { getTheme as A, getDrawContext as z } from "@strudel/draw";
const { Pattern: O, logger: W, repl: $ } = P;
R(W);
const B = (e) => (e.ensureObjectValue(), e.value), F = (e, t, o, s, f) => I(B(e), f, o, s, e.whole?.begin.valueOf());
function H(e = {}) {
  return e = {
    getTime: () => M().currentTime,
    defaultOutput: F,
    ...e
  }, $(e);
}
O.prototype.dough = function() {
  return this.onTrigger(k, 1);
};
function j(e, {
  align: t = !0,
  color: o = "white",
  thickness: s = 3,
  scale: f = 0.25,
  pos: a = 0.75,
  trigger: u = 0,
  ctx: r = z(),
  id: y = 1
} = {}) {
  r.lineWidth = s, r.strokeStyle = o;
  let c = r.canvas;
  if (!e) {
    r.beginPath();
    let l = a * c.height;
    r.moveTo(0, l), r.lineTo(c.width, l), r.stroke();
    return;
  }
  const n = b("time", y);
  r.beginPath();
  const p = e.frequencyBinCount;
  let h = t ? Array.from(n).findIndex((l, d, g) => d && g[d - 1] > -u && l <= -u) : 0;
  h = Math.max(h, 0);
  const w = c.width * 1 / p;
  let i = 0;
  for (let l = h; l < p; l++) {
    const d = n[l] + 1, g = (a - f * (d - 1)) * c.height;
    l === 0 ? r.moveTo(i, g) : r.lineTo(i, g), i += w;
  }
  r.stroke();
}
function L(e, { color: t = "white", scale: o = 0.25, pos: s = 0.75, lean: f = 0.5, min: a = -150, max: u = 0, ctx: r = z(), id: y = 1 } = {}) {
  if (!e) {
    r.beginPath();
    let i = s * n.height;
    r.moveTo(0, i), r.lineTo(n.width, i), r.stroke();
    return;
  }
  const c = b("frequency", y), n = r.canvas;
  r.fillStyle = t;
  const p = e.frequencyBinCount, h = n.width * 1 / p;
  let w = 0;
  for (let i = 0; i < p; i++) {
    const d = q((c[i] - a) / (u - a), 0, 1) * o, g = d * n.height, D = (s - d * f) * n.height;
    r.fillRect(w, D, Math.max(h, 1), g), w += h;
  }
}
function C(e = 0, t = "0,0,0", o = z()) {
  e ? (o.fillStyle = `rgba(${t},${1 - e})`, o.fillRect(0, 0, o.canvas.width, o.canvas.height)) : o.clearRect(0, 0, o.canvas.width, o.canvas.height);
}
m.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      C(e.smear, "0,0,0", e.ctx), v[t] && L(v[t], e);
    },
    { id: t }
  );
};
m.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (o) => {
      e.color = o[0]?.value?.color || A().foreground, e.color, C(e.smear, "0,0,0", e.ctx), j(v[t], e);
    },
    { id: t }
  );
};
m.prototype.scope = m.prototype.tscope;
let T = {};
m.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (o) => {
      e.color = o[0]?.value?.color || T[t] || A().foreground, T[t] = e.color, V(v[t], e);
    },
    { id: t }
  );
};
m.prototype.scope = m.prototype.tscope;
const S = /* @__PURE__ */ new Map();
function V(e, { thickness: t = 3, speed: o = 1, min: s = -80, max: f = 0, ctx: a = z(), id: u = 1, color: r } = {}) {
  if (a.lineWidth = t, a.strokeStyle = r, !e)
    return;
  const y = o, c = b("frequency", u), n = a.canvas;
  a.fillStyle = r;
  const p = e.frequencyBinCount;
  let h = S.get(u) || a.getImageData(0, 0, n.width, n.height);
  S.set(u, h), a.clearRect(0, 0, a.canvas.width, a.canvas.height), a.putImageData(h, -y, 0);
  let w = n.width - o;
  for (let i = 0; i < p; i++) {
    const l = q((c[i] - s) / (f - s), 0, 1);
    a.globalAlpha = l;
    const d = Math.log(i + 1) / Math.log(p) * n.height;
    a.fillRect(w, n.height - d, y, 2);
  }
  S.set(u, a.getImageData(0, 0, n.width, n.height));
}
export {
  L as drawFrequencyScope,
  j as drawTimeScope,
  F as webaudioOutput,
  H as webaudioRepl
};
