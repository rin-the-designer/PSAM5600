import T from "fraction.js";
const It = "strudel.log";
let Te = 1e3, Jt, jt;
function Ht(t, e = "cyclist") {
  z(`[${e}] error: ${t.message}`);
}
function z(t, e, n = {}) {
  let s = performance.now();
  Jt === t && s - jt < Te || (Jt = t, jt = s, console.log(`%c${t}`, "background-color: black;color:white;border-radius:15px"), typeof document < "u" && typeof CustomEvent < "u" && document.dispatchEvent(
    new CustomEvent(It, {
      detail: {
        message: t,
        type: e,
        data: n
      }
    })
  ));
}
z.key = It;
const Iu = (t) => /^[a-gA-G][#bs]*[0-9]$/.test(t), _t = (t) => /^[a-gA-G][#bsf]*[0-9]?$/.test(t), xe = (t) => {
  if (typeof t != "string")
    return [];
  const [e, n = "", s] = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return e ? [e, n, s ? Number(s) : void 0] : [];
}, Ce = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, Be = { "#": 1, b: -1, s: 1, f: -1 }, lt = (t, e = 3) => {
  const [n, s, r = e] = xe(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const o = Ce[n.toLowerCase()], c = s?.split("").reduce((u, a) => u + Be[a], 0) || 0;
  return (Number(r) + 1) * 12 + o + c;
}, et = (t) => Math.pow(2, (t - 69) / 12) * 440, Oe = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69, Hu = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: s } = t;
  if (typeof n == "number")
    return Oe(n);
  if (typeof s == "string")
    return lt(s);
  if (typeof s == "number")
    return s;
  if (!e)
    throw new Error("valueToMidi: expected freq or note to be set");
  return e;
}, Vu = (t, e) => (t - e) * 1e3, ze = (t) => et(typeof t == "number" ? t : lt(t)), Ee = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], Fu = (t) => {
  const e = Math.floor(t / 12) - 1;
  return Ee[t % 12] + e;
}, pt = (t, e) => (t % e + e) % e, Me = (t) => t.reduce((e, n) => e + n) / t.length;
function Je(t, e = 0) {
  return isNaN(Number(t)) ? (z(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
const Du = (t, e) => pt(Math.round(Je(t ?? 0, 0)), e), Gu = (t) => {
  let { value: e, context: n } = t, s = e;
  if (typeof s == "object" && !Array.isArray(s) && (s = s.note || s.n || s.value, s === void 0))
    throw new Error(`cannot find a playable note for ${JSON.stringify(e)}`);
  if (typeof s == "number" && n.type !== "frequency")
    s = et(t.value);
  else if (typeof s == "number" && n.type === "frequency")
    s = t.value;
  else if (typeof s != "string" || !_t(s))
    throw new Error("not a note: " + JSON.stringify(s));
  return s;
}, Qu = (t) => {
  let { value: e, context: n } = t;
  if (typeof e == "object")
    return e.freq ? e.freq : ze(e.note || e.n || e.value);
  if (typeof e == "number" && n.type !== "frequency")
    e = et(t.value);
  else if (typeof e == "string" && _t(e))
    e = et(lt(t.value));
  else if (typeof e != "number")
    throw new Error("not a note or frequency: " + e);
  return e;
}, je = (t, e) => t.slice(e).concat(t.slice(0, e)), Pe = (...t) => t.reduce(
  (e, n) => (...s) => e(n(...s)),
  (e) => e
), Uu = (...t) => Pe(...t.reverse()), ot = (t) => t.filter((e) => e != null), F = (t) => [].concat(...t), tt = (t) => t, Ku = (t, e) => t, Vt = (t, e) => Array.from({ length: e - t + 1 }, (n, s) => s + t);
function g(t, e, n = t.length) {
  const s = function r(...o) {
    if (o.length >= n)
      return t.apply(this, o);
    {
      const c = function(...u) {
        return r.apply(this, o.concat(u));
      };
      return e && e(c, o), c;
    }
  };
  return e && e(s, []), s;
}
function Ft(t) {
  const e = Number(t);
  if (!isNaN(e))
    return e;
  if (_t(t))
    return lt(t);
  throw new Error(`cannot parse as numeral: "${t}"`);
}
function Dt(t, e) {
  return (...n) => t(...n.map(e));
}
function $(t) {
  return Dt(t, Ft);
}
function Ne(t) {
  const e = Number(t);
  if (!isNaN(e))
    return e;
  const n = {
    pi: Math.PI,
    w: 1,
    h: 0.5,
    q: 0.25,
    e: 0.125,
    s: 0.0625,
    t: 1 / 3,
    f: 0.2,
    x: 1 / 6
  }[t];
  if (typeof n < "u")
    return n;
  throw new Error(`cannot parse as fractional: "${t}"`);
}
const Xu = (t) => Dt(t, Ne), Gt = function(t, e) {
  return [e.slice(0, t), e.slice(t)];
}, vt = (t, e, n) => e.map((s, r) => t(s, n[r])), $e = function(t) {
  const e = [];
  for (let n = 0; n < t.length - 1; ++n)
    e.push([t[n], t[n + 1]]);
  return e;
}, Re = (t, e, n) => Math.min(Math.max(t, e), n), We = ["Do", "Reb", "Re", "Mib", "Mi", "Fa", "Solb", "Sol", "Lab", "La", "Sib", "Si"], Le = [
  "Sa",
  "Re",
  "Ga",
  "Ma",
  "Pa",
  "Dha",
  "Ni"
], Ie = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Hb", "H"], He = [
  "Ni",
  "Pab",
  "Pa",
  "Voub",
  "Vou",
  "Ga",
  "Dib",
  "Di",
  "Keb",
  "Ke",
  "Zob",
  "Zo"
], Ve = [
  "I",
  "Ro",
  "Ha",
  "Ni",
  "Ho",
  "He",
  "To"
], Fe = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], Yu = (t, e = "letters") => {
  const s = (e === "solfeggio" ? We : e === "indian" ? Le : e === "german" ? Ie : e === "byzantine" ? He : e === "japanese" ? Ve : Fe)[t % 12], r = Math.floor(t / 12) - 1;
  return s + r;
};
function Zu(t) {
  var e = {};
  return t.filter(function(n) {
    return e.hasOwn(n) ? !1 : e[n] = !0;
  });
}
function ta(t) {
  return t.sort().filter(function(e, n, s) {
    return !n || e != s[n - 1];
  });
}
function De(t) {
  return t.sort((e, n) => e.compare(n)).filter(function(e, n, s) {
    return !n || e.ne(s[n - 1]);
  });
}
function Ge(t) {
  const e = new TextEncoder().encode(t);
  return btoa(String.fromCharCode(...e));
}
function Qe(t) {
  const e = new Uint8Array(
    atob(t).split("").map((s) => s.charCodeAt(0))
  );
  return new TextDecoder().decode(e);
}
function ea(t) {
  return encodeURIComponent(Ge(t));
}
function na(t) {
  return Qe(decodeURIComponent(t));
}
function Ue(t, e) {
  return Array.isArray(t) ? t.map(e) : Object.fromEntries(Object.entries(t).map(([n, s], r) => [n, e(s, n, r)]));
}
function Pt(t, e) {
  return t / e;
}
class Ke {
  constructor({
    getTargetClockTime: e = Xe,
    weight: n = 16,
    offsetDelta: s = 5e-3,
    checkAfterTime: r = 2,
    resetAfterTime: o = 8
  }) {
    this.offsetTime, this.timeAtPrevOffsetSample, this.prevOffsetTimes = [], this.getTargetClockTime = e, this.weight = n, this.offsetDelta = s, this.checkAfterTime = r, this.resetAfterTime = o, this.reset = () => {
      this.prevOffsetTimes = [], this.offsetTime = null, this.timeAtPrevOffsetSample = null;
    };
  }
  calculateOffset(e) {
    const n = this.getTargetClockTime(), s = n - this.timeAtPrevOffsetSample, r = n - e;
    if (s > this.resetAfterTime && this.reset(), this.offsetTime == null && (this.offsetTime = r), this.prevOffsetTimes.push(r), this.prevOffsetTimes.length > this.weight && this.prevOffsetTimes.shift(), this.timeAtPrevOffsetSample == null || s > this.checkAfterTime) {
      this.timeAtPrevOffsetSample = n;
      const o = Me(this.prevOffsetTimes);
      Math.abs(o - this.offsetTime) > this.offsetDelta && (this.offsetTime = o);
    }
    return this.offsetTime;
  }
  calculateTimestamp(e, n) {
    return this.calculateOffset(e) + n;
  }
}
function sa() {
  return performance.now() * 1e-3;
}
function Xe() {
  return Date.now() * 1e-3;
}
const Ye = /* @__PURE__ */ new Map([
  ["control", "Control"],
  ["ctrl", "Control"],
  ["alt", "Alt"],
  ["shift", "Shift"],
  ["down", "ArrowDown"],
  ["up", "ArrowUp"],
  ["left", "ArrowLeft"],
  ["right", "ArrowRight"]
]);
let Z;
function Ze() {
  if (Z == null) {
    if (typeof window > "u")
      return;
    Z = {}, window.addEventListener("keydown", (t) => {
      Z[t.key] = !0;
    }), window.addEventListener("keyup", (t) => {
      Z[t.key] = !1;
    });
  }
  return { ...Z };
}
function Qt(t, e = !1) {
  return typeof t == "object" ? e ? JSON.stringify(t).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(t) : t;
}
T.prototype.sam = function() {
  return this.floor();
};
T.prototype.nextSam = function() {
  return this.sam().add(1);
};
T.prototype.wholeCycle = function() {
  return new C(this.sam(), this.nextSam());
};
T.prototype.cyclePos = function() {
  return this.sub(this.sam());
};
T.prototype.lt = function(t) {
  return this.compare(t) < 0;
};
T.prototype.gt = function(t) {
  return this.compare(t) > 0;
};
T.prototype.lte = function(t) {
  return this.compare(t) <= 0;
};
T.prototype.gte = function(t) {
  return this.compare(t) >= 0;
};
T.prototype.eq = function(t) {
  return this.compare(t) == 0;
};
T.prototype.ne = function(t) {
  return this.compare(t) != 0;
};
T.prototype.max = function(t) {
  return this.gt(t) ? this : t;
};
T.prototype.maximum = function(...t) {
  return t = t.map((e) => new T(e)), t.reduce((e, n) => n.max(e), this);
};
T.prototype.min = function(t) {
  return this.lt(t) ? this : t;
};
T.prototype.mulmaybe = function(t) {
  return t !== void 0 ? this.mul(t) : void 0;
};
T.prototype.divmaybe = function(t) {
  return t !== void 0 ? this.div(t) : void 0;
};
T.prototype.addmaybe = function(t) {
  return t !== void 0 ? this.add(t) : void 0;
};
T.prototype.submaybe = function(t) {
  return t !== void 0 ? this.sub(t) : void 0;
};
T.prototype.show = function() {
  return this.s * this.n + "/" + this.d;
};
T.prototype.or = function(t) {
  return this.eq(0) ? t : this;
};
const d = (t) => T(t), tn = (...t) => {
  if (t = ot(t), t.length !== 0)
    return t.reduce((e, n) => e.gcd(n), d(1));
}, U = (...t) => {
  if (t = ot(t), t.length === 0)
    return;
  const e = t.pop();
  return t.reduce(
    (n, s) => n === void 0 || s === void 0 ? void 0 : n.lcm(s),
    e
  );
};
d._original = T;
class C {
  constructor(e, n) {
    this.begin = d(e), this.end = d(n);
  }
  get spanCycles() {
    const e = [];
    var n = this.begin;
    const s = this.end, r = s.sam();
    if (n.equals(s))
      return [new C(n, s)];
    for (; s.gt(n); ) {
      if (n.sam().equals(r)) {
        e.push(new C(n, this.end));
        break;
      }
      const o = n.nextSam();
      e.push(new C(n, o)), n = o;
    }
    return e;
  }
  get duration() {
    return this.end.sub(this.begin);
  }
  cycleArc() {
    const e = this.begin.cyclePos(), n = e.add(this.duration);
    return new C(e, n);
  }
  withTime(e) {
    return new C(e(this.begin), e(this.end));
  }
  withEnd(e) {
    return new C(this.begin, e(this.end));
  }
  withCycle(e) {
    const n = this.begin.sam(), s = n.add(e(this.begin.sub(n))), r = n.add(e(this.end.sub(n)));
    return new C(s, r);
  }
  intersection(e) {
    const n = this.begin.max(e.begin), s = this.end.min(e.end);
    if (!n.gt(s) && !(n.equals(s) && (n.equals(this.end) && this.begin.lt(this.end) || n.equals(e.end) && e.begin.lt(e.end))))
      return new C(n, s);
  }
  intersection_e(e) {
    const n = this.intersection(e);
    if (n == null)
      throw "TimeSpans do not intersect";
    return n;
  }
  midpoint() {
    return this.begin.add(this.duration.div(d(2)));
  }
  equals(e) {
    return this.begin.equals(e.begin) && this.end.equals(e.end);
  }
  show() {
    return this.begin.show() + " → " + this.end.show();
  }
}
class x {
  /*
        Event class, representing a value active during the timespan
        'part'. This might be a fragment of an event, in which case the
        timespan will be smaller than the 'whole' timespan, otherwise the
        two timespans will be the same. The 'part' must never extend outside of the
        'whole'. If the event represents a continuously changing value
        then the whole will be returned as None, in which case the given
        value will have been sampled from the point halfway between the
        start and end of the 'part' timespan.
        The context is to store a list of source code locations causing the event.
  
        The word 'Event' is more or less a reserved word in javascript, hence this
        class is named called 'Hap'.
        */
  constructor(e, n, s, r = {}, o = !1) {
    this.whole = e, this.part = n, this.value = s, this.context = r, this.stateful = o, o && console.assert(typeof this.value == "function", "Stateful values must be functions");
  }
  get duration() {
    let e;
    return typeof this.value?.duration == "number" ? e = d(this.value.duration) : e = this.whole.end.sub(this.whole.begin), typeof this.value?.clip == "number" ? e.mul(this.value.clip) : e;
  }
  get endClipped() {
    return this.whole.begin.add(this.duration);
  }
  isActive(e) {
    return this.whole.begin <= e && this.endClipped >= e;
  }
  isInPast(e) {
    return e > this.endClipped;
  }
  isInNearPast(e, n) {
    return n - e <= this.endClipped;
  }
  isInFuture(e) {
    return e < this.whole.begin;
  }
  isInNearFuture(e, n) {
    return n < this.whole.begin && n > this.whole.begin - e;
  }
  isWithinTime(e, n) {
    return this.whole.begin <= n && this.endClipped >= e;
  }
  wholeOrPart() {
    return this.whole ? this.whole : this.part;
  }
  withSpan(e) {
    const n = this.whole ? e(this.whole) : void 0;
    return new x(n, e(this.part), this.value, this.context);
  }
  withValue(e) {
    return new x(this.whole, this.part, e(this.value), this.context);
  }
  hasOnset() {
    return this.whole != null && this.whole.begin.equals(this.part.begin);
  }
  hasTag(e) {
    return this.context.tags?.includes(e);
  }
  resolveState(e) {
    if (this.stateful && this.hasOnset()) {
      console.log("stateful");
      const n = this.value, [s, r] = n(e);
      return [s, new x(this.whole, this.part, r, this.context, !1)];
    }
    return [e, this];
  }
  spanEquals(e) {
    return this.whole == null && e.whole == null || this.whole.equals(e.whole);
  }
  equals(e) {
    return this.spanEquals(e) && this.part.equals(e.part) && // TODO would == be better ??
    this.value === e.value;
  }
  show(e = !1) {
    const n = typeof this.value == "object" ? e ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value;
    var s = "";
    if (this.whole == null)
      s = "~" + this.part.show;
    else {
      var r = this.whole.begin.equals(this.part.begin) && this.whole.end.equals(this.part.end);
      this.whole.begin.equals(this.part.begin) || (s = this.whole.begin.show() + " ⇜ "), r || (s += "("), s += this.part.show(), r || (s += ")"), this.whole.end.equals(this.part.end) || (s += " ⇝ " + this.whole.end.show());
    }
    return "[ " + s + " | " + n + " ]";
  }
  showWhole(e = !1) {
    return `${this.whole == null ? "~" : this.whole.show()}: ${Qt(this.value, e)}`;
  }
  combineContext(e) {
    const n = this;
    return { ...n.context, ...e.context, locations: (n.context.locations || []).concat(e.context.locations || []) };
  }
  setContext(e) {
    return new x(this.whole, this.part, this.value, e);
  }
  ensureObjectValue() {
    if (typeof this.value != "object")
      throw new Error(
        `expected hap.value to be an object, but got "${this.value}". Hint: append .note() or .s() to the end`,
        "error"
      );
  }
}
class nt {
  constructor(e, n = {}) {
    this.span = e, this.controls = n;
  }
  // Returns new State with different span
  setSpan(e) {
    return new nt(e, this.controls);
  }
  withSpan(e) {
    return this.setSpan(e(this.span));
  }
  // Returns new State with different controls
  setControls(e) {
    return new nt(this.span, e);
  }
}
function en(t, e, n) {
  if (e?.value !== void 0 && Object.keys(e).length === 1)
    return z("[warn]: Can't do arithmetic on control pattern."), t;
  const s = Object.keys(t).filter((r) => Object.keys(e).includes(r));
  return Object.assign({}, t, e, Object.fromEntries(s.map((r) => [r, n(t[r], e[r])])));
}
g((t, e) => t * e);
g((t, e) => e.map(t));
function nn(t, e = 60) {
  let n = 0, s = d(0), r = [""], o = "";
  for (; r[0].length < e; ) {
    const c = t.queryArc(n, n + 1), u = c.filter((m) => m.hasOnset()).map((m) => m.duration), a = tn(...u), p = a.inverse();
    r = r.map((m) => m + "|"), o += "|";
    for (let m = 0; m < p; m++) {
      const [y, b] = [s, s.add(a)], w = c.filter((k) => k.whole.begin.lte(y) && k.whole.end.gte(b)), v = w.length - r.length;
      v > 0 && (r = r.concat(Array(v).fill(o))), r = r.map((k, E) => {
        const M = w[E];
        if (M) {
          const A = M.whole.begin.eq(y) ? "" + M.value : "-";
          return k + A;
        }
        return k + ".";
      }), o += ".", s = s.add(a);
    }
    n++;
  }
  return r.join(`
`);
}
let gt, L = !0;
const ra = function(t) {
  L = !!t;
}, oa = (t) => gt = t;
class f {
  /**
   * Create a pattern. As an end user, you will most likely not create a Pattern directly.
   *
   * @param {function} query - The function that maps a `State` to an array of `Hap`.
   * @noAutocomplete
   */
  constructor(e, n = void 0) {
    this.query = e, this._Pattern = !0, this._steps = n;
  }
  get _steps() {
    return this.__steps;
  }
  set _steps(e) {
    this.__steps = e === void 0 ? void 0 : d(e);
  }
  setSteps(e) {
    return this._steps = e, this;
  }
  withSteps(e) {
    return L ? new f(this.query, this._steps === void 0 ? void 0 : e(this._steps)) : this;
  }
  get hasSteps() {
    return this._steps !== void 0;
  }
  //////////////////////////////////////////////////////////////////////
  // Haskell-style functor, applicative and monadic operations
  /**
   * Returns a new pattern, with the function applied to the value of
   * each hap. It has the alias `fmap`.
   * @synonyms fmap
   * @param {Function} func to to apply to the value
   * @returns Pattern
   * @example
   * "0 1 2".withValue(v => v + 10).log()
   */
  withValue(e) {
    const n = new f((s) => this.query(s).map((r) => r.withValue(e)));
    return n._steps = this._steps, n;
  }
  // runs func on query state
  withState(e) {
    return this.withHaps((n, s) => (e(s), n));
  }
  /**
   * see `withValue`
   * @noAutocomplete
   */
  fmap(e) {
    return this.withValue(e);
  }
  /**
   * Assumes 'this' is a pattern of functions, and given a function to
   * resolve wholes, applies a given pattern of values to that
   * pattern of functions.
   * @param {Function} whole_func
   * @param {Function} func
   * @noAutocomplete
   * @returns Pattern
   */
  appWhole(e, n) {
    const s = this, r = function(o) {
      const c = s.query(o), u = n.query(o), a = function(p, m) {
        const y = p.part.intersection(m.part);
        if (y != null)
          return new x(
            e(p.whole, m.whole),
            y,
            p.value(m.value),
            m.combineContext(p)
          );
      };
      return F(
        c.map((p) => ot(u.map((m) => a(p, m))))
      );
    };
    return new f(r);
  }
  /**
   * When this method is called on a pattern of functions, it matches its haps
   * with those in the given pattern of values.  A new pattern is returned, with
   * each matching value applied to the corresponding function.
   *
   * In this `_appBoth` variant, where timespans of the function and value haps
   * are not the same but do intersect, the resulting hap has a timespan of the
   * intersection. This applies to both the part and the whole timespan.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appBoth(e) {
    const n = this, s = function(o, c) {
      if (!(o == null || c == null))
        return o.intersection_e(c);
    }, r = n.appWhole(s, e);
    return L && (r._steps = U(e._steps, n._steps)), r;
  }
  /**
   * As with `appBoth`, but the `whole` timespan is not the intersection,
   * but the timespan from the function of patterns that this method is called
   * on. In practice, this means that the pattern structure, including onsets,
   * are preserved from the pattern of functions (often referred to as the left
   * hand or inner pattern).
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appLeft(e) {
    const n = this, s = function(o) {
      const c = [];
      for (const u of n.query(o)) {
        const a = e.query(o.setSpan(u.wholeOrPart()));
        for (const p of a) {
          const m = u.whole, y = u.part.intersection(p.part);
          if (y) {
            const b = u.value(p.value), w = p.combineContext(u), v = new x(m, y, b, w);
            c.push(v);
          }
        }
      }
      return c;
    }, r = new f(s);
    return r._steps = this._steps, r;
  }
  /**
   * As with `appLeft`, but `whole` timespans are instead taken from the
   * pattern of values, i.e. structure is preserved from the right hand/outer
   * pattern.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appRight(e) {
    const n = this, s = function(o) {
      const c = [];
      for (const u of e.query(o)) {
        const a = n.query(o.setSpan(u.wholeOrPart()));
        for (const p of a) {
          const m = u.whole, y = p.part.intersection(u.part);
          if (y) {
            const b = p.value(u.value), w = u.combineContext(p), v = new x(m, y, b, w);
            c.push(v);
          }
        }
      }
      return c;
    }, r = new f(s);
    return r._steps = e._steps, r;
  }
  bindWhole(e, n) {
    const s = this, r = function(o) {
      const c = function(a, p) {
        return new x(
          e(a.whole, p.whole),
          p.part,
          p.value,
          Object.assign({}, a.context, p.context, {
            locations: (a.context.locations || []).concat(p.context.locations || [])
          })
        );
      }, u = function(a) {
        return n(a.value).query(o.setSpan(a.part)).map((p) => c(a, p));
      };
      return F(s.query(o).map((a) => u(a)));
    };
    return new f(r);
  }
  bind(e) {
    const n = function(s, r) {
      if (!(s == null || r == null))
        return s.intersection_e(r);
    };
    return this.bindWhole(n, e);
  }
  join() {
    return this.bind(tt);
  }
  outerBind(e) {
    return this.bindWhole((n) => n, e).setSteps(this._steps);
  }
  outerJoin() {
    return this.outerBind(tt);
  }
  innerBind(e) {
    return this.bindWhole((n, s) => s, e);
  }
  innerJoin() {
    return this.innerBind(tt);
  }
  // Flatterns patterns of patterns, by retriggering/resetting inner patterns at onsets of outer pattern haps
  resetJoin(e = !1) {
    const n = this;
    return new f((s) => n.discreteOnly().query(s).map((r) => r.value.late(e ? r.whole.begin : r.whole.begin.cyclePos()).query(s).map(
      (o) => new x(
        // Supports continuous haps in the inner pattern
        o.whole ? o.whole.intersection(r.whole) : void 0,
        o.part.intersection(r.part),
        o.value
      ).setContext(r.combineContext(o))
    ).filter((o) => o.part)).flat());
  }
  restartJoin() {
    return this.resetJoin(!0);
  }
  // Like the other joins above, joins a pattern of patterns of values, into a flatter
  // pattern of values. In this case it takes whole cycles of the inner pattern to fit each event
  // in the outer pattern.
  squeezeJoin() {
    const e = this;
    function n(s) {
      const r = e.discreteOnly().query(s);
      function o(u) {
        const p = u.value._focusSpan(u.wholeOrPart()).query(s.setSpan(u.part));
        function m(y, b) {
          let w;
          if (b.whole && y.whole && (w = b.whole.intersection(y.whole), !w))
            return;
          const v = b.part.intersection(y.part);
          if (!v)
            return;
          const k = b.combineContext(y);
          return new x(w, v, b.value, k);
        }
        return p.map((y) => m(u, y));
      }
      return F(r.map(o)).filter((u) => u);
    }
    return new f(n);
  }
  squeezeBind(e) {
    return this.fmap(e).squeezeJoin();
  }
  polyJoin = function() {
    const e = this;
    return e.fmap((n) => n.extend(e._steps.div(n._steps))).outerJoin();
  };
  polyBind(e) {
    return this.fmap(e).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // Utility methods mainly for internal use
  /**
   * Query haps inside the given time span.
   *
   * @param {Fraction | number} begin from time
   * @param {Fraction | number} end to time
   * @returns Hap[]
   * @example
   * const pattern = sequence('a', ['b', 'c'])
   * const haps = pattern.queryArc(0, 1)
   * console.log(haps)
   * silence
   * @noAutocomplete
   */
  queryArc(e, n, s = {}) {
    try {
      return this.query(new nt(new C(e, n), s));
    } catch (r) {
      return z(`[query]: ${r.message}`, "error"), [];
    }
  }
  /**
   * Returns a new pattern, with queries split at cycle boundaries. This makes
   * some calculations easier to express, as all haps are then constrained to
   * happen within a cycle.
   * @returns Pattern
   * @noAutocomplete
   */
  splitQueries() {
    const e = this, n = (s) => F(s.span.spanCycles.map((r) => e.query(s.setSpan(r))));
    return new f(n);
  }
  /**
   * Returns a new pattern, where the given function is applied to the query
   * timespan before passing it to the original pattern.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQuerySpan(e) {
    return new f((n) => this.query(n.withSpan(e)));
  }
  withQuerySpanMaybe(e) {
    const n = this;
    return new f((s) => {
      const r = s.withSpan(e);
      return r.span ? n.query(r) : [];
    });
  }
  /**
   * As with `withQuerySpan`, but the function is applied to both the
   * begin and end time of the query timespan.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQueryTime(e) {
    return new f((n) => this.query(n.withSpan((s) => s.withTime(e))));
  }
  /**
   * Similar to `withQuerySpan`, but the function is applied to the timespans
   * of all haps returned by pattern queries (both `part` timespans, and where
   * present, `whole` timespans).
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHapSpan(e) {
    return new f((n) => this.query(n).map((s) => s.withSpan(e)));
  }
  /**
   * As with `withHapSpan`, but the function is applied to both the
   * begin and end time of the hap timespans.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withHapTime(e) {
    return this.withHapSpan((n) => n.withTime(e));
  }
  /**
   * Returns a new pattern with the given function applied to the list of haps returned by every query.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHaps(e) {
    const n = new f((s) => e(this.query(s), s));
    return n._steps = this._steps, n;
  }
  /**
   * As with `withHaps`, but applies the function to every hap, rather than every list of haps.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHap(e) {
    return this.withHaps((n) => n.map(e));
  }
  /**
   * Returns a new pattern with the context field set to every hap set to the given value.
   * @param {*} context
   * @returns Pattern
   * @noAutocomplete
   */
  setContext(e) {
    return this.withHap((n) => n.setContext(e));
  }
  /**
   * Returns a new pattern with the given function applied to the context field of every hap.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withContext(e) {
    const n = this.withHap((s) => s.setContext(e(s.context)));
    return this.__pure !== void 0 && (n.__pure = this.__pure, n.__pure_loc = this.__pure_loc), n;
  }
  /**
   * Returns a new pattern with the context field of every hap set to an empty object.
   * @returns Pattern
   * @noAutocomplete
   */
  stripContext() {
    return this.withHap((e) => e.setContext({}));
  }
  /**
   * Returns a new pattern with the given location information added to the
   * context of every hap.
   * @param {Number} start start offset
   * @param {Number} end end offset
   * @returns Pattern
   * @noAutocomplete
   */
  withLoc(e, n) {
    const s = {
      start: e,
      end: n
    }, r = this.withContext((o) => {
      const c = (o.locations || []).concat([s]);
      return { ...o, locations: c };
    });
    return this.__pure && (r.__pure = this.__pure, r.__pure_loc = s), r;
  }
  /**
   * Returns a new Pattern, which only returns haps that meet the given test.
   * @param {Function} hap_test - a function which returns false for haps to be removed from the pattern
   * @returns Pattern
   * @noAutocomplete
   */
  filterHaps(e) {
    return new f((n) => this.query(n).filter(e));
  }
  /**
   * As with `filterHaps`, but the function is applied to values
   * inside haps.
   * @param {Function} value_test
   * @returns Pattern
   * @noAutocomplete
   */
  filterValues(e) {
    return new f((n) => this.query(n).filter((s) => e(s.value))).setSteps(this._steps);
  }
  /**
   * Returns a new pattern, with haps containing undefined values removed from
   * query results.
   * @returns Pattern
   * @noAutocomplete
   */
  removeUndefineds() {
    return this.filterValues((e) => e != null);
  }
  /**
   * Returns a new pattern, with all haps without onsets filtered out. A hap
   * with an onset is one with a `whole` timespan that begins at the same time
   * as its `part` timespan.
   * @returns Pattern
   * @noAutocomplete
   */
  onsetsOnly() {
    return this.filterHaps((e) => e.hasOnset());
  }
  /**
   * Returns a new pattern, with 'continuous' haps (those without 'whole'
   * timespans) removed from query results.
   * @returns Pattern
   * @noAutocomplete
   */
  discreteOnly() {
    return this.filterHaps((e) => e.whole);
  }
  /**
   * Combines adjacent haps with the same value and whole.  Only
   * intended for use in tests.
   * @noAutocomplete
   */
  defragmentHaps() {
    return this.discreteOnly().withHaps((n) => {
      const s = [];
      for (var r = 0; r < n.length; ++r) {
        for (var o = !0, c = n[r]; o; ) {
          const p = JSON.stringify(n[r].value);
          for (var u = !1, a = r + 1; a < n.length; a++) {
            const m = n[a];
            if (c.whole.equals(m.whole)) {
              if (c.part.begin.eq(m.part.end)) {
                if (p === JSON.stringify(m.value)) {
                  c = new x(c.whole, new C(m.part.begin, c.part.end), c.value), n.splice(a, 1), u = !0;
                  break;
                }
              } else if (m.part.begin.eq(c.part.end) && p == JSON.stringify(m.value)) {
                c = new x(c.whole, new C(c.part.begin, m.part.end), c.value), n.splice(a, 1), u = !0;
                break;
              }
            }
          }
          o = u;
        }
        s.push(c);
      }
      return s;
    });
  }
  /**
   * Queries the pattern for the first cycle, returning Haps. Mainly of use when
   * debugging a pattern.
   * @param {Boolean} with_context - set to true, otherwise the context field
   * will be stripped from the resulting haps.
   * @returns [Hap]
   * @noAutocomplete
   */
  firstCycle(e = !1) {
    var n = this;
    return e || (n = n.stripContext()), n.query(new nt(new C(d(0), d(1))));
  }
  /**
   * Accessor for a list of values returned by querying the first cycle.
   * @noAutocomplete
   */
  get firstCycleValues() {
    return this.firstCycle().map((e) => e.value);
  }
  /**
   * More human-readable version of the `firstCycleValues` accessor.
   * @noAutocomplete
   */
  get showFirstCycle() {
    return this.firstCycle().map(
      (e) => `${e.value}: ${e.whole.begin.toFraction()} - ${e.whole.end.toFraction()}`
    );
  }
  /**
   * Returns a new pattern, which returns haps sorted in temporal order. Mainly
   * of use when comparing two patterns for equality, in tests.
   * @returns Pattern
   * @noAutocomplete
   */
  sortHapsByPart() {
    return this.withHaps(
      (e) => e.sort(
        (n, s) => n.part.begin.sub(s.part.begin).or(n.part.end.sub(s.part.end)).or(n.whole.begin.sub(s.whole.begin).or(n.whole.end.sub(s.whole.end)))
      )
    );
  }
  asNumber() {
    return this.fmap(Ft);
  }
  //////////////////////////////////////////////////////////////////////
  // Operators - see 'make composers' later..
  _opIn(e, n) {
    return this.fmap(n).appLeft(h(e));
  }
  _opOut(e, n) {
    return this.fmap(n).appRight(h(e));
  }
  _opMix(e, n) {
    return this.fmap(n).appBoth(h(e));
  }
  _opSqueeze(e, n) {
    const s = h(e);
    return this.fmap((r) => s.fmap((o) => n(r)(o))).squeezeJoin();
  }
  _opSqueezeOut(e, n) {
    const s = this;
    return h(e).fmap((o) => s.fmap((c) => n(c)(o))).squeezeJoin();
  }
  _opReset(e, n) {
    return h(e).fmap((r) => this.fmap((o) => n(o)(r))).resetJoin();
  }
  _opRestart(e, n) {
    return h(e).fmap((r) => this.fmap((o) => n(o)(r))).restartJoin();
  }
  _opPoly(e, n) {
    const s = h(e);
    return this.fmap((r) => s.fmap((o) => n(o)(r))).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // End-user methods.
  // Those beginning with an underscore (_) are 'patternified',
  // i.e. versions are created without the underscore, that are
  // magically transformed to accept patterns for all their arguments.
  //////////////////////////////////////////////////////////////////////
  // Methods without corresponding toplevel functions
  /**
   * Layers the result of the given function(s). Like `superimpose`, but without the original pattern:
   * @name layer
   * @memberof Pattern
   * @synonyms apply
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .layer(x=>x.add("0,2"))
   *   .scale('C minor').note()
   */
  layer(...e) {
    return B(...e.map((n) => n(this)));
  }
  /**
   * Superimposes the result of the given function(s) on top of the original pattern:
   * @name superimpose
   * @memberof Pattern
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .superimpose(x=>x.add(2))
   *   .scale('C minor').note()
   */
  superimpose(...e) {
    return this.stack(...e.map((n) => n(this)));
  }
  //////////////////////////////////////////////////////////////////////
  // Multi-pattern functions
  stack(...e) {
    return B(this, ...e);
  }
  sequence(...e) {
    return D(this, ...e);
  }
  seq(...e) {
    return D(this, ...e);
  }
  cat(...e) {
    return pn(this, ...e);
  }
  fastcat(...e) {
    return N(this, ...e);
  }
  slowcat(...e) {
    return K(this, ...e);
  }
  //////////////////////////////////////////////////////////////////////
  // Context methods - ones that deal with metadata
  onTrigger(e, n = !0) {
    return this.withHap(
      (s) => s.setContext({
        ...s.context,
        onTrigger: (...r) => {
          s.context.onTrigger?.(...r), e(...r);
        },
        // if dominantTrigger is set to true, the default output (webaudio) will be disabled
        // when using multiple triggers, you cannot flip this flag to false again!
        // example: x.csound('CooLSynth').log() as well as x.log().csound('CooLSynth') should work the same
        dominantTrigger: s.context.dominantTrigger || n
      })
    );
  }
  /**
   * Writes the content of the current event to the console (visible in the side menu).
   * @name log
   * @memberof Pattern
   * @example
   * s("bd sd").log()
   */
  log(e = (s) => `[hap] ${s.showWhole(!0)}`, n = (s) => ({ hap: s })) {
    return this.onTrigger((...s) => {
      z(e(...s), void 0, n(...s));
    }, !1);
  }
  /**
   * A simplified version of `log` which writes all "values" (various configurable parameters)
   * within the event to the console (visible in the side menu).
   * @name logValues
   * @memberof Pattern
   * @example
   * s("bd sd").gain("0.25 0.5 1").n("2 1 0").logValues()
   */
  logValues(e = (n) => `[hap] ${Qt(n, !0)}`) {
    return this.log((n) => e(n.value));
  }
  //////////////////////////////////////////////////////////////////////
  // Visualisation
  drawLine() {
    return console.log(nn(this)), this;
  }
  //////////////////////////////////////////////////////////////////////
  // methods relating to breaking patterns into subcycles
  // Breaks a pattern into a pattern of patterns, according to the structure of the given binary pattern.
  unjoin(e, n = tt) {
    return e.withHap(
      (s) => s.withValue((r) => r ? n(this.ribbon(s.whole.begin, s.whole.duration)) : this)
    );
  }
  /**
   * Breaks a pattern into pieces according to the structure of a given pattern.
   * True values in the given pattern cause the corresponding subcycle of the
   * source pattern to be looped, and for an (optional) given function to be
   * applied. False values result in the corresponding part of the source pattern
   * to be played unchanged.
   * @name into
   * @memberof Pattern
   * @example
   * sound("bd sd ht lt").into("1 0", hurry(2))
   */
  into(e, n) {
    return this.unjoin(e, n).innerJoin();
  }
}
function sn(t, e) {
  let n = [];
  return e.forEach((s) => {
    const r = n.findIndex(([o]) => t(s, o));
    r === -1 ? n.push([s]) : n[r].push(s);
  }), n;
}
const rn = (t, e) => t.spanEquals(e);
f.prototype.collect = function() {
  return this.withHaps(
    (t) => sn(rn, t).map((e) => new x(e[0].whole, e[0].part, e, {}))
  );
};
const ia = l("arpWith", (t, e) => e.collect().fmap((n) => h(t(n))).innerJoin().withHap((n) => new x(n.whole, n.part, n.value.value, n.combineContext(n.value)))), ca = l(
  "arp",
  (t, e) => e.arpWith((n) => h(t).fmap((s) => n[s % n.length])),
  !1
);
function ut(t) {
  return !Array.isArray(t) && typeof t == "object";
}
function on(t, e, n) {
  return ut(t) || ut(e) ? (ut(t) || (t = { value: t }), ut(e) || (e = { value: e }), en(t, e, n)) : n(t, e);
}
(function() {
  const t = {
    set: [(n, s) => s],
    keep: [(n) => n],
    keepif: [(n, s) => s ? n : void 0],
    // numerical functions
    /**
     *
     * Assumes a pattern of numbers. Adds the given number to each item in the pattern.
     * @name add
     * @memberof Pattern
     * @example
     * // Here, the triad 0, 2, 4 is shifted by different amounts
     * n("0 2 4".add("<0 3 4 0>")).scale("C:major")
     * // Without add, the equivalent would be:
     * // n("<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>").scale("C:major")
     * @example
     * // You can also use add with notes:
     * note("c3 e3 g3".add("<0 5 7 0>"))
     * // Behind the scenes, the notes are converted to midi numbers:
     * // note("48 52 55".add("<0 5 7 0>"))
     */
    add: [$((n, s) => n + s)],
    // support string concatenation
    /**
     *
     * Like add, but the given numbers are subtracted.
     * @name sub
     * @memberof Pattern
     * @example
     * n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
     * // See add for more information.
     */
    sub: [$((n, s) => n - s)],
    /**
     *
     * Multiplies each number by the given factor.
     * @name mul
     * @memberof Pattern
     * @example
     * "<1 1.5 [1.66, <2 2.33>]>*4".mul(150).freq()
     */
    mul: [$((n, s) => n * s)],
    /**
     *
     * Divides each number by the given factor.
     * @name div
     * @memberof Pattern
     */
    div: [$((n, s) => n / s)],
    mod: [$(pt)],
    pow: [$(Math.pow)],
    log2: [$(Math.log2)],
    band: [$((n, s) => n & s)],
    bor: [$((n, s) => n | s)],
    bxor: [$((n, s) => n ^ s)],
    blshift: [$((n, s) => n << s)],
    brshift: [$((n, s) => n >> s)],
    // TODO - force numerical comparison if both look like numbers?
    lt: [(n, s) => n < s],
    gt: [(n, s) => n > s],
    lte: [(n, s) => n <= s],
    gte: [(n, s) => n >= s],
    eq: [(n, s) => n == s],
    eqt: [(n, s) => n === s],
    ne: [(n, s) => n != s],
    net: [(n, s) => n !== s],
    and: [(n, s) => n && s],
    or: [(n, s) => n || s],
    //  bitwise ops
    func: [(n, s) => s(n)]
  }, e = ["In", "Out", "Mix", "Squeeze", "SqueezeOut", "Reset", "Restart", "Poly"];
  for (const [n, [s, r]] of Object.entries(t)) {
    f.prototype["_" + n] = function(o) {
      return this.fmap((c) => s(c, o));
    }, Object.defineProperty(f.prototype, n, {
      // a getter that returns a function, so 'pat' can be
      // accessed by closures that are methods of that function..
      get: function() {
        const o = this, c = (...u) => o[n].in(...u);
        for (const u of e)
          c[u.toLowerCase()] = function(...a) {
            var p = o;
            a = D(a), r && (p = r(p), a = r(a));
            var m;
            return n === "keepif" ? (m = p["_op" + u](a, (y) => (b) => s(y, b)), m = m.removeUndefineds()) : m = p["_op" + u](a, (y) => (b) => on(y, b, s)), m;
          };
        return c.squeezein = c.squeeze, c;
      }
    });
    for (const o of e)
      f.prototype[o.toLowerCase()] = function(...c) {
        return this.set[o.toLowerCase()](c);
      };
  }
  f.prototype.struct = function(...n) {
    return this.keepif.out(...n);
  }, f.prototype.structAll = function(...n) {
    return this.keep.out(...n);
  }, f.prototype.mask = function(...n) {
    return this.keepif.in(...n);
  }, f.prototype.maskAll = function(...n) {
    return this.keep.in(...n);
  }, f.prototype.reset = function(...n) {
    return this.keepif.reset(...n);
  }, f.prototype.resetAll = function(...n) {
    return this.keep.reset(...n);
  }, f.prototype.restart = function(...n) {
    return this.keepif.restart(...n);
  }, f.prototype.restartAll = function(...n) {
    return this.keep.restart(...n);
  };
})();
const ua = B, aa = B, la = St, it = (t) => new f(() => [], t), S = it(1), R = it(0);
function P(t) {
  function e(s) {
    return s.span.spanCycles.map((r) => new x(d(r.begin).wholeCycle(), r, t));
  }
  const n = new f(e, 1);
  return n.__pure = t, n;
}
function Ut(t) {
  return t instanceof f || t?._Pattern;
}
function h(t) {
  return Ut(t) ? t : gt && typeof t == "string" ? gt(t) : P(t);
}
function cn(t) {
  let e = P([]);
  for (const n of t)
    e = e.bind((s) => n.fmap((r) => s.concat([r])));
  return e;
}
function B(...t) {
  t = t.map((s) => Array.isArray(s) ? D(...s) : h(s));
  const e = (s) => F(t.map((r) => r.query(s))), n = new f(e);
  return L && (n._steps = U(...t.map((s) => s._steps))), n;
}
function kt(t, e) {
  if (e = e.map((o) => Array.isArray(o) ? D(...o) : h(o)), e.length === 0)
    return S;
  if (e.length === 1)
    return e[0];
  const [n, ...s] = e.map((o) => o._steps), r = L ? n.maximum(...s) : void 0;
  return B(...t(r, e));
}
function un(...t) {
  return kt(
    (e, n) => n.map((s) => s._steps.eq(e) ? s : j(s, it(e.sub(s._steps)))),
    t
  );
}
function an(...t) {
  return kt(
    (e, n) => n.map((s) => s._steps.eq(e) ? s : j(it(e.sub(s._steps)), s)),
    t
  );
}
function ln(...t) {
  return kt(
    (e, n) => n.map((s) => {
      if (s._steps.eq(e))
        return s;
      const r = it(e.sub(s._steps).div(2));
      return j(r, s, r);
    }),
    t
  );
}
function pa(t, ...e) {
  const [n, ...s] = e.map((c) => c._steps), r = n.maximum(...s), o = {
    centre: ln,
    left: un,
    right: an,
    expand: B,
    repeat: (...c) => St(...c).steps(r)
  };
  return t.inhabit(o).fmap((c) => c(...e)).innerJoin().setSteps(r);
}
function K(...t) {
  if (t = t.map((s) => Array.isArray(s) ? N(...s) : h(s)), t.length == 1)
    return t[0];
  const e = function(s) {
    const r = s.span, o = pt(r.begin.sam(), t.length), c = t[o];
    if (!c)
      return [];
    const u = r.begin.floor().sub(r.begin.div(t.length).floor());
    return c.withHapTime((a) => a.add(u)).query(s.setSpan(r.withTime((a) => a.sub(u))));
  }, n = L ? U(...t.map((s) => s._steps)) : void 0;
  return new f(e).splitQueries().setSteps(n);
}
function Kt(...t) {
  t = t.map(h);
  const e = function(n) {
    const s = Math.floor(n.span.begin) % t.length;
    return t[s]?.query(n) || [];
  };
  return new f(e).splitQueries();
}
function pn(...t) {
  return K(...t);
}
function fa(...t) {
  const e = t.reduce((n, [s]) => n + s, 0);
  return t = t.map(([n, s]) => [n, s.fast(n)]), j(...t).slow(e);
}
function ha(...t) {
  let e = d(0);
  for (let n of t)
    n.length == 2 && n.unshift(e), e = n[1];
  return B(
    ...t.map(
      ([n, s, r]) => P(h(r)).compress(d(n).div(e), d(s).div(e))
    )
  ).slow(e).innerJoin();
}
function N(...t) {
  let e = K(...t);
  return t.length > 1 && (e = e._fast(t.length), e._steps = t.length), t.length == 1 && t[0].__steps_source && (t._steps = t[0]._steps), e;
}
function D(...t) {
  return N(...t);
}
function fn(...t) {
  return N(...t);
}
function wt(t) {
  return Array.isArray(t) ? t.length == 0 ? [S, 0] : t.length == 1 ? wt(t[0]) : [N(...t.map((e) => wt(e)[0])), t.length] : [h(t), 1];
}
const da = g((t, e) => h(e).mask(t)), ma = g((t, e) => h(e).struct(t)), ya = g((t, e) => h(e).superimpose(...t)), ga = g((t, e) => h(e).withValue(t)), wa = g((t, e) => h(e).bind(t)), ba = g((t, e) => h(e).innerBind(t)), _a = g((t, e) => h(e).outerBind(t)), va = g((t, e) => h(e).squeezeBind(t)), ka = g((t, e) => h(e).stepBind(t)), qa = g((t, e) => h(e).polyBind(t)), Aa = g((t, e) => h(e).set(t)), Sa = g((t, e) => h(e).keep(t)), Ta = g((t, e) => h(e).keepif(t)), xa = g((t, e) => h(e).add(t)), Ca = g((t, e) => h(e).sub(t)), Ba = g((t, e) => h(e).mul(t)), Oa = g((t, e) => h(e).div(t)), za = g((t, e) => h(e).mod(t)), Ea = g((t, e) => h(e).pow(t)), Ma = g((t, e) => h(e).band(t)), Ja = g((t, e) => h(e).bor(t)), ja = g((t, e) => h(e).bxor(t)), Pa = g((t, e) => h(e).blshift(t)), Na = g((t, e) => h(e).brshift(t)), $a = g((t, e) => h(e).lt(t)), Ra = g((t, e) => h(e).gt(t)), Wa = g((t, e) => h(e).lte(t)), La = g((t, e) => h(e).gte(t)), Ia = g((t, e) => h(e).eq(t)), Ha = g((t, e) => h(e).eqt(t)), Va = g((t, e) => h(e).ne(t)), Fa = g((t, e) => h(e).net(t)), Da = g((t, e) => h(e).and(t)), Ga = g((t, e) => h(e).or(t)), Qa = g((t, e) => h(e).func(t));
function l(t, e, n = !0, s = !1, r = (o) => o.innerJoin()) {
  if (Array.isArray(t)) {
    const u = {};
    for (const a of t)
      u[a] = l(a, e, n, s, r);
    return u;
  }
  const o = e.length;
  var c;
  return n ? c = function(...u) {
    u = u.map(h);
    const a = u[u.length - 1];
    let p;
    if (o === 1)
      p = e(a);
    else {
      const m = u.slice(0, -1);
      if (m.every((y) => y.__pure != null)) {
        const y = m.map((w) => w.__pure), b = m.filter((w) => w.__pure_loc).map((w) => w.__pure_loc);
        p = e(...y, a), p = p.withContext((w) => {
          const v = (w.locations || []).concat(b);
          return { ...w, locations: v };
        });
      } else {
        const [y, ...b] = m;
        let w = (...v) => e(...v, a);
        w = g(w, null, o - 1), p = r(b.reduce((v, k) => v.appLeft(k), y.fmap(w)));
      }
    }
    return s && (p._steps = a._steps), p;
  } : c = function(...u) {
    u = u.map(h);
    const a = e(...u);
    return s && (a._steps = u[u.length - 1]._steps), a;
  }, f.prototype[t] = function(...u) {
    if (o === 2 && u.length !== 1)
      u = [D(...u)];
    else if (o !== u.length + 1)
      throw new Error(`.${t}() expects ${o - 1} inputs but got ${u.length}.`);
    return u = u.map(h), c(...u, this);
  }, o > 1 && (f.prototype["_" + t] = function(...u) {
    const a = e(...u, this);
    return s && a.setSteps(this._steps), a;
  }), g(c, null, o);
}
function ct(t, e, n = !0, s = !1, r = (o) => o.stepJoin()) {
  return l(t, e, n, s, r);
}
const Ua = l("round", function(t) {
  return t.asNumber().fmap((e) => Math.round(e));
}), Ka = l("floor", function(t) {
  return t.asNumber().fmap((e) => Math.floor(e));
}), Xa = l("ceil", function(t) {
  return t.asNumber().fmap((e) => Math.ceil(e));
}), Ya = l("toBipolar", function(t) {
  return t.fmap((e) => e * 2 - 1);
}), Za = l("fromBipolar", function(t) {
  return t.fmap((e) => (e + 1) / 2);
}), tl = l("range", function(t, e, n) {
  return n.mul(e - t).add(t);
}), el = l("rangex", function(t, e, n) {
  return n._range(Math.log(t), Math.log(e)).fmap(Math.exp);
}), nl = l("range2", function(t, e, n) {
  return n.fromBipolar()._range(t, e);
}), sl = l(
  "ratio",
  (t) => t.fmap((e) => Array.isArray(e) ? e.slice(1).reduce((n, s) => n / s, e[0]) : e)
), rl = l("compress", function(t, e, n) {
  return t = d(t), e = d(e), t.gt(e) || t.gt(1) || e.gt(1) || t.lt(0) || e.lt(0) ? S : n._fastGap(d(1).div(e.sub(t)))._late(t);
}), { compressSpan: ol, compressspan: il } = l(["compressSpan", "compressspan"], function(t, e) {
  return e._compress(t.begin, t.end);
}), { fastGap: cl, fastgap: ul } = l(["fastGap", "fastgap"], function(t, e) {
  const n = function(r) {
    const o = r.begin.sam(), c = r.begin.sub(o).mul(t).min(1), u = r.end.sub(o).mul(t).min(1);
    if (!(c >= 1))
      return new C(o.add(c), o.add(u));
  }, s = function(r) {
    const o = r.part.begin, c = r.part.end, u = o.sam(), a = o.sub(u).div(t).min(1), p = c.sub(u).div(t).min(1), m = new C(u.add(a), u.add(p)), y = r.whole ? new C(
      m.begin.sub(o.sub(r.whole.begin).div(t)),
      m.end.add(r.whole.end.sub(c).div(t))
    ) : void 0;
    return new x(y, m, r.value, r.context);
  };
  return e.withQuerySpanMaybe(n).withHap(s).splitQueries();
}), al = l("focus", function(t, e, n) {
  return t = d(t), e = d(e), n._early(t.sam())._fast(d(1).div(e.sub(t)))._late(t);
}), { focusSpan: ll, focusspan: pl } = l(["focusSpan", "focusspan"], function(t, e) {
  return e._focus(t.begin, t.end);
}), fl = l("ply", function(t, e) {
  const n = e.fmap((s) => P(s)._fast(t)).squeezeJoin();
  return L && (n._steps = d(t).mulmaybe(e._steps)), n;
}), { fast: hl, density: dl } = l(
  ["fast", "density"],
  function(t, e) {
    return t === 0 ? S : (t = d(t), e.withQueryTime((s) => s.mul(t)).withHapTime((s) => s.div(t)).setSteps(e._steps));
  },
  !0,
  !0
), ml = l("hurry", function(t, e) {
  return e._fast(t).mul(P({ speed: t }));
}), { slow: yl, sparsity: gl } = l(["slow", "sparsity"], function(t, e) {
  return t === 0 ? S : e._fast(d(1).div(t));
}), wl = l("inside", function(t, e, n) {
  return e(n._slow(t))._fast(t);
}), bl = l("outside", function(t, e, n) {
  return e(n._fast(t))._slow(t);
}), _l = l("lastOf", function(t, e, n) {
  const s = Array(t - 1).fill(n);
  return s.push(e(n)), Kt(...s);
}), { firstOf: vl, every: kl } = l(["firstOf", "every"], function(t, e, n) {
  const s = Array(t - 1).fill(n);
  return s.unshift(e(n)), Kt(...s);
}), ql = l("apply", function(t, e) {
  return t(e);
}), Al = l("cpm", function(t, e) {
  return e._fast(t / 60 / 1);
}), Sl = l(
  "early",
  function(t, e) {
    return t = d(t), e.withQueryTime((n) => n.add(t)).withHapTime((n) => n.sub(t));
  },
  !0,
  !0
), hn = l(
  "late",
  function(t, e) {
    return t = d(t), e._early(d(0).sub(t));
  },
  !0,
  !0
), Tl = l("zoom", function(t, e, n) {
  if (e = d(e), t = d(t), t.gte(e))
    return R;
  const s = e.sub(t), r = L ? n._steps?.mulmaybe(s) : void 0;
  return n.withQuerySpan((o) => o.withCycle((c) => c.mul(s).add(t))).withHapSpan((o) => o.withCycle((c) => c.sub(t).div(s))).splitQueries().setSteps(r);
}), { zoomArc: xl, zoomarc: Cl } = l(["zoomArc", "zoomarc"], function(t, e) {
  return e.zoom(t.begin, t.end);
}), Bl = l(
  "bite",
  (t, e, n) => e.fmap((s) => (r) => {
    const o = d(s).div(r).mod(1), c = o.add(d(1).div(r));
    return n.zoom(o, c);
  }).appLeft(t).squeezeJoin(),
  !1
), Ol = l(
  "linger",
  function(t, e) {
    return t == 0 ? S : t < 0 ? e._zoom(t.add(1), 1)._slow(t) : e._zoom(0, t)._slow(t);
  },
  !0,
  !0
), { segment: zl, seg: El } = l(["segment", "seg"], function(t, e) {
  return e.struct(P(!0)._fast(t)).setSteps(t);
}), Ml = l("swingBy", (t, e, n) => n.inside(e, hn(fn(0, t / 2)))), Jl = l("swing", (t, e) => e.swingBy(1 / 3, t)), { invert: jl, inv: Pl } = l(
  ["invert", "inv"],
  function(t) {
    return t.fmap((e) => !e);
  },
  !0,
  !0
), Nl = l("when", function(t, e, n) {
  return t ? e(n) : n;
}), $l = l("off", function(t, e, n) {
  return B(n, e(n.late(t)));
}), Rl = l("brak", function(t) {
  return t.when(K(!1, !0), (e) => N(e, S)._late(0.25));
}), dn = l(
  "rev",
  function(t) {
    const e = function(n) {
      const s = n.span, r = s.begin.sam(), o = s.begin.nextSam(), c = function(a) {
        const p = a.withTime((y) => r.add(o.sub(y))), m = p.begin;
        return p.begin = p.end, p.end = m, p;
      };
      return t.query(n.setSpan(c(s))).map((a) => a.withSpan(c));
    };
    return new f(e).splitQueries();
  },
  !1,
  !0
), Wl = l("pressBy", function(t, e) {
  return e.fmap((n) => P(n).compress(t, 1)).squeezeJoin();
}), Ll = l("press", function(t) {
  return t._pressBy(0.5);
});
f.prototype.hush = function() {
  return S;
};
const Il = l(
  "palindrome",
  function(t) {
    return t.lastOf(2, dn);
  },
  !0,
  !0
), { juxBy: Hl, juxby: Vl } = l(["juxBy", "juxby"], function(t, e, n) {
  t /= 2;
  const s = function(c, u, a) {
    return u in c ? c[u] : a;
  }, r = n.withValue((c) => Object.assign({}, c, { pan: s(c, "pan", 0.5) - t })), o = e(n.withValue((c) => Object.assign({}, c, { pan: s(c, "pan", 0.5) + t })));
  return B(r, o).setSteps(L ? U(r._steps, o._steps) : void 0);
}), Fl = l("jux", function(t, e) {
  return e._juxBy(1, t, e);
}), { echoWith: Dl, echowith: Gl, stutWith: Ql, stutwith: Ul } = l(
  ["echoWith", "echowith", "stutWith", "stutwith"],
  function(t, e, n, s) {
    return B(...Vt(0, t - 1).map((r) => n(s.late(d(e).mul(r)), r)));
  }
), Kl = l("echo", function(t, e, n, s) {
  return s._echoWith(t, e, (r, o) => r.gain(Math.pow(n, o)));
}), Xl = l("stut", function(t, e, n, s) {
  return s._echoWith(t, n, (r, o) => r.gain(Math.pow(e, o)));
}), qt = function(t, e, n = !1) {
  return t = d(t), K(
    ...Vt(0, t.sub(1)).map(
      (s) => n ? e.late(d(s).div(t)) : e.early(d(s).div(t))
    )
  );
}, Yl = l(
  "iter",
  function(t, e) {
    return qt(t, e, !1);
  },
  !0,
  !0
), { iterBack: Zl, iterback: tp } = l(
  ["iterBack", "iterback"],
  function(t, e) {
    return qt(t, e, !0);
  },
  !0,
  !0
), { repeatCycles: ep } = l(
  "repeatCycles",
  function(t, e) {
    return new f(function(n) {
      const s = n.span.begin.sam(), r = s.div(t).sam(), o = s.sub(r);
      return n = n.withSpan((c) => c.withTime((u) => u.sub(o))), e.query(n).map((c) => c.withSpan((u) => u.withTime((a) => a.add(o))));
    }).splitQueries();
  },
  !0,
  !0
), At = function(t, e, n, s = !1, r = !1) {
  const o = Array(t - 1).fill(!1);
  o.unshift(!0);
  const c = qt(t, D(...o), !s);
  return r || (n = n.repeatCycles(t)), n.when(c, e);
}, { chunk: np, slowchunk: sp, slowChunk: rp } = l(
  ["chunk", "slowchunk", "slowChunk"],
  function(t, e, n) {
    return At(t, e, n, !1, !1);
  },
  !0,
  !0
), { chunkBack: op, chunkback: ip } = l(
  ["chunkBack", "chunkback"],
  function(t, e, n) {
    return At(t, e, n, !0);
  },
  !0,
  !0
), { fastchunk: cp, fastChunk: up } = l(
  ["fastchunk", "fastChunk"],
  function(t, e, n) {
    return At(t, e, n, !1, !0);
  },
  !0,
  !0
), { chunkinto: ap, chunkInto: lp } = l(["chunkinto", "chunkInto"], function(t, e, n) {
  return n.into(N(!0, ...Array(t - 1).fill(!1))._iterback(t), e);
}), { chunkbackinto: pp, chunkBackInto: fp } = l(["chunkbackinto", "chunkBackInto"], function(t, e, n) {
  return n.into(
    N(!0, ...Array(t - 1).fill(!1))._iter(t)._early(1),
    e
  );
}), hp = l(
  "bypass",
  function(t, e) {
    return t = !!parseInt(t), t ? S : e;
  },
  !0,
  !0
), { ribbon: dp, rib: mp } = l(
  ["ribbon", "rib"],
  (t, e, n) => n.early(t).restart(P(1).slow(e))
), yp = l("hsla", (t, e, n, s, r) => r.color(`hsla(${t}turn,${e * 100}%,${n * 100}%,${s})`)), gp = l("hsl", (t, e, n, s) => s.color(`hsl(${t}turn,${e * 100}%,${n * 100}%)`));
f.prototype.tag = function(t) {
  return this.withContext((e) => ({ ...e, tags: (e.tags || []).concat([t]) }));
};
const wp = l("filter", (t, e) => e.withHaps((n) => n.filter(t))), bp = l("filterWhen", (t, e) => e.filter((n) => t(n.whole.begin))), _p = l(
  "within",
  (t, e, n, s) => B(
    n(s.filterWhen((r) => r.cyclePos() >= t && r.cyclePos() <= e)),
    s.filterWhen((r) => r.cyclePos() < t || r.cyclePos() > e)
  )
);
f.prototype.stepJoin = function() {
  const t = this, e = j(...Nt($t(t.queryArc(0, 1))))._steps, n = function(s) {
    const o = t.early(s.span.begin.sam()).query(s.setSpan(new C(d(0), d(1))));
    return j(...Nt($t(o))).query(s);
  };
  return new f(n, e);
};
f.prototype.stepBind = function(t) {
  return this.fmap(t).stepJoin();
};
function Nt(t) {
  const e = t.filter((o, c) => c.hasSteps).reduce((o, c) => o.add(c), d(0)), n = ot(t.map((o, c) => c._steps)).reduce(
    (o, c) => o.add(c),
    d(0)
  ), s = e.eq(0) ? void 0 : n.div(e);
  function r(o, c) {
    return c._steps === void 0 ? [o.mulmaybe(s), c] : [c._steps, c];
  }
  return t.map((o) => r(...o));
}
function $t(t) {
  const e = F(t.map((r) => [r.part.begin, r.part.end])), n = De([d(0), d(1), ...e]);
  return $e(n).map((r) => [
    r[1].sub(r[0]),
    B(...mn(new C(...r), t).map((o) => o.value.withHap((c) => c.setContext(c.combineContext(o)))))
  ]);
}
function mn(t, e) {
  return ot(e.map((n) => yn(t, n)));
}
function yn(t, e) {
  const n = t.intersection(e.part);
  if (n != null)
    return new x(e.whole, n, e.value, e.context);
}
const gn = l("pace", function(t, e) {
  return e._steps === void 0 ? e : e._steps.eq(d(0)) ? R : e._fast(d(t).div(e._steps)).setSteps(t);
});
function wn(t, ...e) {
  const n = e.map((r) => wt(r));
  if (n.length == 0)
    return S;
  t == 0 && (t = n[0][1]);
  const s = [];
  for (const r of n)
    r[1] != 0 && (t == r[1] ? s.push(r[0]) : s.push(r[0]._fast(d(t).div(d(r[1])))));
  return B(...s);
}
function St(...t) {
  if (Array.isArray(t[0]))
    return wn(0, ...t);
  if (t = t.filter((s) => s.hasSteps), t.length == 0)
    return S;
  const e = U(...t.map((s) => s._steps));
  if (e.eq(d(0)))
    return R;
  const n = B(...t.map((s) => s.pace(e)));
  return n._steps = e, n;
}
function j(...t) {
  if (t.length === 0)
    return R;
  const e = (c) => Array.isArray(c) ? c : [c._steps ?? 1, c];
  if (t = t.map(e), t.find((c) => c[0] === void 0)) {
    const c = t.map((a) => a[0]).filter((a) => a !== void 0);
    if (c.length === 0)
      return N(...t.map((a) => a[1]));
    if (c.length === t.length)
      return R;
    const u = c.reduce((a, p) => a.add(p), d(0)).div(c.length);
    for (let a of t)
      a[0] === void 0 && (a[0] = u);
  }
  if (t.length == 1)
    return h(t[0][1]).withSteps((u) => t[0][0]);
  const n = t.map((c) => c[0]).reduce((c, u) => c.add(u), d(0));
  let s = d(0);
  const r = [];
  for (const [c, u] of t) {
    if (d(c).eq(0))
      continue;
    const a = s.add(c);
    r.push(h(u)._compress(s.div(n), a.div(n))), s = a;
  }
  const o = B(...r);
  return o._steps = n, o;
}
function bn(...t) {
  t = t.map((r) => Array.isArray(r) ? r.map(h) : [h(r)]);
  const e = U(...t.map((r) => d(r.length)));
  let n = [];
  for (let r = 0; r < e; ++r)
    n.push(...t.map((o) => o.length == 0 ? S : o[r % o.length]));
  n = n.filter((r) => r.hasSteps && r._steps > 0);
  const s = n.reduce((r, o) => r.add(o._steps), d(0));
  return n = j(...n), n._steps = s, n;
}
const _n = ct("take", function(t, e) {
  if (!e.hasSteps || e._steps.lte(0) || (t = d(t), t.eq(0)))
    return R;
  const n = t < 0;
  n && (t = t.abs());
  const s = t.div(e._steps);
  return s.lte(0) ? R : s.gte(1) ? e : n ? e.zoom(d(1).sub(s), 1) : e.zoom(0, s);
}), vn = ct("drop", function(t, e) {
  return e.hasSteps ? (t = d(t), t.lt(0) ? e.take(e._steps.add(t)) : e.take(d(0).sub(e._steps.sub(t)))) : R;
}), kn = ct("extend", function(t, e) {
  return e.fast(t).expand(t);
}), qn = ct("expand", function(t, e) {
  return e.withSteps((n) => n.mul(d(t)));
}), An = ct("contract", function(t, e) {
  return e.withSteps((n) => n.div(d(t)));
});
f.prototype.shrinklist = function(t) {
  const e = this;
  if (!e.hasSteps)
    return [e];
  let [n, s] = Array.isArray(t) ? t : [t, e._steps];
  if (n = d(n), s === 0 || n === 0)
    return [e];
  const r = n > 0, o = [];
  if (r) {
    const c = d(1).div(e._steps).mul(n);
    for (let u = 0; u < s; ++u) {
      const a = c.mul(u);
      if (a.gt(1))
        break;
      o.push([a, 1]);
    }
  } else {
    n = d(0).sub(n);
    const c = d(1).div(e._steps).mul(n);
    for (let u = 0; u < s; ++u) {
      const a = d(1).sub(c.mul(u));
      if (a.lt(0))
        break;
      o.push([d(0), a]);
    }
  }
  return o.map((c) => e.zoom(...c));
};
const Sn = (t, e) => e.shrinklist(t), Tn = l(
  "shrink",
  function(t, e) {
    if (!e.hasSteps)
      return R;
    const n = e.shrinklist(t), s = j(...n);
    return s._steps = n.reduce((r, o) => r.add(o._steps), d(0)), s;
  },
  !0,
  !1,
  (t) => t.stepJoin()
), vp = l(
  "grow",
  function(t, e) {
    if (!e.hasSteps)
      return R;
    const n = e.shrinklist(d(0).sub(t));
    n.reverse();
    const s = j(...n);
    return s._steps = n.reduce((r, o) => r.add(o._steps), d(0)), s;
  },
  !0,
  !1,
  (t) => t.stepJoin()
), xn = function(t, ...e) {
  return t.tour(...e);
};
f.prototype.tour = function(...t) {
  return j(
    ...[].concat(
      ...t.map((e, n) => [...t.slice(0, t.length - n), this, ...t.slice(t.length - n)]),
      this,
      ...t
    )
  );
};
const Cn = function(...t) {
  t = t.filter((s) => s.hasSteps);
  const e = K(...t.map((s) => s._slow(s._steps))), n = U(...t.map((s) => s._steps));
  return e._fast(n).setSteps(n);
}, kp = j, Bn = j, qp = j, Ap = bn, Sp = St;
f.prototype.s_polymeter = f.prototype.polymeter;
const Tp = Tn;
f.prototype.s_taper = f.prototype.shrink;
const xp = Sn;
f.prototype.s_taperlist = f.prototype.shrinklist;
const Cp = _n;
f.prototype.s_add = f.prototype.take;
const Bp = vn;
f.prototype.s_sub = f.prototype.drop;
const Op = qn;
f.prototype.s_expand = f.prototype.expand;
const zp = kn;
f.prototype.s_extend = f.prototype.extend;
const Ep = An;
f.prototype.s_contract = f.prototype.contract;
const Mp = xn;
f.prototype.s_tour = f.prototype.tour;
const Jp = Cn;
f.prototype.s_zip = f.prototype.zip;
const jp = gn;
f.prototype.steps = f.prototype.pace;
const Pp = l("chop", function(t, e) {
  const s = Array.from({ length: t }, (c, u) => u).map((c) => ({ begin: c / t, end: (c + 1) / t })), r = function(c, u) {
    if ("begin" in c && "end" in c && c.begin !== void 0 && c.end !== void 0) {
      const a = c.end - c.begin;
      u = { begin: c.begin + u.begin * a, end: c.begin + u.end * a };
    }
    return Object.assign({}, c, u);
  }, o = function(c) {
    return D(s.map((u) => r(c, u)));
  };
  return e.squeezeBind(o).setSteps(L ? d(t).mulmaybe(e._steps) : void 0);
}), Np = l("striate", function(t, e) {
  const s = Array.from({ length: t }, (o, c) => c).map((o) => ({ begin: o / t, end: (o + 1) / t })), r = K(...s);
  return e.set(r)._fast(t).setSteps(L ? d(t).mulmaybe(e._steps) : void 0);
}), Xt = function(t, e, n = 0.5) {
  return e.speed(1 / t * n).unit("c").slow(t);
}, On = l(
  "slice",
  function(t, e, n) {
    return t.innerBind(
      (s) => e.outerBind(
        (r) => n.outerBind((o) => {
          o = o instanceof Object ? o : { s: o };
          const c = Array.isArray(s) ? s[r] : r / s, u = Array.isArray(s) ? s[r + 1] : (r + 1) / s;
          return P({ begin: c, end: u, _slices: s, ...o });
        })
      )
    ).setSteps(e._steps);
  },
  !1
  // turns off auto-patternification
);
f.prototype.onTriggerTime = function(t) {
  return this.onTrigger((e, n, s, r) => {
    const o = r - n;
    window.setTimeout(() => {
      t(e);
    }, o * 1e3);
  }, !1);
};
const $p = l(
  "splice",
  function(t, e, n) {
    const s = On(t, e, n);
    return new f((r) => {
      const o = r.controls._cps || 1;
      return s.query(r).map(
        (u) => u.withValue((a) => ({
          speed: o / a._slices / u.whole.duration * (a.speed || 1),
          unit: "c",
          ...a
        }))
      );
    }).setSteps(e._steps);
  },
  !1
  // turns off auto-patternification
), { loopAt: Rp, loopat: Wp } = l(["loopAt", "loopat"], function(t, e) {
  const n = e._steps ? e._steps.div(t) : void 0;
  return new f((s) => Xt(t, e, s.controls._cps).query(s), n);
}), Lp = l(
  "fit",
  (t) => t.withHaps(
    (e, n) => e.map(
      (s) => s.withValue((r) => {
        const o = ("end" in r ? r.end : 1) - ("begin" in r ? r.begin : 0);
        return {
          ...r,
          speed: (n.controls._cps || 1) / s.whole.duration * o,
          unit: "c"
        };
      })
    )
  )
), { loopAtCps: Ip, loopatcps: Hp } = l(["loopAtCps", "loopatcps"], function(t, e, n) {
  return Xt(t, n, e);
}), Vp = (t) => P(1).withValue(() => h(t())).innerJoin();
let Rt = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5, zn = (t, e, n) => {
  e = h(e), t = h(t), n = h(n);
  let s = e.fmap((o) => ({ gain: Rt(o) })), r = e.fmap((o) => ({ gain: Rt(1 - o) }));
  return B(t.mul(s), n.mul(r));
};
f.prototype.xfade = function(t, e) {
  return zn(this, t, e);
};
const En = (t) => (e, n, s) => {
  e = d(e).mod(n), n = d(n);
  const r = e.div(n), o = e.add(1).div(n);
  return t(s.fmap((c) => P(c)._compress(r, o)));
}, { beat: Fp } = l(
  ["beat"],
  En((t) => t.innerJoin())
), Yt = (t, e, n) => {
  n = d(n);
  const s = d(1).div(t.length), r = (u) => {
    const a = [];
    for (const [p, m] of u.entries())
      m && a.push([d(p).div(u.length), m]);
    return a;
  }, o = vt(
    ([u, a], [p, m]) => {
      const y = n.mul(p - u).add(u), b = y.add(s);
      return new C(y, b);
    },
    r(t),
    r(e)
  );
  function c(u) {
    const a = u.span.begin.sam(), p = u.span.cycleArc(), m = [];
    for (const y of o) {
      const b = y.intersection(p);
      b !== void 0 && m.push(
        new x(
          y.withTime((w) => w.add(a)),
          b.withTime((w) => w.add(a)),
          !0
        )
      );
    }
    return m;
  }
  return new f(c).splitQueries();
}, Dp = (t, e, n) => (t = h(t), e = h(e), n = h(n), t.innerBind((s) => e.innerBind((r) => n.innerBind((o) => Yt(s, r, o)))));
function Tt(t) {
  let e = Array.isArray(t);
  t = e ? t : [t];
  const n = t[0], s = (o) => {
    let c;
    if (typeof o == "object" && o.value !== void 0 && (c = { ...o }, o = o.value, delete c.value), e && Array.isArray(o)) {
      const u = c || {};
      return o.forEach((a, p) => {
        p < t.length && (u[t[p]] = a);
      }), u;
    } else return c ? (c[n] = o, c) : { [n]: o };
  }, r = function(o, c) {
    return c ? typeof o > "u" ? c.fmap(s) : c.set(h(o).withValue(s)) : h(o).withValue(s);
  };
  return f.prototype[n] = function(o) {
    return r(o, this);
  }, r;
}
const st = /* @__PURE__ */ new Map();
function Mn(t) {
  return st.has(t);
}
function i(t, ...e) {
  const n = Array.isArray(t) ? t[0] : t;
  let s = {};
  return s[n] = Tt(t), st.set(n, n), e.forEach((r) => {
    s[r] = s[n], st.set(r, n), f.prototype[r] = f.prototype[n];
  }), s;
}
const { s: Jn, sound: jn } = i(["s", "n", "gain"], "sound"), { source: Pn, src: Nn } = i("source", "src"), { n: $n } = i("n"), { note: Rn } = i(["note", "n"]), { accelerate: Wn } = i("accelerate"), { velocity: Ln } = i("velocity"), { gain: In } = i("gain"), { postgain: Hn } = i("postgain"), { amp: Vn } = i("amp"), { attack: Fn, att: Dn } = i("attack", "att"), { fmh: Gn } = i(["fmh", "fmi"], "fmh"), { fmi: Qn, fm: Un } = i(["fmi", "fmh"], "fm"), { fmenv: Kn } = i("fmenv"), { fmattack: Xn } = i("fmattack"), { fmwave: Yn } = i("fmwave"), { fmdecay: Zn } = i("fmdecay"), { fmsustain: ts } = i("fmsustain"), { fmrelease: es } = i("fmrelease"), { fmvelocity: ns } = i("fmvelocity"), { bank: ss } = i("bank"), { analyze: rs } = i("analyze"), { fft: os } = i("fft"), { decay: is, dec: cs } = i("decay", "dec"), { sustain: us, sus: as } = i("sustain", "sus"), { release: ls, rel: ps } = i("release", "rel"), { hold: fs } = i("hold"), { bandf: hs, bpf: ds, bp: ms } = i(["bandf", "bandq", "bpenv"], "bpf", "bp"), { bandq: ys, bpq: gs } = i("bandq", "bpq"), { begin: ws } = i("begin"), { end: bs } = i("end"), { loop: _s } = i("loop"), { loopBegin: vs, loopb: ks } = i("loopBegin", "loopb"), { loopEnd: qs, loope: As } = i("loopEnd", "loope"), { crush: Ss } = i("crush"), { coarse: Ts } = i("coarse"), { tremolo: xs } = i(["tremolo", "tremolodepth", "tremoloskew", "tremolophase"], "trem"), { tremolosync: Cs } = i(
  ["tremolosync", "tremolodepth", "tremoloskew", "tremolophase"],
  "tremsync"
), { tremolodepth: Bs } = i("tremolodepth", "tremdepth"), { tremoloskew: Os } = i("tremoloskew", "tremskew"), { tremolophase: zs } = i("tremolophase", "tremphase"), { tremoloshape: Es } = i("tremoloshape", "tremshape"), { duck: Ms } = i("duckorbit", "duck"), { duckdepth: Js } = i("duckdepth"), { duckattack: js } = i("duckattack", "duckatt"), { drive: Ps } = i("drive"), { byteBeatExpression: Ns, bbexpr: $s } = i("byteBeatExpression", "bbexpr"), { byteBeatStartTime: Rs, bbst: Ws } = i("byteBeatStartTime", "bbst"), { channels: Ls, ch: Is } = i("channels", "ch"), { pw: Hs } = i(["pw", "pwrate", "pwsweep"]), { pwrate: Vs } = i("pwrate"), { pwsweep: Fs } = i("pwsweep"), { phaserrate: Ds, ph: Gs, phaser: Qs } = i(
  ["phaserrate", "phaserdepth", "phasercenter", "phasersweep"],
  "ph",
  "phaser"
), { phasersweep: Us, phs: Ks } = i("phasersweep", "phs"), { phasercenter: Xs, phc: Ys } = i("phasercenter", "phc"), { phaserdepth: Zs, phd: tr, phasdp: er } = i("phaserdepth", "phd", "phasdp"), { channel: nr } = i("channel"), { cut: sr } = i("cut"), { cutoff: rr, ctf: or, lpf: ir, lp: cr } = i(["cutoff", "resonance", "lpenv"], "ctf", "lpf", "lp"), { lpenv: ur, lpe: ar } = i("lpenv", "lpe"), { hpenv: lr, hpe: pr } = i("hpenv", "hpe"), { bpenv: fr, bpe: hr } = i("bpenv", "bpe"), { lpattack: dr, lpa: mr } = i("lpattack", "lpa"), { hpattack: yr, hpa: gr } = i("hpattack", "hpa"), { bpattack: wr, bpa: br } = i("bpattack", "bpa"), { lpdecay: _r, lpd: vr } = i("lpdecay", "lpd"), { hpdecay: kr, hpd: qr } = i("hpdecay", "hpd"), { bpdecay: Ar, bpd: Sr } = i("bpdecay", "bpd"), { lpsustain: Tr, lps: xr } = i("lpsustain", "lps"), { hpsustain: Cr, hps: Br } = i("hpsustain", "hps"), { bpsustain: Or, bps: zr } = i("bpsustain", "bps"), { lprelease: Er, lpr: Mr } = i("lprelease", "lpr"), { hprelease: Jr, hpr: jr } = i("hprelease", "hpr"), { bprelease: Pr, bpr: Nr } = i("bprelease", "bpr"), { ftype: $r } = i("ftype"), { fanchor: Rr } = i("fanchor"), { vib: Wr, vibrato: Lr, v: Ir } = i(["vib", "vibmod"], "vibrato", "v"), { noise: Hr } = i("noise"), { vibmod: Vr, vmod: Fr } = i(["vibmod", "vib"], "vmod"), { hcutoff: Dr, hpf: Gr, hp: Qr } = i(["hcutoff", "hresonance", "hpenv"], "hpf", "hp"), { hresonance: Ur, hpq: Kr } = i("hresonance", "hpq"), { resonance: Xr, lpq: Yr } = i("resonance", "lpq"), { djf: Zr } = i("djf"), { delay: to } = i(["delay", "delaytime", "delayfeedback"]), { delayfeedback: eo, delayfb: no, dfb: so } = i("delayfeedback", "delayfb", "dfb"), { delaytime: ro, delayt: oo, dt: io } = i("delaytime", "delayt", "dt"), { delaysync: co } = i("delaysync"), { lock: uo } = i("lock"), { detune: ao, det: lo } = i("detune", "det"), { unison: po } = i("unison"), { spread: fo } = i("spread"), { dry: ho } = i("dry"), { fadeTime: mo, fadeOutTime: yo } = i("fadeTime", "fadeOutTime"), { fadeInTime: go } = i("fadeInTime"), { freq: wo } = i("freq"), { pattack: bo, patt: _o } = i("pattack", "patt"), { pdecay: vo, pdec: ko } = i("pdecay", "pdec"), { psustain: qo, psus: Ao } = i("psustain", "psus"), { prelease: So, prel: To } = i("prelease", "prel"), { penv: xo } = i("penv"), { pcurve: Co } = i("pcurve"), { panchor: Bo } = i("panchor"), { gate: Oo, gat: zo } = i("gate", "gat"), { leslie: Eo } = i("leslie"), { lrate: Mo } = i("lrate"), { lsize: Jo } = i("lsize"), { activeLabel: jo } = i("activeLabel"), { label: Po } = i(["label", "activeLabel"]), { degree: No } = i("degree"), { mtranspose: $o } = i("mtranspose"), { ctranspose: Ro } = i("ctranspose"), { harmonic: Wo } = i("harmonic"), { stepsPerOctave: Lo } = i("stepsPerOctave"), { octaveR: Io } = i("octaveR"), { nudge: Ho } = i("nudge"), { octave: Vo } = i("octave"), { orbit: Fo } = i("orbit"), { overgain: Do } = i("overgain"), { overshape: Go } = i("overshape"), { pan: Qo } = i("pan"), { panspan: Uo } = i("panspan"), { pansplay: Ko } = i("pansplay"), { panwidth: Xo } = i("panwidth"), { panorient: Yo } = i("panorient"), { rate: Zo } = i("rate"), { slide: ti } = i("slide"), { semitone: ei } = i("semitone"), { voice: ni } = i("voice"), { chord: si } = i("chord"), { dictionary: ri, dict: oi } = i("dictionary", "dict"), { anchor: ii } = i("anchor"), { offset: ci } = i("offset"), { octaves: ui } = i("octaves"), { mode: ai } = i(["mode", "anchor"]), { room: li } = i(["room", "size"]), { roomlp: pi, rlp: fi } = i("roomlp", "rlp"), { roomdim: hi, rdim: di } = i("roomdim", "rdim"), { roomfade: mi, rfade: yi } = i("roomfade", "rfade"), { ir: gi, iresponse: wi } = i(["ir", "i"], "iresponse"), { irspeed: bi } = i("irspeed"), { irbegin: _i } = i("irbegin"), { roomsize: vi, size: ki, sz: qi, rsize: Ai } = i("roomsize", "size", "sz", "rsize"), { shape: Si } = i(["shape", "shapevol"]), { distort: Ti, dist: xi } = i(["distort", "distortvol"], "dist"), { compressor: Ci } = i([
  "compressor",
  "compressorRatio",
  "compressorKnee",
  "compressorAttack",
  "compressorRelease"
]), { compressorKnee: Bi } = i("compressorKnee"), { compressorRatio: Oi } = i("compressorRatio"), { compressorAttack: zi } = i("compressorAttack"), { compressorRelease: Ei } = i("compressorRelease"), { speed: Zt } = i("speed"), { stretch: Mi } = i("stretch"), { unit: Ji } = i("unit"), { squiz: ji } = i("squiz"), { vowel: Pi } = i("vowel"), { waveloss: Ni } = i("waveloss"), { density: $i } = i("density"), { expression: Ri } = i("expression"), { sustainpedal: Wi } = i("sustainpedal"), { fshift: Li } = i("fshift"), { fshiftnote: Ii } = i("fshiftnote"), { fshiftphase: Hi } = i("fshiftphase"), { triode: Vi } = i("triode"), { krush: Fi } = i("krush"), { kcutoff: Di } = i("kcutoff"), { octer: Gi } = i("octer"), { octersub: Qi } = i("octersub"), { octersubsub: Ui } = i("octersubsub"), { ring: Ki } = i("ring"), { ringf: Xi } = i("ringf"), { ringdf: Yi } = i("ringdf"), { freeze: Zi } = i("freeze"), { xsdelay: tc } = i("xsdelay"), { tsdelay: ec } = i("tsdelay"), { real: nc } = i("real"), { imag: sc } = i("imag"), { enhance: rc } = i("enhance"), { partials: oc } = i("partials"), { comb: ic } = i("comb"), { smear: cc } = i("smear"), { scram: uc } = i("scram"), { binshift: ac } = i("binshift"), { hbrick: lc } = i("hbrick"), { lbrick: pc } = i("lbrick"), { frameRate: fc } = i("frameRate"), { frames: hc } = i("frames"), { hours: dc } = i("hours"), { minutes: mc } = i("minutes"), { seconds: yc } = i("seconds"), { songPtr: gc } = i("songPtr"), { uid: wc } = i("uid"), { val: bc } = i("val"), { cps: _c } = i("cps"), { clip: vc, legato: kc } = i("clip", "legato"), { duration: qc, dur: Ac } = i("duration", "dur"), { zrand: Sc } = i("zrand"), { curve: Tc } = i("curve"), { deltaSlide: xc } = i("deltaSlide"), { pitchJump: Cc } = i("pitchJump"), { pitchJumpTime: Bc } = i("pitchJumpTime"), { lfo: Oc, repeatTime: zc } = i("lfo", "repeatTime"), { znoise: Ec } = i("znoise"), { zmod: Mc } = i("zmod"), { zcrush: Jc } = i("zcrush"), { zdelay: jc } = i("zdelay"), { zzfx: Pc } = i("zzfx"), { color: Nc, colour: $c } = i(["color", "colour"]);
let Rc = (...t) => t.reduce((e, n) => Object.assign(e, { [n]: Tt(n) }), {});
const Wc = l("adsr", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s, r, o] = t;
  return e.set({ attack: n, decay: s, sustain: r, release: o });
}), Lc = l("ad", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = n] = t;
  return e.attack(n).decay(s);
}), Ic = l("ds", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = 0] = t;
  return e.set({ decay: n, sustain: s });
}), Hc = l("ar", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = n] = t;
  return e.set({ attack: n, release: s });
}), { midichan: Vc } = i("midichan"), { midimap: Fc } = i("midimap"), { midiport: Dc } = i("midiport"), { midicmd: Gc } = i("midicmd"), Qc = l("control", (t, e) => {
  if (!Array.isArray(t))
    throw new Error("control expects an array of [ccn, ccv]");
  const [n, s] = t;
  return e.ccn(n).ccv(s);
}), { ccn: Uc } = i("ccn"), { ccv: Kc } = i("ccv"), { ctlNum: Xc } = i("ctlNum"), { nrpnn: Yc } = i("nrpnn"), { nrpv: Zc } = i("nrpv"), { progNum: tu } = i("progNum"), eu = l("sysex", (t, e) => {
  if (!Array.isArray(t))
    throw new Error("sysex expects an array of [id, data]");
  const [n, s] = t;
  return e.sysexid(n).sysexdata(s);
}), { sysexid: nu } = i("sysexid"), { sysexdata: su } = i("sysexdata"), { midibend: ru } = i("midibend"), { miditouch: ou } = i("miditouch"), { polyTouch: iu } = i("polyTouch"), te = (t) => st.has(t) ? st.get(t) : t, cu = l("as", (t, e) => (t = Array.isArray(t) ? t : [t], e.fmap((n) => (n = Array.isArray(n) ? n : [n], n = Object.fromEntries(t.map((s, r) => [te(s), n[r]])), n)))), uu = l(
  "scrub",
  (t, e) => t.outerBind((n) => {
    Array.isArray(n) || (n = [n]);
    const [s, r = 1] = n;
    return e.begin(s).mul(Zt(r)).clip(1);
  }),
  !1
), Gp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accelerate: Wn,
  activeLabel: jo,
  ad: Lc,
  adsr: Wc,
  amp: Vn,
  analyze: rs,
  anchor: ii,
  ar: Hc,
  as: cu,
  att: Dn,
  attack: Fn,
  bandf: hs,
  bandq: ys,
  bank: ss,
  bbexpr: $s,
  bbst: Ws,
  begin: ws,
  binshift: ac,
  bp: ms,
  bpa: br,
  bpattack: wr,
  bpd: Sr,
  bpdecay: Ar,
  bpe: hr,
  bpenv: fr,
  bpf: ds,
  bpq: gs,
  bpr: Nr,
  bprelease: Pr,
  bps: zr,
  bpsustain: Or,
  byteBeatExpression: Ns,
  byteBeatStartTime: Rs,
  ccn: Uc,
  ccv: Kc,
  ch: Is,
  channel: nr,
  channels: Ls,
  chord: si,
  clip: vc,
  coarse: Ts,
  color: Nc,
  colour: $c,
  comb: ic,
  compressor: Ci,
  compressorAttack: zi,
  compressorKnee: Bi,
  compressorRatio: Oi,
  compressorRelease: Ei,
  control: Qc,
  cps: _c,
  createParam: Tt,
  createParams: Rc,
  crush: Ss,
  ctf: or,
  ctlNum: Xc,
  ctranspose: Ro,
  curve: Tc,
  cut: sr,
  cutoff: rr,
  dec: cs,
  decay: is,
  degree: No,
  delay: to,
  delayfb: no,
  delayfeedback: eo,
  delaysync: co,
  delayt: oo,
  delaytime: ro,
  deltaSlide: xc,
  density: $i,
  det: lo,
  detune: ao,
  dfb: so,
  dict: oi,
  dictionary: ri,
  dist: xi,
  distort: Ti,
  djf: Zr,
  drive: Ps,
  dry: ho,
  ds: Ic,
  dt: io,
  duck: Ms,
  duckattack: js,
  duckdepth: Js,
  dur: Ac,
  duration: qc,
  end: bs,
  enhance: rc,
  expression: Ri,
  fadeInTime: go,
  fadeOutTime: yo,
  fadeTime: mo,
  fanchor: Rr,
  fft: os,
  fm: Un,
  fmattack: Xn,
  fmdecay: Zn,
  fmenv: Kn,
  fmh: Gn,
  fmi: Qn,
  fmrelease: es,
  fmsustain: ts,
  fmvelocity: ns,
  fmwave: Yn,
  frameRate: fc,
  frames: hc,
  freeze: Zi,
  freq: wo,
  fshift: Li,
  fshiftnote: Ii,
  fshiftphase: Hi,
  ftype: $r,
  gain: In,
  gat: zo,
  gate: Oo,
  getControlName: te,
  harmonic: Wo,
  hbrick: lc,
  hcutoff: Dr,
  hold: fs,
  hours: dc,
  hp: Qr,
  hpa: gr,
  hpattack: yr,
  hpd: qr,
  hpdecay: kr,
  hpe: pr,
  hpenv: lr,
  hpf: Gr,
  hpq: Kr,
  hpr: jr,
  hprelease: Jr,
  hps: Br,
  hpsustain: Cr,
  hresonance: Ur,
  imag: sc,
  ir: gi,
  irbegin: _i,
  iresponse: wi,
  irspeed: bi,
  isControlName: Mn,
  kcutoff: Di,
  krush: Fi,
  label: Po,
  lbrick: pc,
  legato: kc,
  leslie: Eo,
  lfo: Oc,
  lock: uo,
  loop: _s,
  loopBegin: vs,
  loopEnd: qs,
  loopb: ks,
  loope: As,
  lp: cr,
  lpa: mr,
  lpattack: dr,
  lpd: vr,
  lpdecay: _r,
  lpe: ar,
  lpenv: ur,
  lpf: ir,
  lpq: Yr,
  lpr: Mr,
  lprelease: Er,
  lps: xr,
  lpsustain: Tr,
  lrate: Mo,
  lsize: Jo,
  midibend: ru,
  midichan: Vc,
  midicmd: Gc,
  midimap: Fc,
  midiport: Dc,
  miditouch: ou,
  minutes: mc,
  mode: ai,
  mtranspose: $o,
  n: $n,
  noise: Hr,
  note: Rn,
  nrpnn: Yc,
  nrpv: Zc,
  nudge: Ho,
  octave: Vo,
  octaveR: Io,
  octaves: ui,
  octer: Gi,
  octersub: Qi,
  octersubsub: Ui,
  offset: ci,
  orbit: Fo,
  overgain: Do,
  overshape: Go,
  pan: Qo,
  panchor: Bo,
  panorient: Yo,
  panspan: Uo,
  pansplay: Ko,
  panwidth: Xo,
  partials: oc,
  patt: _o,
  pattack: bo,
  pcurve: Co,
  pdec: ko,
  pdecay: vo,
  penv: xo,
  ph: Gs,
  phasdp: er,
  phaser: Qs,
  phasercenter: Xs,
  phaserdepth: Zs,
  phaserrate: Ds,
  phasersweep: Us,
  phc: Ys,
  phd: tr,
  phs: Ks,
  pitchJump: Cc,
  pitchJumpTime: Bc,
  polyTouch: iu,
  postgain: Hn,
  prel: To,
  prelease: So,
  progNum: tu,
  psus: Ao,
  psustain: qo,
  pw: Hs,
  pwrate: Vs,
  pwsweep: Fs,
  rate: Zo,
  rdim: di,
  real: nc,
  registerControl: i,
  rel: ps,
  release: ls,
  repeatTime: zc,
  resonance: Xr,
  rfade: yi,
  ring: Ki,
  ringdf: Yi,
  ringf: Xi,
  rlp: fi,
  room: li,
  roomdim: hi,
  roomfade: mi,
  roomlp: pi,
  roomsize: vi,
  rsize: Ai,
  s: Jn,
  scram: uc,
  scrub: uu,
  seconds: yc,
  semitone: ei,
  shape: Si,
  size: ki,
  slide: ti,
  smear: cc,
  songPtr: gc,
  sound: jn,
  source: Pn,
  speed: Zt,
  spread: fo,
  squiz: ji,
  src: Nn,
  stepsPerOctave: Lo,
  stretch: Mi,
  sus: as,
  sustain: us,
  sustainpedal: Wi,
  sysex: eu,
  sysexdata: su,
  sysexid: nu,
  sz: qi,
  tremolo: xs,
  tremolodepth: Bs,
  tremolophase: zs,
  tremoloshape: Es,
  tremoloskew: Os,
  tremolosync: Cs,
  triode: Vi,
  tsdelay: ec,
  uid: wc,
  unison: po,
  unit: Ji,
  v: Ir,
  val: bc,
  velocity: Ln,
  vib: Wr,
  vibmod: Vr,
  vibrato: Lr,
  vmod: Fr,
  voice: ni,
  vowel: Pi,
  waveloss: Ni,
  xsdelay: tc,
  zcrush: Jc,
  zdelay: jc,
  zmod: Mc,
  znoise: Ec,
  zrand: Sc,
  zzfx: Pc
}, Symbol.toStringTag, { value: "Module" })), au = function(t, e) {
  const [n, s] = t, [r, o] = e, [c, u] = Gt(s, r);
  return [
    [s, n - s],
    [vt((a, p) => a.concat(p), c, o), u]
  ];
}, lu = function(t, e) {
  const [n, s] = t, [r, o] = e, [c, u] = Gt(n, o);
  return [
    [n, s - n],
    [vt((p, m) => p.concat(m), r, c), u]
  ];
}, ee = function(t, e) {
  const [n, s] = t;
  return Math.min(n, s) <= 1 ? [t, e] : ee(...n > s ? au(t, e) : lu(t, e));
}, ne = function(t, e) {
  const n = t < 0, s = Math.abs(t), r = e - s, o = Array(s).fill([1]), c = Array(r).fill([0]), u = ee([s, r], [o, c]), a = F(u[1][0]).concat(F(u[1][1]));
  return n ? a.map((p) => 1 - p) : a;
}, ft = function(t, e, n) {
  const s = ne(t, e);
  return n ? je(s, -n) : s;
}, Qp = l("euclid", function(t, e, n) {
  return n.struct(ft(t, e, 0));
}), Up = l("e", function(t, e) {
  Array.isArray(t) || (t = [t]);
  const [n, s = n, r = 0] = t;
  return e.struct(ft(n, s, r));
}), { euclidrot: Kp, euclidRot: Xp } = l(["euclidrot", "euclidRot"], function(t, e, n, s) {
  return s.struct(ft(t, e, n));
}), se = function(t, e, n, s) {
  if (t < 1)
    return S;
  const o = ft(t, e, 0).join("").split("1").slice(1).map((c) => [c.length + 1, !0]);
  return s.struct(Bn(...o)).late(d(n).div(e));
}, Yp = l(["euclidLegato"], function(t, e, n) {
  return se(t, e, 0, n);
}), Zp = l(["euclidLegatoRot"], function(t, e, n, s) {
  return se(t, e, n, s);
}), { euclidish: tf, eish: ef } = l(["euclidish", "eish"], function(t, e, n, s) {
  const r = Yt(ne(t, e), new Array(t).fill(1), n);
  return s.struct(r).setSteps(e);
});
function pu(t, e, n = 0.05, s = 0.1, r = 0.1, o = globalThis.setInterval, c = globalThis.clearInterval, u = !0) {
  let a = 0, p = 0, m = 10 ** 4, y = 0.01;
  const b = (J) => n = J(n);
  r = r || s / 2;
  const w = () => {
    const J = t(), G = J + s + r;
    for (p === 0 && (p = J + y); p < G; )
      p = u ? Math.round(p * m) / m : p, e(p, n, a, J), p += n, a++;
  };
  let v;
  const k = () => {
    E(), w(), v = o(w, s * 1e3);
  }, E = () => {
    v !== void 0 && c(v), v = void 0;
  };
  return { setDuration: b, start: k, stop: () => {
    a = 0, p = 0, E();
  }, pause: () => E(), duration: n, interval: s, getPhase: () => p, minLatency: y };
}
function nf(t) {
  return new f((e) => [new x(void 0, e.span, t)]);
}
const I = (t) => {
  const e = (n) => [new x(void 0, n.span, t(n.span.begin))];
  return new f(e);
}, ht = I((t) => t % 1), re = ht.toBipolar(), xt = I((t) => 1 - t % 1), oe = xt.toBipolar(), ie = I((t) => Math.sin(Math.PI * 2 * t)), fu = ie.fromBipolar(), sf = fu._early(d(1).div(4)), rf = ie._early(d(1).div(4)), hu = I((t) => Math.floor(t * 2 % 2)), of = hu.toBipolar(), cf = N(ht, xt), uf = N(re, oe), af = N(xt, ht), lf = N(oe, re), ce = I(tt);
let Ct = 0, Bt = 0;
typeof window < "u" && document.addEventListener("mousemove", (t) => {
  Ct = t.clientY / document.body.clientHeight, Bt = t.clientX / document.body.clientWidth;
});
const pf = I(() => Ct), ff = I(() => Ct), hf = I(() => Bt), df = I(() => Bt), ue = (t) => {
  const e = t << 13 ^ t, n = e >> 17 ^ e;
  return n << 5 ^ n;
}, du = (t) => t - Math.trunc(t), ae = (t) => ue(Math.trunc(du(t / 300) * 536870912)), le = (t) => t % 536870912 / 536870912, rt = (t) => Math.abs(le(ae(t))), mu = (t, e) => {
  const n = [];
  for (let s = 0; s < e; ++s)
    n.push(le(t)), t = ue(t);
  return n;
}, yu = (t, e) => mu(ae(t), e), gu = (t) => ht.range(0, t).round().segment(t), mf = (t) => {
  const e = h(t).log2(0).floor().add(1);
  return wu(t, e);
}, wu = (t, e = 16) => {
  e = h(e);
  const n = gu(e).mul(-1).add(e.sub(1));
  return h(t).segment(e).brshift(n).band(P(1));
}, bu = (t) => I((e) => {
  const s = yu(e.floor().add(0.5), t).map((o, c) => [o, c]).sort((o, c) => (o[0] > c[0]) - (o[0] < c[0])).map((o) => o[1]), r = e.cyclePos().mul(t).floor() % t;
  return s[r];
})._segment(t), pe = (t, e, n) => {
  const s = [...Array(e).keys()].map((r) => n.zoom(d(r).div(e), d(r + 1).div(e)));
  return t.fmap((r) => s[r].repeatCycles(e)._fast(e)).innerJoin();
}, yf = l("shuffle", (t, e) => pe(bu(t), t, e)), gf = l("scramble", (t, e) => pe(he(t)._segment(t), t, e)), W = I(rt), wf = W.toBipolar(), fe = (t) => W.fmap((e) => e < t), bf = (t) => h(t).fmap(fe).innerJoin(), _f = fe(0.5), he = (t) => W.fmap((e) => Math.trunc(e * t)), vf = (t) => h(t).fmap(he).innerJoin(), de = (t, e) => (e = e.map(h), e.length == 0 ? S : t.range(0, e.length).fmap((n) => {
  const s = Math.min(Math.max(Math.floor(n), 0), e.length - 1);
  return e[s];
})), Ot = (t, e) => de(t, e).outerJoin(), me = (t, e) => de(t, e).innerJoin(), _u = (...t) => Ot(W, t), kf = (...t) => me(W, t), qf = _u;
f.prototype.choose = function(...t) {
  return Ot(this, t);
};
f.prototype.choose2 = function(...t) {
  return Ot(this.fromBipolar(), t);
};
const vu = (...t) => me(W.segment(1), t), Af = vu, ye = function(t, ...e) {
  const n = e.map((u) => h(u[0])), s = [];
  let r = P(0);
  for (const u of e)
    r = r.add(u[1]), s.push(r);
  const o = cn(s), c = function(u) {
    const a = r.mul(u);
    return o.fmap((p) => (m) => n[p.findIndex((y) => y > m, p)]).appLeft(a);
  };
  return t.bind(c);
}, ku = (...t) => ye(...t).outerJoin(), Sf = (...t) => ku(W, ...t), qu = (...t) => ye(W.segment(1), ...t).innerJoin(), Tf = qu;
function Au(t) {
  let e = Math.floor(t), n = e + 1;
  const s = (c) => 6 * c ** 5 - 15 * c ** 4 + 10 * c ** 3;
  return ((c) => (u) => (a) => u + s(c) * (a - u))(t - e)(rt(e))(rt(n));
}
const Su = (t) => t.fmap(Au);
function Tu(t) {
  const e = Math.floor(t), n = e + 1, s = rt(e), r = rt(n) + s, o = (t - e) / (n - e);
  return ((u, a, p) => u + (a - u) * p)(s, r, o) / 2;
}
const xu = (t) => t.fmap(Tu), xf = Su(ce.fmap((t) => Number(t))), Cf = xu(ce.fmap((t) => Number(t))), Bf = l(
  "degradeByWith",
  (t, e, n) => n.fmap((s) => (r) => s).appLeft(t.filterValues((s) => s > e)),
  !0,
  !0
), Of = l(
  "degradeBy",
  function(t, e) {
    return e._degradeByWith(W, t);
  },
  !0,
  !0
), zf = l("degrade", (t) => t._degradeBy(0.5), !0, !0), Ef = l(
  "undegradeBy",
  function(t, e) {
    return e._degradeByWith(
      W.fmap((n) => 1 - n),
      t
    );
  },
  !0,
  !0
), Mf = l("undegrade", (t) => t._undegradeBy(0.5), !0, !0), Jf = l("sometimesBy", function(t, e, n) {
  return h(t).fmap((s) => B(n._degradeBy(s), e(n._undegradeBy(1 - s)))).innerJoin();
}), jf = l("sometimes", function(t, e) {
  return e._sometimesBy(0.5, t);
}), Pf = l("someCyclesBy", function(t, e, n) {
  return h(t).fmap(
    (s) => B(
      n._degradeByWith(W._segment(1), s),
      e(n._degradeByWith(W.fmap((r) => 1 - r)._segment(1), 1 - s))
    )
  ).innerJoin();
}), Nf = l("someCycles", function(t, e) {
  return e._someCyclesBy(0.5, t);
}), $f = l("often", function(t, e) {
  return e.sometimesBy(0.75, t);
}), Rf = l("rarely", function(t, e) {
  return e.sometimesBy(0.25, t);
}), Wf = l("almostNever", function(t, e) {
  return e.sometimesBy(0.1, t);
}), Lf = l("almostAlways", function(t, e) {
  return e.sometimesBy(0.9, t);
}), If = l("never", function(t, e) {
  return e;
}), Hf = l("always", function(t, e) {
  return t(e);
});
function ge(t) {
  Array.isArray(t) === !1 && (t = [t]);
  const e = Ze();
  return t.every((n) => {
    const s = Ye.get(n) ?? n;
    return e[s];
  });
}
const Vf = l("whenKey", function(t, e, n) {
  return n.when(ge(t), e);
}), Ff = l("keyDown", function(t) {
  return t.fmap(ge);
}), H = function(t, e, n = !0) {
  const s = Array.isArray(t), r = Object.keys(t).length;
  return t = Ue(t, h), r === 0 ? S : e.fmap((o) => {
    let c = o;
    return s && (c = n ? Math.round(c) % r : Re(Math.round(c), 0, t.length - 1)), t[c];
  });
}, Cu = function(t, e) {
  return Array.isArray(e) && ([e, t] = [t, e]), Bu(t, e);
}, Bu = l("pick", function(t, e) {
  return H(t, e, !1).innerJoin();
}), Ou = l("pickmod", function(t, e) {
  return H(t, e, !0).innerJoin();
}), Df = l("pickF", function(t, e, n) {
  return n.apply(Cu(t, e));
}), Gf = l("pickmodF", function(t, e, n) {
  return n.apply(Ou(t, e));
}), Qf = l("pickOut", function(t, e) {
  return H(t, e, !1).outerJoin();
}), Uf = l("pickmodOut", function(t, e) {
  return H(t, e, !0).outerJoin();
}), Kf = l("pickRestart", function(t, e) {
  return H(t, e, !1).restartJoin();
}), Xf = l("pickmodRestart", function(t, e) {
  return H(t, e, !0).restartJoin();
}), Yf = l("pickReset", function(t, e) {
  return H(t, e, !1).resetJoin();
}), Zf = l("pickmodReset", function(t, e) {
  return H(t, e, !0).resetJoin();
}), { inhabit: th, pickSqueeze: eh } = l(["inhabit", "pickSqueeze"], function(t, e) {
  return H(t, e, !1).squeezeJoin();
}), { inhabitmod: nh, pickmodSqueeze: sh } = l(["inhabitmod", "pickmodSqueeze"], function(t, e) {
  return H(t, e, !0).squeezeJoin();
}), rh = (t, e) => (e = e.map(h), e.length == 0 ? S : t.fmap((n) => {
  const s = pt(Math.round(n), e.length);
  return e[s];
}).squeezeJoin());
let at;
try {
  at = window?.speechSynthesis;
} catch {
  console.warn("cannot use window: not in browser?");
}
let Wt = at?.getVoices();
function zu(t, e, n) {
  at.cancel();
  const s = new SpeechSynthesisUtterance(t);
  s.lang = e, Wt = at.getVoices();
  const r = Wt.filter((o) => o.lang.includes(e));
  typeof n == "number" ? s.voice = r[n % r.length] : typeof n == "string" && (s.voice = r.find((o) => o.name === o)), speechSynthesis.speak(s);
}
const oh = l("speak", function(t, e, n) {
  return n.onTrigger((s) => {
    zu(s.value, t, e);
  });
}), Eu = {}, Mu = async (...t) => {
  const e = await Promise.allSettled(t), n = e.filter((s) => s.status === "fulfilled").map((s) => s.value);
  return e.forEach((s, r) => {
    s.status === "rejected" && console.warn(`evalScope: module with index ${r} could not be loaded:`, s.reason);
  }), n.forEach((s) => {
    Object.entries(s).forEach(([r, o]) => {
      globalThis[r] = o, Eu[r] = o;
    });
  }), n;
};
function Ju(t, e = {}) {
  const { wrapExpression: n = !0, wrapAsync: s = !0 } = e;
  n && (t = `{${t}}`), s && (t = `(async ()=>${t})()`);
  const r = `"use strict";return (${t})`;
  return Function(r)();
}
const ju = async (t, e, n) => {
  let s = {};
  if (e) {
    const c = e(t, n);
    t = c.output, s = c;
  }
  return { mode: "javascript", pattern: await Ju(t, { wrapExpression: !!e }), meta: s };
};
class Pu {
  constructor({ onTrigger: e, onToggle: n, getTime: s }) {
    this.started = !1, this.cps = 0.5, this.getTime = s, this.time_at_last_tick_message = 0, this.collator = new Ke({ getTargetClockTime: s }), this.onToggle = n, this.latency = 0.1, this.cycle = 0, this.id = Math.round(Date.now() * Math.random()), this.worker = new SharedWorker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/clockworker-ZDiUtESR.js", import.meta.url).href,
      import.meta.url
    )), this.worker.port.start(), this.channel = new BroadcastChannel("strudeltick");
    const r = (c) => {
      const { cps: u, begin: a, end: p, cycle: m, time: y } = c;
      this.cps = u, this.cycle = m;
      const b = this.collator.calculateOffset(y) + y;
      o(a, p, b), this.time_at_last_tick_message = b;
    }, o = (c, u, a) => {
      if (this.started === !1)
        return;
      this.pattern.queryArc(c, u, { _cps: this.cps }).forEach((m) => {
        if (m.hasOnset()) {
          const b = Pt(m.whole.begin - this.cycle, this.cps) + a + this.latency, w = Pt(m.duration, this.cps);
          e?.(m, 0, w, this.cps, b);
        }
      });
    };
    this.channel.onmessage = (c) => {
      if (!this.started)
        return;
      const { payload: u, type: a } = c.data;
      switch (a) {
        case "tick":
          r(u);
      }
    };
  }
  sendMessage(e, n) {
    this.worker.port.postMessage({ type: e, payload: n, id: this.id });
  }
  now() {
    const e = (this.getTime() - this.time_at_last_tick_message) * this.cps;
    return this.cycle + e;
  }
  setCps(e = 1) {
    this.sendMessage("cpschange", { cps: e });
  }
  setCycle(e) {
    this.sendMessage("setcycle", { cycle: e });
  }
  setStarted(e) {
    this.sendMessage("toggle", { started: e }), this.started = e, this.onToggle?.(e);
  }
  start() {
    z("[cyclist] start"), this.setStarted(!0);
  }
  stop() {
    z("[cyclist] stop"), this.collator.reset(), this.setStarted(!1);
  }
  setPattern(e, n = !1) {
    this.pattern = e, n && !this.started && this.start();
  }
  log(e, n, s) {
    const r = s.filter((o) => o.hasOnset());
    console.log(`${e.toFixed(4)} - ${n.toFixed(4)} ${Array(r.length).fill("I").join("")}`);
  }
}
class Nu {
  constructor({
    interval: e,
    onTrigger: n,
    onToggle: s,
    onError: r,
    getTime: o,
    latency: c = 0.1,
    setInterval: u,
    clearInterval: a,
    beforeStart: p
  }) {
    this.started = !1, this.beforeStart = p, this.cps = 0.5, this.num_ticks_since_cps_change = 0, this.lastTick = 0, this.lastBegin = 0, this.lastEnd = 0, this.getTime = o, this.num_cycles_at_cps_change = 0, this.seconds_at_cps_change, this.onToggle = s, this.latency = c, this.clock = pu(
      o,
      // called slightly before each cycle
      (m, y, b, w) => {
        this.num_ticks_since_cps_change === 0 && (this.num_cycles_at_cps_change = this.lastEnd, this.seconds_at_cps_change = m), this.num_ticks_since_cps_change++;
        const k = this.num_ticks_since_cps_change * y * this.cps;
        try {
          const E = this.lastEnd;
          this.lastBegin = E;
          const M = this.num_cycles_at_cps_change + k;
          if (this.lastEnd = M, this.lastTick = m, m < w) {
            console.log("skip query: too late");
            return;
          }
          this.pattern.queryArc(E, M, { _cps: this.cps }).forEach((A) => {
            if (A.hasOnset()) {
              const J = (A.whole.begin - this.num_cycles_at_cps_change) / this.cps + this.seconds_at_cps_change + c, G = A.duration / this.cps, V = J - m;
              n?.(A, V, G, this.cps, J), A.value.cps !== void 0 && this.cps != A.value.cps && (this.cps = A.value.cps, this.num_ticks_since_cps_change = 0);
            }
          });
        } catch (E) {
          Ht(E), r?.(E);
        }
      },
      e,
      // duration of each cycle
      0.1,
      0.1,
      u,
      a
    );
  }
  now() {
    if (!this.started)
      return 0;
    const e = this.getTime() - this.lastTick - this.clock.duration;
    return this.lastBegin + e * this.cps;
  }
  setStarted(e) {
    this.started = e, this.onToggle?.(e);
  }
  async start() {
    if (await this.beforeStart?.(), this.num_ticks_since_cps_change = 0, this.num_cycles_at_cps_change = 0, !this.pattern)
      throw new Error("Scheduler: no pattern set! call .setPattern first.");
    z("[cyclist] start"), this.clock.start(), this.setStarted(!0);
  }
  pause() {
    z("[cyclist] pause"), this.clock.pause(), this.setStarted(!1);
  }
  stop() {
    z("[cyclist] stop"), this.clock.stop(), this.lastEnd = 0, this.setStarted(!1);
  }
  async setPattern(e, n = !1) {
    this.pattern = e, n && !this.started && await this.start();
  }
  setCps(e = 0.5) {
    this.cps !== e && (this.cps = e, this.num_ticks_since_cps_change = 0);
  }
  log(e, n, s) {
    const r = s.filter((o) => o.hasOnset());
    console.log(`${e.toFixed(4)} - ${n.toFixed(4)} ${Array(r.length).fill("I").join("")}`);
  }
}
let bt;
function ih() {
  if (!bt)
    throw new Error("no time set! use setTime to define a time source");
  return bt();
}
function Lt(t) {
  bt = t;
}
function ch({
  defaultOutput: t,
  onEvalError: e,
  beforeEval: n,
  beforeStart: s,
  afterEval: r,
  getTime: o,
  transpiler: c,
  onToggle: u,
  editPattern: a,
  onUpdateState: p,
  sync: m = !1,
  setInterval: y,
  clearInterval: b,
  id: w,
  mondo: v = !1
}) {
  const k = {
    schedulerError: void 0,
    evalError: void 0,
    code: "// LOADING",
    activeCode: "// LOADING",
    pattern: void 0,
    miniLocations: [],
    widgets: [],
    pending: !1,
    started: !1
  }, E = {
    id: w
  }, M = (_) => {
    Object.assign(k, _), k.isDirty = k.code !== k.activeCode, k.error = k.evalError || k.schedulerError, p?.(k);
  }, X = {
    onTrigger: $u({ defaultOutput: t, getTime: o }),
    getTime: o,
    onToggle: (_) => {
      M({ started: _ }), u?.(_);
    },
    setInterval: y,
    clearInterval: b,
    beforeStart: s
  }, A = m && typeof SharedWorker < "u" ? new Pu(X) : new Nu(X);
  let J = {}, G = 0, V;
  const zt = function() {
    return J = {}, G = 0, V = void 0, S;
  }, Et = async (_, q = !0) => (_ = a?.(_) || _, await A.setPattern(_, q), _);
  Lt(() => A.now());
  const we = () => A.stop(), be = () => A.start(), _e = () => A.pause(), ve = () => A.toggle(), dt = (_) => A.setCps(_), Mt = (_) => A.setCps(_ / 60);
  let Y = [];
  const ke = function(_) {
    return Y.push(_), S;
  }, qe = function(_) {
    return V = _, S;
  }, Ae = () => {
    f.prototype.p = function(q) {
      return typeof q == "string" && (q.startsWith("_") || q.endsWith("_")) ? S : (q === "$" && (q = `$${G}`, G++), J[q] = this, this);
    }, f.prototype.q = function(q) {
      return S;
    };
    try {
      for (let q = 1; q < 10; ++q)
        Object.defineProperty(f.prototype, `d${q}`, {
          get() {
            return this.p(q);
          },
          configurable: !0
        }), Object.defineProperty(f.prototype, `p${q}`, {
          get() {
            return this.p(q);
          },
          configurable: !0
        }), f.prototype[`q${q}`] = S;
    } catch (q) {
      console.warn("injectPatternMethods: error:", q);
    }
    const _ = l("cpm", function(q, mt) {
      return mt._fast(q / 60 / A.cps);
    });
    return Mu({
      all: ke,
      each: qe,
      hush: zt,
      cpm: _,
      setCps: dt,
      setcps: dt,
      setCpm: Mt,
      setcpm: Mt
    });
  };
  return { scheduler: A, evaluate: async (_, q = !0, mt = !0) => {
    if (!_)
      throw new Error("no code to evaluate");
    try {
      M({ code: _, pending: !0 }), await Ae(), Lt(() => A.now()), await n?.({ code: _ }), Y = [], mt && zt(), v && (_ = `mondolang\`${_}\``);
      let { pattern: O, meta: yt } = await ju(_, c, E);
      if (Object.keys(J).length) {
        let Q = Object.values(J);
        V && (Q = Q.map((Se) => V(Se))), O = B(...Q);
      } else V && (O = V(O));
      if (Y.length)
        for (let Q in Y)
          O = Y[Q](O);
      if (!Ut(O)) {
        const Q = `got "${typeof evaluated}" instead of pattern`;
        throw new Error(Q + (typeof evaluated == "function" ? ", did you forget to call a function?" : "."));
      }
      return z("[eval] code updated"), O = await Et(O, q), M({
        miniLocations: yt?.miniLocations || [],
        widgets: yt?.widgets || [],
        activeCode: _,
        pattern: O,
        evalError: void 0,
        schedulerError: void 0,
        pending: !1
      }), r?.({ code: _, pattern: O, meta: yt }), O;
    } catch (O) {
      z(`[eval] error: ${O.message}`, "error"), console.error(O), M({ evalError: O, pending: !1 }), e?.(O);
    }
  }, start: be, stop: we, pause: _e, setCps: dt, setPattern: Et, setCode: (_) => M({ code: _ }), toggle: ve, state: k };
}
const $u = ({ getTime: t, defaultOutput: e }) => async (n, s, r, o, c) => {
  try {
    (!n.context.onTrigger || !n.context.dominantTrigger) && await e(n, s, r, o, c), n.context.onTrigger && await n.context.onTrigger(n, t(), o, c);
  } catch (u) {
    Ht(u, "getTrigger");
  }
}, uh = function(t, e = {}) {
  const n = document.getElementById("code"), s = "background-image:url(" + t + ");background-size:contain;";
  n.style = s;
  const { className: r } = n, o = (a, p) => {
    ({
      style: () => n.style = s + ";" + p,
      className: () => n.className = p + " " + r
    })[a]();
  }, c = Object.entries(e).filter(([a, p]) => typeof p == "function");
  Object.entries(e).filter(([a, p]) => typeof p == "string").forEach(([a, p]) => o(a, p)), c.length;
}, ah = () => {
  const t = document.getElementById("code");
  t && (t.style = "");
};
z("🌀 @strudel/core loaded 🌀");
globalThis._strudelLoaded && console.warn(
  `@strudel/core was loaded more than once...
This might happen when you have multiple versions of strudel installed. 
Please check with "npm ls @strudel/core".`
);
globalThis._strudelLoaded = !0;
export {
  Ke as ClockCollator,
  Nu as Cyclist,
  d as Fraction,
  x as Hap,
  f as Pattern,
  nt as State,
  C as TimeSpan,
  de as __chooseWith,
  fe as _brandBy,
  mn as _fitslice,
  he as _irand,
  ge as _keyDown,
  yn as _match,
  pt as _mod,
  Yt as _morph,
  wn as _polymeterListSteps,
  Nt as _retime,
  $t as _slices,
  Wn as accelerate,
  jo as activeLabel,
  Lc as ad,
  xa as add,
  Wc as adsr,
  Lf as almostAlways,
  Wf as almostNever,
  Hf as always,
  Vn as amp,
  rs as analyze,
  ii as anchor,
  Da as and,
  ql as apply,
  Hc as ar,
  ca as arp,
  ia as arpWith,
  fa as arrange,
  cu as as,
  Dn as att,
  Fn as attack,
  Me as averageArray,
  uh as backgroundImage,
  Ma as band,
  hs as bandf,
  ys as bandq,
  ss as bank,
  Qe as base64ToUnicode,
  $s as bbexpr,
  Ws as bbst,
  Fp as beat,
  ws as begin,
  Cf as berlin,
  xu as berlinWith,
  mf as binary,
  wu as binaryN,
  wa as bind,
  ac as binshift,
  Bl as bite,
  ne as bjork,
  Pa as blshift,
  Ja as bor,
  ms as bp,
  br as bpa,
  wr as bpattack,
  Sr as bpd,
  Ar as bpdecay,
  hr as bpe,
  fr as bpenv,
  ds as bpf,
  gs as bpq,
  Nr as bpr,
  Pr as bprelease,
  zr as bps,
  Or as bpsustain,
  Rl as brak,
  _f as brand,
  bf as brandBy,
  Na as brshift,
  ja as bxor,
  hp as bypass,
  Ns as byteBeatExpression,
  Rs as byteBeatStartTime,
  ra as calculateSteps,
  pn as cat,
  Uc as ccn,
  Kc as ccv,
  Xa as ceil,
  Is as ch,
  nr as channel,
  Ls as channels,
  _u as choose,
  vu as chooseCycles,
  kf as chooseIn,
  me as chooseInWith,
  qf as chooseOut,
  Ot as chooseWith,
  Pp as chop,
  si as chord,
  np as chunk,
  op as chunkBack,
  fp as chunkBackInto,
  lp as chunkInto,
  ip as chunkback,
  pp as chunkbackinto,
  ap as chunkinto,
  Re as clamp,
  ah as cleanupUi,
  vc as clip,
  Ts as coarse,
  ea as code2hash,
  Nc as color,
  $c as colour,
  ic as comb,
  Uu as compose,
  rl as compress,
  ol as compressSpan,
  Ci as compressor,
  zi as compressorAttack,
  Bi as compressorKnee,
  Oi as compressorRatio,
  Ei as compressorRelease,
  il as compressspan,
  Ku as constant,
  An as contract,
  Qc as control,
  Gp as controls,
  sf as cosine,
  rf as cosine2,
  Al as cpm,
  _c as cps,
  pu as createClock,
  Tt as createParam,
  Rc as createParams,
  Ss as crush,
  or as ctf,
  Xc as ctlNum,
  Ro as ctranspose,
  g as curry,
  Tc as curve,
  sr as cut,
  rr as cutoff,
  Pt as cycleToSeconds,
  cs as dec,
  is as decay,
  zf as degrade,
  Of as degradeBy,
  Bf as degradeByWith,
  No as degree,
  to as delay,
  no as delayfb,
  eo as delayfeedback,
  co as delaysync,
  oo as delayt,
  ro as delaytime,
  xc as deltaSlide,
  lo as det,
  ao as detune,
  so as dfb,
  oi as dict,
  ri as dictionary,
  xi as dist,
  Ti as distort,
  Oa as div,
  Zr as djf,
  nn as drawLine,
  Ps as drive,
  vn as drop,
  ho as dry,
  Ic as ds,
  io as dt,
  Ms as duck,
  js as duckattack,
  Js as duckdepth,
  Ac as dur,
  qc as duration,
  Up as e,
  Sl as early,
  Kl as echo,
  Dl as echoWith,
  Gl as echowith,
  ef as eish,
  bs as end,
  rc as enhance,
  Ia as eq,
  Ha as eqt,
  Ht as errorLogger,
  Qp as euclid,
  Yp as euclidLegato,
  Zp as euclidLegatoRot,
  Xp as euclidRot,
  tf as euclidish,
  Kp as euclidrot,
  Mu as evalScope,
  ju as evaluate,
  kl as every,
  qn as expand,
  Ri as expression,
  kn as extend,
  go as fadeInTime,
  yo as fadeOutTime,
  mo as fadeTime,
  Rr as fanchor,
  hl as fast,
  up as fastChunk,
  cl as fastGap,
  N as fastcat,
  cp as fastchunk,
  ul as fastgap,
  os as fft,
  wp as filter,
  bp as filterWhen,
  vl as firstOf,
  Lp as fit,
  F as flatten,
  Ka as floor,
  Un as fm,
  Xn as fmattack,
  Zn as fmdecay,
  Kn as fmenv,
  Gn as fmh,
  Qn as fmi,
  es as fmrelease,
  ts as fmsustain,
  ns as fmvelocity,
  Yn as fmwave,
  al as focus,
  ll as focusSpan,
  pl as focusspan,
  Xu as fractionalArgs,
  fc as frameRate,
  hc as frames,
  Zi as freeze,
  wo as freq,
  Oe as freqToMidi,
  Za as fromBipolar,
  Li as fshift,
  Ii as fshiftnote,
  Hi as fshiftphase,
  $r as ftype,
  Qa as func,
  In as gain,
  it as gap,
  zo as gat,
  Oo as gate,
  te as getControlName,
  Ze as getCurrentKeyboardState,
  Vu as getEventOffsetMs,
  ze as getFreq,
  Qu as getFrequency,
  sa as getPerformanceTimeSeconds,
  Gu as getPlayableNoteValue,
  Du as getSoundIndex,
  ih as getTime,
  $u as getTrigger,
  vp as grow,
  Ra as gt,
  La as gte,
  Wo as harmonic,
  na as hash2code,
  lc as hbrick,
  Dr as hcutoff,
  fs as hold,
  dc as hours,
  Qr as hp,
  gr as hpa,
  yr as hpattack,
  qr as hpd,
  kr as hpdecay,
  pr as hpe,
  lr as hpenv,
  Gr as hpf,
  Kr as hpq,
  jr as hpr,
  Jr as hprelease,
  Br as hps,
  Cr as hpsustain,
  Ur as hresonance,
  gp as hsl,
  yp as hsla,
  ml as hurry,
  tt as id,
  sc as imag,
  th as inhabit,
  nh as inhabitmod,
  ba as innerBind,
  wl as inside,
  Pl as inv,
  jl as invert,
  gi as ir,
  vf as irand,
  _i as irbegin,
  wi as iresponse,
  bi as irspeed,
  Mn as isControlName,
  _t as isNote,
  Iu as isNoteWithOctave,
  Ut as isPattern,
  xt as isaw,
  oe as isaw2,
  Yl as iter,
  Zl as iterBack,
  tp as iterback,
  af as itri,
  lf as itri2,
  Fl as jux,
  Hl as juxBy,
  Vl as juxby,
  Di as kcutoff,
  Sa as keep,
  Ta as keepif,
  Ye as keyAlias,
  Ff as keyDown,
  Fi as krush,
  Po as label,
  _l as lastOf,
  hn as late,
  pc as lbrick,
  kc as legato,
  Eo as leslie,
  Oc as lfo,
  Ol as linger,
  Vt as listRange,
  uo as lock,
  It as logKey,
  z as logger,
  _s as loop,
  Rp as loopAt,
  Ip as loopAtCps,
  vs as loopBegin,
  qs as loopEnd,
  Wp as loopat,
  Hp as loopatcps,
  ks as loopb,
  As as loope,
  cr as lp,
  mr as lpa,
  dr as lpattack,
  vr as lpd,
  _r as lpdecay,
  ar as lpe,
  ur as lpenv,
  ir as lpf,
  Yr as lpq,
  Mr as lpr,
  Er as lprelease,
  xr as lps,
  Tr as lpsustain,
  Mo as lrate,
  Jo as lsize,
  $a as lt,
  Wa as lte,
  Dt as mapArgs,
  da as mask,
  Fu as midi2note,
  et as midiToFreq,
  ru as midibend,
  Vc as midichan,
  Gc as midicmd,
  Fc as midimap,
  Dc as midiport,
  ou as miditouch,
  mc as minutes,
  za as mod,
  ai as mode,
  Dp as morph,
  df as mouseX,
  ff as mouseY,
  hf as mousex,
  pf as mousey,
  $o as mtranspose,
  Ba as mul,
  $n as n,
  Je as nanFallback,
  Va as ne,
  Fa as net,
  If as never,
  Hr as noise,
  Rn as note,
  lt as noteToMidi,
  R as nothing,
  Yc as nrpnn,
  Zc as nrpv,
  Ho as nudge,
  $ as numeralArgs,
  Ue as objectMap,
  Vo as octave,
  Io as octaveR,
  ui as octaves,
  Gi as octer,
  Qi as octersub,
  Ui as octersubsub,
  $l as off,
  ci as offset,
  $f as often,
  Ga as or,
  Fo as orbit,
  _a as outerBind,
  bl as outside,
  Do as overgain,
  Go as overshape,
  gn as pace,
  $e as pairs,
  Il as palindrome,
  Qo as pan,
  Bo as panchor,
  Yo as panorient,
  Uo as panspan,
  Ko as pansplay,
  Xo as panwidth,
  Ne as parseFractional,
  Ft as parseNumeral,
  oc as partials,
  _o as patt,
  bo as pattack,
  Co as pcurve,
  ko as pdec,
  vo as pdecay,
  xo as penv,
  xf as perlin,
  Su as perlinWith,
  Gs as ph,
  er as phasdp,
  Qs as phaser,
  Xs as phasercenter,
  Zs as phaserdepth,
  Ds as phaserrate,
  Us as phasersweep,
  Ys as phc,
  tr as phd,
  Ks as phs,
  Cu as pick,
  Df as pickF,
  Qf as pickOut,
  Yf as pickReset,
  Kf as pickRestart,
  eh as pickSqueeze,
  Ou as pickmod,
  Gf as pickmodF,
  Uf as pickmodOut,
  Zf as pickmodReset,
  Xf as pickmodRestart,
  sh as pickmodSqueeze,
  Pe as pipe,
  Cc as pitchJump,
  Bc as pitchJumpTime,
  fl as ply,
  la as pm,
  qa as polyBind,
  iu as polyTouch,
  St as polymeter,
  ua as polyrhythm,
  Hn as postgain,
  Ea as pow,
  aa as pr,
  To as prel,
  So as prelease,
  Ll as press,
  Wl as pressBy,
  tu as progNum,
  Ao as psus,
  qo as psustain,
  P as pure,
  Hs as pw,
  Vs as pwrate,
  Fs as pwsweep,
  W as rand,
  wf as rand2,
  Af as randcat,
  bu as randrun,
  tl as range,
  nl as range2,
  el as rangex,
  Rf as rarely,
  Zo as rate,
  sl as ratio,
  di as rdim,
  nc as real,
  Vp as ref,
  l as register,
  i as registerControl,
  h as reify,
  ps as rel,
  ls as release,
  ot as removeUndefineds,
  ep as repeatCycles,
  zc as repeatTime,
  ch as repl,
  Xr as resonance,
  dn as rev,
  yi as rfade,
  mp as rib,
  dp as ribbon,
  Ki as ring,
  Yi as ringdf,
  Xi as ringf,
  fi as rlp,
  li as room,
  hi as roomdim,
  mi as roomfade,
  pi as roomlp,
  vi as roomsize,
  je as rotate,
  Ua as round,
  Ai as rsize,
  gu as run,
  Jn as s,
  Cp as s_add,
  Ap as s_alt,
  qp as s_cat,
  Ep as s_contract,
  Op as s_expand,
  zp as s_extend,
  Sp as s_polymeter,
  Bp as s_sub,
  Tp as s_taper,
  xp as s_taperlist,
  Mp as s_tour,
  Jp as s_zip,
  ht as saw,
  re as saw2,
  uc as scram,
  gf as scramble,
  uu as scrub,
  yc as seconds,
  El as seg,
  zl as segment,
  ei as semitone,
  fn as seq,
  ha as seqPLoop,
  D as sequence,
  cn as sequenceP,
  Aa as set,
  oa as setStringParser,
  Lt as setTime,
  Si as shape,
  Tn as shrink,
  Sn as shrinklist,
  yf as shuffle,
  I as signal,
  S as silence,
  fu as sine,
  ie as sine2,
  ki as size,
  On as slice,
  ti as slide,
  yl as slow,
  rp as slowChunk,
  K as slowcat,
  Kt as slowcatPrime,
  sp as slowchunk,
  cc as smear,
  Yu as sol2note,
  Nf as someCycles,
  Pf as someCyclesBy,
  jf as sometimes,
  Jf as sometimesBy,
  gc as songPtr,
  jn as sound,
  Pn as source,
  gl as sparsity,
  oh as speak,
  Zt as speed,
  $p as splice,
  Gt as splitAt,
  fo as spread,
  hu as square,
  of as square2,
  rh as squeeze,
  va as squeezeBind,
  ji as squiz,
  Nn as src,
  B as stack,
  pa as stackBy,
  ln as stackCentre,
  un as stackLeft,
  an as stackRight,
  nf as steady,
  ka as stepBind,
  bn as stepalt,
  j as stepcat,
  jp as steps,
  Lo as stepsPerOctave,
  Mi as stretch,
  Np as striate,
  Qt as stringifyValues,
  ma as struct,
  Eu as strudelScope,
  Xl as stut,
  Ql as stutWith,
  Ul as stutwith,
  Ca as sub,
  ya as superimpose,
  as as sus,
  us as sustain,
  Wi as sustainpedal,
  Jl as swing,
  Ml as swingBy,
  eu as sysex,
  su as sysexdata,
  nu as sysexid,
  qi as sz,
  _n as take,
  ce as time,
  Bn as timeCat,
  kp as timecat,
  Ya as toBipolar,
  xe as tokenizeNote,
  xn as tour,
  xs as tremolo,
  Bs as tremolodepth,
  zs as tremolophase,
  Es as tremoloshape,
  Os as tremoloskew,
  Cs as tremolosync,
  cf as tri,
  uf as tri2,
  Vi as triode,
  ec as tsdelay,
  wc as uid,
  Mf as undegrade,
  Ef as undegradeBy,
  Ge as unicodeToBase64,
  Zu as uniq,
  ta as uniqsort,
  De as uniqsortr,
  po as unison,
  Ji as unit,
  Ir as v,
  bc as val,
  Hu as valueToMidi,
  Ln as velocity,
  Wr as vib,
  Vr as vibmod,
  Lr as vibrato,
  Fr as vmod,
  ni as voice,
  Pi as vowel,
  Ni as waveloss,
  Sf as wchoose,
  qu as wchooseCycles,
  Nl as when,
  Vf as whenKey,
  ga as withValue,
  _p as within,
  Tf as wrandcat,
  zn as xfade,
  tc as xsdelay,
  Jc as zcrush,
  jc as zdelay,
  Cn as zip,
  vt as zipWith,
  Mc as zmod,
  Ec as znoise,
  Tl as zoom,
  xl as zoomArc,
  Cl as zoomarc,
  Sc as zrand,
  Pc as zzfx
};
